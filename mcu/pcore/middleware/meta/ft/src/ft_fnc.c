/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*******************************************************************************
*  Modification Notice:
*  --------------------------
*  This software is modified by MediaTek Inc. and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2001
*
*******************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *   ft_fnc_r.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Factory testing function library
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *              HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/
/*************************************************************************
* Include Statements for KAL
 *************************************************************************/
#include "kal_public_defs.h" //MSBB change #include "stack_common.h"
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
#include "task_config.h"
#include "svc_sap.h"
#include "ft_msgid.h"
/*************************************************************************
* Include Statements for MAUI
 *************************************************************************/
/**************************************************************************
 * System Service header
 *************************************************************************/
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "kal_public_defs.h"
#include "string.h"
#include "fs_type.h"
#include "fs_func.h"
#include "fs_errcode.h"
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"
#include "init.h"
/**************************************************************************
 * HAL header
 *************************************************************************/
#include "dcl.h"
#include "drv_comm.h"
#include "l1audio.h"
// include the device.h for the GPIO_DEV_LED_KEY definition
// (Baseband tool LED, vibrator definitions)
#include "device.h"
#include "tst_hal_internal_wrapper_defs.h"
/**************************************************************************
 * FT header
 *************************************************************************/
#include "ft_msg.h"
#include "ft_public.h"
#include "ft_private.h"
#include "ft_fnc_misc.h"
#include "ft_fnc_l1rf.h"
#include "ft_fnc_wcdma.h"
/**************************************************************************
 * custom header
 *************************************************************************/
#include "meta_customize.h"
#include "custom_em.h"
//#include "usb_custom.h"
#include "custom_equipment.h"
/**************************************************************************
 * UL1 RF header
 *************************************************************************/
#if defined(__UMTS_RAT__) && defined(__MTK_UL1_FDD__)
#include "ul1cal.h"
#endif // #if defined(__UMTS_RAT__) && defined(__MTK_UL1_FDD__)
//MSBB remove #include "fctycomp_config.h"
/**************************************************************************
 * NVRAM header
 *************************************************************************/
#include "nvram_data_items.h"
/**************************************************************************
 * audio (MED) header
 *************************************************************************/
#ifndef MED_NOT_PRESENT
#include "aud_defs.h"
#include "med_struct.h"
#endif // MED_NOT_PRESENT
#include "tst_def.h"
/**************************************************************************
 * SLA header
 *************************************************************************/
#include "meta_sec_support.h"
/*************************************************************************
 * Non-MODEM BSP
 *************************************************************************/
kal_uint32 ft_event_group_ptr; /**< \brief ft event group pointer */

extern kal_bool Drv_ReadReg(kal_uint32 addr, kal_uint16 *data);
extern kal_bool Drv_WriteReg(kal_uint32 addr, kal_uint16 data);
extern void tst_log_primitive_without_filter_check(ilm_struct*,
        kal_uint8,
        kal_uint32);
extern void dhl_FT_log_primitive(ilm_struct *ilm);
/*******************************************************************************
 *
 *  Utility Functions
 *
 *******************************************************************************/
void _FT_ALLOC_MSG(ilm_struct* ilm_ptr, kal_uint16 size, kal_bool IsFtMsg, kal_bool IsCcMsg)
{
    ilm_ptr->local_para_ptr = NULL;
    ilm_ptr->peer_buff_ptr = NULL;
    if( 0 < size ) {
        if( KAL_TRUE == IsCcMsg ) {
            if( NULL == (ilm_ptr->local_para_ptr=construct_cc_non_cached_local_para(size, TD_RESET)) ) {
                ASSERT(0); // assert it!
            }
        }
        else {
            if( NULL == (ilm_ptr->local_para_ptr=construct_local_para(size, TD_RESET)) ) {
                ASSERT(0); // assert it!
            }
        }
    }
    if( KAL_TRUE == IsFtMsg ) {
        // reset content of FT primitive first
		if(size > sizeof(FT_H) && NULL != ((char *)ilm_ptr->local_para_ptr)+sizeof(FT_H))
		{
			kal_mem_set(((char *)ilm_ptr->local_para_ptr)+sizeof(FT_H), 0, size-sizeof(FT_H));
		}
    }
}

void _FT_CONSTRUCT_CC_MSG(const ilm_struct* ilm_ptr, ilm_struct* ilm_cc_ptr)
{
    if(ilm_ptr == NULL || ilm_cc_ptr == NULL)
    {
        ASSERT(0);
    }
    _FT_ALLOC_MSG(ilm_cc_ptr, ilm_ptr->local_para_ptr->msg_len, KAL_FALSE, KAL_TRUE);
    kal_mem_cpy(ilm_cc_ptr->local_para_ptr, ilm_ptr->local_para_ptr, ilm_ptr->local_para_ptr->msg_len);
    if( ilm_ptr->peer_buff_ptr != NULL )
    {
        kal_uint8 *pdu_ptr, *pdu_cc_ptr;
        kal_uint16 size;     
        if( NULL == (ilm_cc_ptr->peer_buff_ptr=construct_cc_non_cached_peer_buff(ilm_ptr->peer_buff_ptr->pdu_len,
                                                                               0,
                                                                               0,
                                                                               TD_RESET)) ) {
            ASSERT(0); // assert it!
        }
        pdu_ptr = (kal_uint8*) get_peer_buff_pdu(ilm_ptr->peer_buff_ptr, &size);
        pdu_cc_ptr = (kal_uint8*) get_peer_buff_pdu(ilm_cc_ptr->peer_buff_ptr, &size);
        kal_mem_cpy(pdu_cc_ptr, pdu_ptr, size);
    }
}

void _FT_SendFtMsgToPcByToken(ilm_struct  *ilm_ptr, kal_uint16  token)
{
#if !defined(__DHL_MODULE__)
    _FT_SendFtMsgByToken(MOD_FT, MOD_TST, FT_TST_SAP, MSG_ID_FT_TO_TST, ilm_ptr, token);
#else
    _FT_SendFtMsgByToken(MOD_FT, MOD_DHL, FT_TST_SAP, MSG_ID_FT_TO_TST, ilm_ptr, token);
#endif // #if !defined(__DHL_MODULE__)
}

void _FT_SendFtMsgByToken(module_type  src_mod, module_type  dest_mod, sap_type  sap, msg_type  msg, ilm_struct  *ilm_ptr, kal_uint16  token)
{
    ilm_ptr->src_mod_id  = src_mod;
    ilm_ptr->dest_mod_id = dest_mod;
    ilm_ptr->msg_id = msg;
    ilm_ptr->sap_id = sap;
#if !defined(__DHL_MODULE__)
    if (dest_mod == MOD_TST) {
#else
    if (dest_mod == MOD_DHL) {
#endif // #if !defined(__DHL_MODULE__)
        ((FT_H *)(ilm_ptr->local_para_ptr))->token=token;
        tst_log_primitive(ilm_ptr);
        ilm_ptr->src_mod_id  = (module_type)0xA1;
        ilm_ptr->dest_mod_id = (module_type)0;
        ilm_ptr->sap_id      = (sap_type)0xA3;
        ilm_ptr->msg_id      = (msg_type)2;
#if !defined(__DHL_MODULE__)
        // directly copy primitive to TST ring buffer
        tst_log_primitive_without_filter_check(
                ilm_ptr,
                RS232_LOGGED_PRIMITIVE_TYPE,
                MSG_ID_LOGGED_PRIMITIVE);
#else
        dhl_FT_log_primitive(ilm_ptr);                
#endif // #if !defined(__DHL_MODULE__)
        // cancel ilm, because we directly access TST ring buffer, no need to send primitive to TST
        destroy_ilm(ilm_ptr);
        return;
    }
    msg_send6(src_mod, dest_mod, sap, msg, ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
}

void FT_SendDeniedMsgIdCnf(kal_uint16 deniedMsgId, kal_uint32 status)
{
    ilm_struct    ilm_ptr;
    FT_DENIED_MSG_ID_CNF *ft_cnf;
    FT_ALLOC_MSG(&ilm_ptr, sizeof(FT_DENIED_MSG_ID_CNF));
    ft_cnf = (FT_DENIED_MSG_ID_CNF *)ilm_ptr.local_para_ptr;
    ft_cnf->header.ft_msg_id = FT_CMD_DENIED_CNF_ID;
    ft_cnf->deniedMsgId = deniedMsgId;
    ft_cnf->status = status;
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}

/*******************************************************************************
 *
 *  FT Module Initialization Functions
 *
 *******************************************************************************/
/*******************************************************************************
 * FUNCTION
 *   FT_InitFtData
 *
 * DESCRIPTION
 *
 * CALLS
 *
 * PARAMETERS
 *
 * RETURNS
 *   None
 *
 * GLOBALS AFFECTED
 *******************************************************************************/
extern kal_int8 FT_FAT_Handle_Clear(void);
void FT_InitFtData()
{
    FT_FAT_Handle_Clear();
    // init event group
    ft_event_group_ptr = (kal_uint32) kal_create_event_group("FtEvent");
}
/**
 * This function calls Dcl PMU interface to read PMIC register
 * @register_index the index of the register to be written
 */
kal_bool ft_pmic_reg_read(kal_uint16 *data, kal_uint16 register_index)
{
    kal_bool status;
    DCL_HANDLE handle;
    PMU_CTRL_MISC_GET_REGISTER_VALUE val;
    val.offset=register_index;
    handle=DclPMU_Open(DCL_PMU, FLAGS_NONE);
    if(DclPMU_Control(handle, MISC_GET_REGISTER_VALUE, (DCL_CTRL_DATA_T *)&val) != STATUS_OK)
    {
        // in this case, there might be not supported (if the driver did not support yet, usually in development phase)
        status = KAL_FALSE;
    }
    else
    {
        status = KAL_TRUE;
    }
    DclPMU_Close(handle);
    *data = val.value;
    return status;
}
/**
 * This function calls Dcl PMU interface to read PMIC register
 * @param data the register value to be written to PMIC
 * @param register_index the index of the register to be written
 */
kal_bool ft_pmic_reg_write(kal_uint16 data, kal_uint16 register_index)
{
    kal_bool status;
    DCL_HANDLE handle;
    PMU_CTRL_MISC_SET_REGISTER_VALUE val;
    val.offset=register_index;
    val.value=data;
    handle=DclPMU_Open(DCL_PMU, FLAGS_NONE);
    if(DclPMU_Control(handle, MISC_SET_REGISTER_VALUE, (DCL_CTRL_DATA_T *)&val) != STATUS_OK)
    {
        // in this case, there might be not supported (if the driver did not support yet, usually in development phase)
        status = KAL_FALSE;
    }
    else
    {
        status = KAL_TRUE;
    }
    DclPMU_Close(handle);
    return status;
}
/**
 * This function handles the PMIC register read operation
 * @param req FT task PMIC register read request
 * @param Regtype register type
 */
void FT_FtPMICRegisterRead(ft_PMICRegisterRead_req_T* req,unsigned char RegType) // for build warning
{
    ilm_struct  ilm_ptr;
    ft_PMICRegisterRead_cnf_T* ptrMsg;
    FT_ALLOC_MSG(&ilm_ptr, sizeof(ft_PMICRegisterRead_cnf_T));
    ptrMsg = (ft_PMICRegisterRead_cnf_T *)ilm_ptr.local_para_ptr;
    ptrMsg->status = KAL_FALSE;
    if(RegType ==FT_PMICReg)
    {
        ptrMsg->header.ft_msg_id = FT_PMIC_REG_READ_CNF_ID;
        /*
         * Note: The custom_pmic_reg_read interface is changed due to HAL,
         * the reference is changed to ft_pmic_reg_read
         */
        ptrMsg->status = ft_pmic_reg_read(&(ptrMsg->value), (kal_uint16)req->addr);
    }
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}
/**
 * This function handles the PMIC register write operation
 * @param req FT task PMIC register write request
 * @param Regtype register type
 */
void FT_FtPMICRegisterWrite(ft_PMICRegisterWrite_req_T* req,unsigned char RegType)
{
    ilm_struct  ilm_ptr;
    ft_PMICRegisterWrite_cnf_T *ptrMsg ;
    FT_ALLOC_MSG(&ilm_ptr, sizeof(ft_PMICRegisterWrite_cnf_T));
    ptrMsg = (ft_PMICRegisterWrite_cnf_T *)ilm_ptr.local_para_ptr;
    ptrMsg->status = KAL_FALSE;
    if(RegType ==FT_PMICReg)
    {
        ptrMsg->header.ft_msg_id = FT_PMIC_REG_WRITE_CNF_ID;
        /*
         * Note: The custom_pmic_reg_write interface is changed due to HAL,
         * the reference is changed to ft_pmic_reg_write
         */
        ptrMsg->status = ft_pmic_reg_write(req->value, (kal_uint16)req->addr);
    }
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}

/*******************************************************************************
 * FUNCTION
 *   FT_FtRegisterRead()
 *
 * DESCRIPTION
 *   Handle the request of reading Register Req
 *
 * CALLS
 *   Drv_ReadReg(.)
 *
 * PARAMETERS
 *   *req
 *
 * RETURNS
 *   None
 *
 * GLOBALS AFFECTED
 *   None
 *******************************************************************************/
void FT_FtRegisterRead(ft_RegisterRead_req_T* req,unsigned char RegType)
{
    kal_uint8 status;
    ilm_struct  ilm_ptr;
    ft_RegisterRead_cnf_T* ptrMsg;
    FT_ALLOC_MSG(&ilm_ptr, sizeof(ft_RegisterRead_cnf_T));
    /* if ptrMsg != NULL*/
    ptrMsg = (ft_RegisterRead_cnf_T *)ilm_ptr.local_para_ptr;
    status = KAL_FALSE; // for build warning
    if(RegType ==FT_BaseBandReg)
    {
        ptrMsg->header.ft_msg_id = FT_REG_READ_CNF_ID;
        status=Drv_ReadReg(req->addr,&ptrMsg->value);
    }
    if(status==KAL_TRUE)
    { status=FT_CNF_OK; }
    else
    { status=FT_CNF_FAIL; }
    ptrMsg->status = status;
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}


/*******************************************************************************
 * FUNCTION
 *   FT_FtRegisterWrite()
 *
 * DESCRIPTION
 *   Handle the request of Writing Register Req
 *
 * CALLS
 *   Drv_WriteReg(.)
 *
 * PARAMETERS
 *   *req
 *
 * RETURNS
 *   None
 *
 * GLOBALS AFFECTED
 *   None
 *******************************************************************************/
void FT_FtRegisterWrite(ft_RegisterWrite_req_T* req,unsigned char RegType)
{
    kal_uint8 status;
    ilm_struct  ilm_ptr;
    ft_RegisterWrite_cnf_T *ptrMsg ;
    FT_ALLOC_MSG(&ilm_ptr, sizeof(ft_RegisterWrite_cnf_T));
    status = KAL_FALSE; // for build warning
    /* if ptrMsg != NULL*/
    ptrMsg = (ft_RegisterWrite_cnf_T *)ilm_ptr.local_para_ptr;
    if(RegType ==FT_BaseBandReg)
    {
        ptrMsg->header.ft_msg_id = FT_REG_WRITE_CNF_ID;
        status=Drv_WriteReg(req->addr,req->value);
    }
    if(status==KAL_TRUE)
    { status=FT_CNF_OK; }
    else
    { status=FT_CNF_FAIL; }
    ptrMsg->status = status;
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}

/*******************************************************************************
 * FUNCTION
 *   FT_FtADC_GetMeaData()
 *
 * DESCRIPTION
 *   Handle the request of Getting MeaData
 *
 * CALLS
 *   ADC_GetData2Meta(.)
 *
 * PARAMETERS
 *   *req
 *
 * RETURNS
 *   None
 *
 * GLOBALS AFFECTED
 *   None
 *******************************************************************************/
void  FT_FtADC_GetMeaData(ft_FtADC_GetMeaData_req_T* req)
{
    ilm_struct  ilm_ptr;
    ft_FtADC_GetMeaData_cnf_T *ptrMsg ;
    ADC_CTRL_GET_DATA_2_META_T data2meta;
    DCL_HANDLE adc_handle;
    memset(&data2meta, 0, sizeof(ADC_CTRL_GET_DATA_2_META_T));
    FT_ALLOC_MSG(&ilm_ptr, sizeof(ft_FtADC_GetMeaData_cnf_T));
    ptrMsg = (ft_FtADC_GetMeaData_cnf_T *)ilm_ptr.local_para_ptr;
    ASSERT(ptrMsg);
    ptrMsg->status=FT_CNF_OK;
    ptrMsg->header.ft_msg_id = FT_ADC_GETMEADATA_CNF_ID;
    adc_handle = DclHADC_Open(DCL_ADC, FLAGS_NONE);
    data2meta.u1Channel = req->Sel;
    data2meta.u2MeaCount = req->Meacount;
    if(DclHADC_Control(adc_handle, ADC_CMD_GET_DATA_2_META, (DCL_CTRL_DATA_T *)& data2meta) != STATUS_OK)
    {
        ptrMsg->status = FT_CNF_FAIL;
    }
    ptrMsg->value = data2meta.u4ADCData;
    if(DclHADC_Close(adc_handle) != STATUS_OK)
    {
        ptrMsg->status = FT_CNF_FAIL;
    }
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}
/*******************************************************************************
 *
 *  Version Info functionality
 *
 *******************************************************************************/
void FT_GetVersionInfo(void) {

    ilm_struct           ilm_ptr;
    FT_VER_INFO_CNF     *ptrMsg;
    version_struct       ver_struct;
	memset(&ver_struct, 0, sizeof(version_struct));
    FT_ALLOC_MSG(&ilm_ptr, sizeof(FT_VER_INFO_CNF));
    // if ptrMsg != NULL
    ptrMsg = (FT_VER_INFO_CNF *)ilm_ptr.local_para_ptr;
    // assign primitive id
    ptrMsg->header.ft_msg_id = FT_VER_INFO_CNF_ID;
    // get version info
    INT_VersionNumbers(&ver_struct);
    // check
    if( NULL == ver_struct.bb_chip ) {
        ver_struct.bb_chip = "Unknown";
    }
    if( NULL == ver_struct.dsp_fw ) {
        ver_struct.dsp_fw = "Unknown";
    }
    if( NULL == ver_struct.dsp_ptch ) {
        ver_struct.dsp_ptch = "Unknown";
    }
    if( NULL == ver_struct.mcu_sw ) {
        ver_struct.mcu_sw = "Unknown";
    }
    if( NULL == ver_struct.bb_board ) {
        ver_struct.bb_board = "Unknown";
    }
    if( NULL == ver_struct.mcu_sw_flavor ) {
        ver_struct.mcu_sw_flavor = "Unknown";
    }
    // assign BaseBand chip version string
    strcpy((kal_char *)ptrMsg->bb_chip, ver_struct.bb_chip);
    // assign ECO version
    kal_mem_set(ptrMsg->eco_ver, 0, 4);
    // assign DSP firmware version string
    strcpy((kal_char *)ptrMsg->dsp_fw, ver_struct.dsp_fw);
    // assign DSP patch version string
    strcpy((kal_char *)ptrMsg->dsp_patch, ver_struct.dsp_ptch);
    // assign S/W version string
    strcpy((kal_char *)ptrMsg->sw_ver, ver_struct.mcu_sw);
    // assign H/W version string
    strcpy((kal_char *)ptrMsg->hw_ver, ver_struct.bb_board);
    // assign Melody version string
    strcpy((kal_char *)ptrMsg->melody_ver, "Unknown");
    // assign S/W flavor version string
    strcpy((kal_char *)ptrMsg->sw_flavor, ver_struct.mcu_sw_flavor);
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}
/*******************************************************************************
 *
 *  FT task test alive
 *
 *******************************************************************************/
void FT_TestAlive(void) {

    FT_IS_ALIVE_CNF *pMsg;
    ilm_struct       ilm_ptr;
    FT_ALLOC_MSG(&ilm_ptr, sizeof(FT_IS_ALIVE_CNF));
    pMsg=(FT_IS_ALIVE_CNF *)ilm_ptr.local_para_ptr;
    pMsg->header.ft_msg_id = FT_IS_ALIVE_CNF_ID;
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}
/**
 * This api calls the DCL interface to check and clear the PDN1 bit 7 set by flashtool
 * and scrambles theh powerkey1
 */
 #if (!defined(__SMART_PHONE_MODEM__))
static kal_bool FT_ClearPowerKey(void)
{
    /// Driver RTC FT Power Off request
    RTC_CTRL_FT_POWEROFF_T ft_cmd_data;
    DCL_HANDLE rtc_handle = DclRTC_Open(DCL_RTC, FLAGS_NONE);
    memset(&ft_cmd_data, 0, sizeof(RTC_CTRL_FT_POWEROFF_T));
    DclRTC_Control(rtc_handle, RTC_CMD_FT_POWEROFF, (DCL_CTRL_DATA_T *) &ft_cmd_data);
    DclRTC_Close(rtc_handle);
    return (kal_bool)ft_cmd_data.fgMetaReset;
}
 #endif
/*******************************************************************************
 *
 * FUNCTION
 *   FT_PowerOff
 *
 * DESCRIPTION
 *   Power off sequence in META mode
 *
 * CALLS
 *   custom_ft_util_check_if_usb_enable_support for check the USB_ENABLE compile option
 *   USB_PowerControl
 *   DclRTC_Open/DclRTC_Control (RTC_CMD_FT_POWEROFF command)/DclRTC_Close for RTC power off sequence (scramble PDN1 bit 7 for flashtool entering META mode)
 *   DclPW_Open/DclPW_Control (PW_CMD_POWEROFF command)/DclPW_Close for Driver power off sequence
 *   DclWDT_Open/DclWDT_Control (WDT_CMD_DRV_RESET command)/DclWDT_Close for Driver reset sequence
 *
 * PARAMETERS
 *   void
 *
 * RETURNS
 *   void
 *
 * GLOBALS AFFECTED
 *   N/A
 *
 *******************************************************************************/
void FT_PowerOff(void)
{
#if (!defined(__SMART_PHONE_MODEM__))
    kal_bool toolUsbReset = KAL_FALSE;
    if(KAL_TRUE == custom_ft_util_check_if_usb_enable_support())
    {
         // shutdown USB module
         /**
          * USB_PowerControl(KAL_FALSE) is no longer 
          * to disable the usb power anymore.
          **/
#if defined(__USB_ENABLE__)
         DCL_BOOL dcl_data = DCL_TRUE;
         DCL_HANDLE  usb_dcl_handle;
         
         usb_dcl_handle = DclUSB_DRV_Open(DCL_USB, FLAGS_NONE);
         
         DclUSB_DRV_Control(usb_dcl_handle, USB_DRV_CMD_PDN_ENABLE, (DCL_CTRL_DATA_T  *)&dcl_data);
         DclUSB_DRV_Close(usb_dcl_handle);
         //   USB_PDNmode(KAl_TRUE);
#endif //#if defined(__USB_ENABLE__)    
    }
    Custom_META_USBVirtualComDisconnect();
    toolUsbReset = FT_ClearPowerKey();
    if(tst_hal_USBDL_Is_USB_Download_Mode() == KAL_TRUE ||
            /* Note: FEATURE compile option and references should be checked before patch-back */
            tst_hal_USBDL_Is_USB_Fast_Meta_Mode() == KAL_TRUE)
    {
        // Driver power off sequence
        {
            DCL_HANDLE dcl_pmu_handle;
            dcl_pmu_handle=DclPW_Open(DCL_PW, FLAGS_NONE);
            DclPW_Control(dcl_pmu_handle,PW_CMD_POWEROFF,NULL);
            DclPW_Close(dcl_pmu_handle);
        }
        // really turn off the target because USB will provide power automatically to target side
        if(toolUsbReset == KAL_FALSE)
        {
            DCL_HANDLE dcl_wdt_handle;
            dcl_wdt_handle = DclWDT_Open(DCL_WDT, FLAGS_NONE);
            DclWDT_Control(dcl_wdt_handle, WDT_CMD_DRV_RESET, FLAGS_NONE);
            DclWDT_Close(dcl_wdt_handle);
        }
        else
        {
            while(1);
        }
    }
#endif // #if (!defined(__SMART_PHONE_MODEM__))
}
/***********************************************
 * FT task self message API
 * This API is called in other task context
 * or HISR conext!
 **********************************************/
void ft_send_in_proc_call_req(ft_in_proc_call_type func, kal_uint32 func_arg1, void *func_arg2)
{
    ft_in_proc_call_req_struct *ptrMsg;
    ptrMsg = (ft_in_proc_call_req_struct *)construct_local_para(sizeof(ft_in_proc_call_req_struct), TD_RESET);
    if(NULL == ptrMsg)
    {
        ASSERT(0);    
    }    
    ptrMsg->func = func;
    ptrMsg->func_arg1 = func_arg1;
    ptrMsg->func_arg2 = func_arg2;    
    msg_send5(kal_get_active_module_id(), MOD_FT, FT_TST_SAP, (msg_type)MSG_ID_FT_IN_PROC_CALL_REQ, (local_para_struct*)ptrMsg);
}
/***********************************************
 * FT task self message (In Proc Call handler)
 **********************************************/
void ft_in_proc_call_handler(ilm_struct *ilm_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ft_in_proc_call_req_struct *ptrMsg = (ft_in_proc_call_req_struct*) ilm_ptr->local_para_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(ptrMsg->func != NULL);
    ptrMsg->func(ptrMsg->func_arg1, ptrMsg->func_arg2);
}


/*******************************************************************************
 *
 *  SLA functionality
 *
 *******************************************************************************/
kal_bool FT_MetaSLA_Is_Enabled(void)
{
    return MetaSLA_Is_Enabled();
}

void FT_GetSlaStatus(void)
{
    ilm_struct              ilm_ptr;
    FT_GET_SLA_STATUS_CNF   *ptrMsg;

    FT_ALLOC_MSG(&ilm_ptr, sizeof(FT_GET_SLA_STATUS_CNF));
    // if ptrMsg != NULL
    ptrMsg = (FT_GET_SLA_STATUS_CNF *)ilm_ptr.local_para_ptr;
    // assign primitive id
    ptrMsg->header.ft_msg_id = FT_GET_SLA_STATUS_CNF_ID;
    ptrMsg->sla_config = (kal_uint16) FT_MetaSLA_Is_Enabled();
    ptrMsg->sla_verified= (kal_uint16) MetaSLA_Is_Verified();
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}

extern kal_uint16 Custom_META_CheckSlaVer(kal_uint32 sla_ver_from_pc);
void FT_CheckSlaVer(FT_CHECK_SLA_VER_REQ *ft_check_sla_ver_op)
{
    ilm_struct              ilm_ptr;
    FT_CHECK_SLA_VER_CNF   *ptrMsg;

    FT_ALLOC_MSG(&ilm_ptr, sizeof(FT_CHECK_SLA_VER_CNF));
    // if ptrMsg != NULL
    ptrMsg = (FT_CHECK_SLA_VER_CNF *)ilm_ptr.local_para_ptr;
    // assign primitive id
    ptrMsg->header.ft_msg_id = FT_CHECK_SLA_VER_CNF_ID;
    ptrMsg->status = Custom_META_CheckSlaVer(ft_check_sla_ver_op->sla_ver_from_pc);
    FT_SEND_MSG_TO_PC(&ilm_ptr);
}

extern kal_bool Custom_META_GetSlaPara(kal_uint8* para, kal_uint32 para_len);
void FT_GetSlaPara(void)
{
    ilm_struct              ilm_ptr;
    FT_GET_SLA_PARA_CNF     *ptrMsg;
    kal_uint8   para[META_SLA_RND_LEN];
    kal_uint32  ret = 0;
    kal_uint8   cust_para[256];
    kal_bool    bRet = 0;

    FT_ALLOC_MSG(&ilm_ptr, sizeof(FT_GET_SLA_PARA_CNF));

    ptrMsg = (FT_GET_SLA_PARA_CNF *)ilm_ptr.local_para_ptr;
    ASSERT(ptrMsg);
    ptrMsg->header.ft_msg_id = FT_GET_SLA_PARA_CNF_ID;

    if (META_SLA_RND_LEN > RND_BUF_LEN)
    {
        // ft message buffer is not enough
        ptrMsg->status = FT_CNF_FAIL;
        FT_SEND_MSG_TO_PC(&ilm_ptr);
        return;
    }

    kal_mem_set(para, 0, META_SLA_RND_LEN);

    ret = MetaSLA_Rnd_Gen(para, RND_BUF_LEN);
    if (0 == ret)
    {
        kal_mem_cpy(ptrMsg->rand_num, para, META_SLA_RND_LEN);
        ptrMsg->rand_num_len = META_SLA_RND_LEN;
    }
    else
    {
        ptrMsg->status = ret;
        ptrMsg->rand_num_len = 0;
    }

    bRet = Custom_META_GetSlaPara(cust_para, 256);
    if (true == bRet)
    {
        kal_mem_cpy(ptrMsg->cust_para, cust_para, 256);
    }
    else
    {
        ptrMsg->status = -1;
    }

    if (ret == 0 && bRet == true)
    {
        ptrMsg->status = FT_CNF_OK;
    }

    FT_SEND_MSG_TO_PC(&ilm_ptr);
}

void FT_VerifySla(FT_VERIFY_SLA_RND_REQ *ft_verify_sla_op)
{
    ilm_struct              ilm_ptr;
    FT_VERIFY_SLA_RND_CNF     *ptrMsg;
    kal_uint32 ret = 0;

    FT_ALLOC_MSG(&ilm_ptr, sizeof(FT_VERIFY_SLA_RND_CNF));

    ptrMsg = (FT_VERIFY_SLA_RND_CNF *)ilm_ptr.local_para_ptr;
    ASSERT(ptrMsg);
    ptrMsg->header.ft_msg_id = FT_VERIFY_SLA_RND_CNF_ID;

    ret = MetaSLA_Rnd_Verify(ft_verify_sla_op->encrypted, ft_verify_sla_op->encrypted_len);
    if (ret == 0)
    {
        if (FT_MetaSLA_Is_Enabled())
        {
            ptrMsg->status = FT_CNF_OK;
        }
        else
        {
            ptrMsg->status = -1;
        }
    }
    else
    {
        ptrMsg->status = ret;
    }

    FT_SEND_MSG_TO_PC(&ilm_ptr);
}


