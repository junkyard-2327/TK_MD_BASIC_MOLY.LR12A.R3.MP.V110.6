/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2006
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * nvram_auto_gen.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for generating NVRAM information.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef NVRAM_NOT_PRESENT
/*****************************************************************************
* Include
*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <sys/io.h>
#include <errno.h>

#include "nvram_auto_gen.h"
#include "custom_nvram_config.h"
#include "nvram_editor_data_item.h"
#include "nvram_data_items.h"

#if defined(__MMI_FMI__)
#include "nvram_user_defs.h"

#endif

#ifndef __VENDOR_RELEASE__
#include "custom_nvram_sec.h"
#endif

#ifdef __FS_RAMDISK__
#include "driver/storage/ramdisk_gprot.h"
#endif

/* Add pseudo merge headfile */
#include "nvram_pseudo_merge.h"

#include "nvram_internal.h"

#include "nvram_white_list.h"
/*
 * Variables
 */
extern kal_uint32 custpack_total_to_verify;

extern nvram_ltable_entry_struct *logical_data_item_table;
extern kal_uint32 nvram_gen_total_lid;

#ifdef __NVRAM_OTP__
extern kal_uint32 otp_total_to_verify;
extern kal_uint32 otp_size_to_verify;
#endif

extern kal_uint32 secupack_total_to_verify;
extern kal_uint32 secupack_size_to_verify;
extern kal_uint16 secupack_idx;

#ifdef __NVRAM_VENDOR_SUPPORT__
extern kal_uint32 nvram_vendor_reserve_size;
#endif

#if defined(__NVRAM_SECURE_DATA_STORAGE__)
extern kal_uint32 sds_total_to_verify;
extern kal_uint32 sds_size_to_verify;
#endif


/* system cache configure*/
extern nvram_sys_cache_entry nvram_sys_cache[];

#define NVRAM_AUTO_GEN_BYTE       1
#define NVRAM_AUTO_GEN_SHORT      2
#define NVRAM_AUTO_GEN_INTEGER    4

#define fprintf_blank_line(x) fprintf (x,"\n")

static FILE* logOfSize;
static FILE* logOfTools;
#ifdef __NVRAM_PSEUDO_MERGE__
static FILE* logOfSize_Package;
#endif

/* used to package samll lid */
#ifdef __NVRAM_PSEUDO_MERGE__
static int nvram_auto_package_num;
static int nvram_auto_pack_file_offset = NVRAM_FILE_HEAD_SIZE;
#endif

static int nvram_restore_cache_system[NVRAM_APP_TOTAL][NVRAM_SYS_CACHE_MAX];
static int nvram_restore_system_idx[NVRAM_APP_TOTAL];
static char **nvram_restore_lid_enum_array;
static char **nvram_restore_lid_description_point;
static int nvram_max_length_lid_str;
static int nvram_total_num_restore_lid;
static char base_path[NVRAM_AUTO_GEN_MAX_PATH_LEN];

kal_uint32 nvram_long_length;
kal_uint32 nvram_ptr_length;
kal_uint32 nvram_padding_length;

/*****************************************************************************
* FUNCTION
*   nvram_gen_check_sys_cache
* DESCRIPTION
*   output system cache default value to nvram_mmi_cust_pack.h
* PARAMETERS
*
* RETURNS
*   none
*****************************************************************************/
void nvram_gen_check_sys_cache(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int loop_idx;
    int byte_idx;
    int bit_idx;
    kal_uint8 *data = &(nvram_sys_cache[NVRAM_SYS_CACHE_BEGIN-1].value1);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (loop_idx = NVRAM_SYS_CACHE_BEGIN; loop_idx < NVRAM_SYS_CACHE_MAX; loop_idx++)
    {
        if(nvram_sys_cache[loop_idx].id != loop_idx+1)
        {
            fprintf(stderr, "ERROR: please check nvram_data_items.h and nvram_data_items.c: # sys cache enum (%d) and # sys cache entry must sync.", loop_idx);
            exit(3);
        }

        byte_idx = loop_idx / 8;
        bit_idx = loop_idx % 8;
        if (nvram_sys_cache[loop_idx].restore)
        {
            data[byte_idx] |= (0x01 << bit_idx);
            nvram_restore_cache_system[nvram_sys_cache[loop_idx].app_id][nvram_restore_system_idx[nvram_sys_cache[loop_idx].app_id]] = loop_idx;
            nvram_restore_system_idx[nvram_sys_cache[loop_idx].app_id]++;
        }
    }
}


void nvram_gen_sys_cache_default(FILE *fh_file)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int loop_idx;
    int loop_value_idx;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* step 1: generate restore mark */
    fprintf(fh_file, "kal_uint8 const NVRAM_EF_SYS_CACHE_OCTET_DEFAULT[NVRAM_EF_SYS_CACHE_OCTET_TOTAL * NVRAM_EF_SYS_CACHE_OCTET_SIZE] =\n");
    fprintf(fh_file, "{\n");

    /* step 2: generate default value */
    for (loop_idx = NVRAM_SYS_CACHE_BEGIN; loop_idx < NVRAM_SYS_CACHE_MAX; loop_idx++)
    {
        for (loop_value_idx = 0; loop_value_idx < sizeof(double); loop_value_idx++)
        {
            fprintf(fh_file,"    0x%02X, ",
                    *(kal_uint8 *)(&(nvram_sys_cache[loop_idx - 1].value1) + loop_value_idx));
        }
        fprintf(fh_file, "\n");
    }

    /* step 3: generate last */
    for (loop_value_idx = 0; loop_value_idx < sizeof(double) - 1; loop_value_idx++)
    {
        fprintf(fh_file, "    0x%02X, ",
                *(&(nvram_sys_cache[NVRAM_SYS_CACHE_MAX - 1].value1) + loop_value_idx));
    }

    fprintf(fh_file, "    0x%02X ", nvram_sys_cache[NVRAM_SYS_CACHE_MAX - 1].value8);

    fprintf(fh_file, "\n");

    fprintf(fh_file, "};\n");
}


void nvram_gen_sys_cache_res_func(FILE *fh_file)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int loop_app_idx;
    int loop_app_cache_idx;
    int loop_value_idx;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fprintf(fh_file, NVRAM_RESTORE_FUNCTION_NAME, "system");

    for (loop_app_idx = 0; loop_app_idx < NVRAM_APP_TOTAL; loop_app_idx++)
    {
        if (nvram_restore_system_idx[loop_app_idx])
        {
            fprintf(fh_file,"        case %s :\n", nvram_sys_cache[nvram_restore_cache_system[loop_app_idx][0]].app_id_str);
        }
        else
        {
            continue;
        }

        for (loop_app_cache_idx = 0; loop_app_cache_idx < nvram_restore_system_idx[loop_app_idx]; loop_app_cache_idx++)
        {
            /*-----------------------------------------------------------
            fprintf(fh_restore_dom_h, R_F_DOM_CONTENT_ID,
                        nvram_mmi_cache_double[nvram_restore_cache_double[loop_app_idx][loop_app_cache_idx]].id_str);

            for (loop_space = 0; loop_space < nvram_max_length_double_id_str - strlen(nvram_mmi_cache_double[nvram_restore_cache_double[loop_app_idx][loop_app_cache_idx]].id_str); loop_space++)
            {
                fprintf(fh_restore_dom_h, " ");
            }

            fprintf(fh_restore_dom_h, R_F_DOM_CONTENT_DESCRIPTION,
                        nvram_mmi_cache_double[nvram_restore_cache_double[loop_app_idx][loop_app_cache_idx]].discription);
            -----------------------------------------------------------*/

            fprintf(fh_file, NVRAM_AUTO_GEN_COMMENT, nvram_sys_cache[nvram_restore_cache_system[loop_app_idx][loop_app_cache_idx]].description);

            for (loop_value_idx = 0; loop_value_idx < sizeof(double); loop_value_idx++)
            {
                fprintf(fh_file,"            buffer[%d * (%s - 1) + %d] = 0x%02X;\n",
                        sizeof(double),
                        nvram_sys_cache[nvram_restore_cache_system[loop_app_idx][loop_app_cache_idx]].id_str,
                        loop_value_idx,
                        *(&(nvram_sys_cache[nvram_restore_cache_system[loop_app_idx][loop_app_cache_idx]].value1) + loop_value_idx));
            }
        }

        fprintf(fh_file,NVRAM_RESTORE_FUNCTION_BREAK);
    }
    fprintf(fh_file, NVRAM_RESTORE_FUNCTION_TAIL);
}


/*****************************************************************************
* FUNCTION
*  nvram_gen_lid_size
* DESCRIPTION
*  Output NVRAM LID size Information.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
char s[512];
char indirect_end_symbol[40];

void nvram_gen_ltable_list(void)
{

    typedef enum
    {
      INDIRECT_PROCESS_YET,
      INDIRECT_PROCESS_ING,
      INDIRECT_PROCESS_FINISHED
    }indirect_process_enum;
    
    FILE* tbl_list = NULL;
    FILE* map_file = NULL;
    char pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN*2];
    indirect_process_enum process_indirect_init = INDIRECT_PROCESS_YET;


    sprintf(pathname,"%s/nvram_auto_gen/nvram_ltable_list.h",base_path);
    printf("%s\n", pathname);
    tbl_list= fopen(pathname,"w+");
    if (tbl_list == NULL)
    {
        fprintf(stderr, "error: %s - nvram_ltable_list.h\n", strerror(errno));
        return;
    }

    sprintf(pathname,"%s/nvram_auto_gen/debug/nvram_auto_gen.map",base_path);
    printf("%s\n", pathname);
    map_file = fopen(pathname,"r");

    if (map_file == NULL)
    {
        fprintf(stderr, "error: %s - nvram_auto_gen.map\n", strerror(errno));
        fclose(tbl_list);
        return;
    }



    while (fgets(s, 512, map_file) > 0)
    {
        char *ptr;
        char *brk;
        s[511] = 0;
        
        brk = strchr(s, '\n');

        if (brk)
            *brk = 0;

        if (process_indirect_init == INDIRECT_PROCESS_YET)
        {
            if ((ptr = strstr(s, "logical_data_item_table_")))
            {
        
                fprintf(tbl_list, "#pragma comment(linker, \"/INCLUDE:_%s\")\n", ptr);
            }
        
            if (strstr(s, "*(_indirect_init)"))
            {
                process_indirect_init = INDIRECT_PROCESS_ING;
                fgets(s, 512, map_file); /* skip one line */
                s[511] = 0;
        
                if (strstr(s, indirect_end_symbol))
                {
                    process_indirect_init = INDIRECT_PROCESS_FINISHED;
                    break;
                }
            }
        }
    else if (process_indirect_init == INDIRECT_PROCESS_ING)
    {
    
        if (strstr(s, indirect_end_symbol))
        {
            process_indirect_init = INDIRECT_PROCESS_FINISHED;
            break;
        }
    
        ptr = strrchr(s, ' ') + 1;
        printf("%s\n", ptr);
        
        if (!strstr(ptr, "./build/"))
        {
            fprintf(tbl_list, "#pragma comment(linker, \"/INCLUDE:_%s\")\n", ptr);                
        }
    }

    }

    fclose(map_file);   
    fclose(tbl_list);

}
void nvram_gen_lid_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __NVRAM_PSEUDO_MERGE__
    kal_uint16 fake_lid;
    int sum = 0;
#endif
    kal_uint32 i,j;
    char pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN*2];
    kal_uint32 estimate_size = 0;
    kal_uint32 estimate_fs_size = 0;
    kal_uint32 remainLen = 0;
#define FS_PAGE_SIZE    4096

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   
    /* Gen information for tools */
    sprintf(pathname, "%s/nvram_auto_gen/~nvram_lid_information.log", base_path);
    logOfTools = fopen(pathname,"w+");
    if (logOfTools == NULL)
    {
        fprintf(stderr, "error: %s - ~nvram_lid_information.log\n", strerror(errno));
    }
    else
    {
        fprintf(logOfTools,"----------------------------------------------------------------------------------------------------------------------------------------------\n");
        fprintf(logOfTools,"----------------------------------------------------------------------------------------------------------------------------------------------\n");
        fprintf(logOfTools,"%4s    %55s    %10s    %10s    %11s  %10s   %10s\n","LID","LID(String)","Filename","Verno","Description", "Category", "Attribute");
        fprintf(logOfTools,"----------------------------------------------------------------------------------------------------------------------------------------------\n");
    } /* end for tools */

    sprintf(pathname, "%s/nvram_auto_gen/~nvram_lid_size.log", base_path);
    logOfSize = fopen(pathname,"w+");
    if (logOfSize == NULL)
    {
        fprintf(stderr, "error: %s - ~nvram_lid_size.log\n", strerror(errno));
    }
    else
    {
        kal_uint32 onefilesize = 0;
        kal_uint32 onefilefssize = 0;
        nvram_ltable_entry_struct *ldi;

        fprintf(logOfSize, "00000       long:%d,char*:%d,padding:%d                     NVRAM_PADDING_TEST\n", nvram_long_length, nvram_ptr_length, (nvram_padding_length / 3));
        fprintf(logOfSize, "--------------------------------------------------------------------------\n");

        #ifdef __NVRAM_PSEUDO_MERGE__
        sprintf(pathname, "%s/nvram_auto_gen/nvram_lid_size_merge.log", base_path);
        logOfSize_Package = fopen(pathname,"w+");
        if (logOfSize_Package == NULL)
        {
            fprintf(stderr, "error: %s - nvram_lid_size_merge.log\n", strerror(errno));
        }
        else
        {
            fprintf(logOfSize_Package, "%4s   %10s    %10s    %10s    %10s    %10s    %10s\n",
                    "ldi->LID", "fileprefix", "onefilesize", "oneLIDsize", "single_num", "single_offset", "file_size");
        }

        #endif

        nvram_restore_lid_enum_array = malloc(sizeof(char *) * nvram_gen_total_lid);
        nvram_restore_lid_description_point = malloc(sizeof(char *) * nvram_gen_total_lid);

        
        for (i = 0;i < nvram_gen_total_lid; i++)
        {
            ldi = &logical_data_item_table[i];

            if (ldi == NULL ||
                (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
            {
                continue;   /* invalid LID */
            }
        #ifdef __NVRAM_PSEUDO_MERGE__
            sum ++;
        #endif
            /* Output data item size */
            if(ldi->attr & NVRAM_ATTR_CONFIDENTIAL
                #ifdef __NVRAM_BIND_TO_CHIP_CIPHER__ //if HW encrypt is enable
                || ldi->attr & NVRAM_ATTR_MSP
                #endif
              )
            {
                remainLen = NVRAM_MSP_ALIGNMENT_REMAINDER(ldi->size + NVRAM_CHKSUM_SIZE);
                onefilesize = (ldi->size + NVRAM_CHKSUM_SIZE + remainLen)*ldi->total_records + NVRAM_LDI_HEADER_SIZE;
            }
            else
            {
                onefilesize = (ldi->size + NVRAM_CHKSUM_SIZE) * ldi->total_records + NVRAM_LDI_HEADER_SIZE;
            }
            onefilefssize = (onefilesize+FS_PAGE_SIZE-1)/FS_PAGE_SIZE*FS_PAGE_SIZE; //align to FS_PAGE_SIZE

            if(onefilesize)
            {
            /* Record data item will be restored (begin) */
                if (NVRAM_IS_CATEGORY_FACTORY_RESET(ldi->category))
                {
                    if (strlen(ldi->str_LID) > nvram_max_length_lid_str)
                    {
                        nvram_max_length_lid_str = strlen(ldi->str_LID);
                    }
                    nvram_restore_lid_enum_array[nvram_total_num_restore_lid] = ldi->str_LID;
                    nvram_restore_lid_description_point[nvram_total_num_restore_lid] = ldi->description;
                    nvram_total_num_restore_lid++;
                }
            /* Record data item will be restored (end) */
            #ifdef __NVRAM_PSEUDO_MERGE__
                if (NVRAM_IS_ATTR_PACKAGE(ldi->attr))
                {
                    /* Gen information for tools */
                    if (logOfTools)
                    {
                        fprintf(logOfTools,"%4d    %55s    %10s    %10s    %11s    0x%08x  0x%08x\n",ldi->LID,ldi->str_LID,"PACK","LID",ldi->description, ldi->category, ldi->attr);
                    }
                    /* end */

                    nvram_auto_package_num++;
                    {
                        fprintf(logOfSize_Package, "%40s", ldi->description);
                        ldi->description = nvram_auto_pack_file_offset;
                        nvram_auto_pack_file_offset += onefilesize;
                        fprintf(logOfSize_Package, "%4d    %10s    %10d    %10d    %10d    %10d    %10d\n",
                                ldi->LID, ldi->fileprefix, onefilesize, ldi->size, nvram_auto_package_num, (kal_int32)(ldi->description), nvram_auto_pack_file_offset);
                    }

                    fprintf(logOfSize, "%4d%10d%60s%20s\n", ldi->LID, 0, ldi->str_LID, NVRAM_IS_CATEGORY_CUSTPACK(ldi->category)?"CUSTPACK":"");

                    continue;   /* already calculate in package file */
                }
            #endif
                fprintf(logOfSize, "%4d%10d%60s%20s\n", ldi->LID, onefilesize, ldi->str_LID, NVRAM_IS_CATEGORY_CUSTPACK(ldi->category)?"CUSTPACK":"");
                estimate_size += onefilesize;
                estimate_fs_size += onefilefssize;

                if (NVRAM_IS_ATTR_MULTIPLE(ldi->attr))
                {
                    fprintf(logOfSize, "%4d%10d%60s%20s\n", ldi->LID, onefilesize, ldi->str_LID, NVRAM_IS_CATEGORY_CUSTPACK(ldi->category)?"CUSTPACK":"");
                    estimate_size += onefilesize;
                    estimate_fs_size += onefilefssize;
                }

                /* Gen information for tools */
                if (logOfTools)
                {
                    fprintf(logOfTools,"%4d    %55s    %10s    %10s    %11s    0x%08x  0x%08x\n",ldi->LID,ldi->str_LID,ldi->fileprefix,ldi->fileverno,ldi->description, ldi->category, ldi->attr);
                }
                /* end */
            }
        }

    #ifdef __NVRAM_VENDOR_SUPPORT__
        fprintf(logOfSize,
                "%4d%10d%60s\n",
                nvram_gen_total_lid,
                nvram_vendor_reserve_size,
                "NVRAM_EF_VENDOR_REMAIN_SPACE_LID"
                );
    #endif /* __NVRAM_VENDOR_SUPPORT__ */

    #ifdef __NVRAM_PSEUDO_MERGE__
        fake_lid = nvram_gen_total_lid;
    #ifdef __NVRAM_VENDOR_SUPPORT__
        fake_lid += 1;
    #endif
        fprintf(logOfSize, "%4d%10d%40s\n", fake_lid, nvram_auto_pack_file_offset, "Package file size");
        /* LID information nvram_auto_package_num */
        fprintf(logOfSize, "%4d%10d%40s\n", fake_lid + 1, nvram_auto_package_num * (sizeof(LID_info_struct) + 2), "Info file A");
        fprintf(logOfSize, "%4d%10d%40s\n", fake_lid + 2, nvram_auto_package_num * (sizeof(LID_info_struct) + 2), "Info file B");
        /* extra cluster is need, for temp file, package file, truncate file */
        fprintf(logOfSize, "%4d%10d%40s\n", fake_lid + 3, 3 * 512,"Extra size");
       /***
        * fprintf(logOfSize,"sum: %4d   nvram_auto_package_num = %4d\n",sum,nvram_auto_package_num);
        */
    #endif /* __NVRAM_PSEUDO_MERGE__ */

        fprintf(logOfSize, "--------------------------------------------------------------------------\n");

        #ifdef __NVRAM_COMPRESS_SUPPORT__
        fprintf(logOfSize, "NVRAM_COMPRESS=1\n");
        #else
        fprintf(logOfSize, "NVRAM_COMPRESS=0\n");
        #endif
        fprintf(logOfSize, "NVRAM_ESTIMATE_SIZE=%d\n", estimate_size);
        fprintf(logOfSize, "NVRAM_ESTIMATE_FS_SIZE=%d\n", estimate_fs_size);
        #ifdef __FS_RAMDISK__
        fprintf(logOfSize, "RAMDISK_SIZE=%d\n", RAM_FS_SIZE);
        #endif

        fclose(logOfSize);
    #ifdef __NVRAM_PSEUDO_MERGE__
        fclose(logOfSize_Package);
    #endif
    }

    /* Gen information for tools */
    if (logOfTools)
    {
        fprintf(logOfTools,"--------------------------------------------------------------------------------------------\n");
        fclose(logOfTools);
    }
    /* end */

    for (i = 0;i < nvram_gen_total_lid; i++)
    {
        nvram_ltable_entry_struct *ldi1, *ldi2;

        ldi1 = &logical_data_item_table[i];

        if (ldi1 == NULL || (ldi1->LID == 0 && ldi1->size == 0 && ldi1->total_records == 0))
        {
            continue;   /* invalid LID */
        }

        if (strcasecmp(ldi1->fileprefix, "") == 0)
        {
            fprintf(stderr, "error: fileprefix of %s = %d cannot be NULL!\n", ldi1->str_LID, ldi1->LID);
            exit(NVRAM_EXIT_CODE_ERROR);
        }
        if (strlen(ldi1->fileprefix) != FILE_PREFIX_LEN)
        {
            fprintf(stderr, "error: fileprefix length of %s is invalid!\n", ldi1->str_LID);
            exit(NVRAM_EXIT_CODE_ERROR);
        }
        if (strlen(ldi1->fileverno) != FILE_VERNO_LEN)
        {
            fprintf(stderr, "error: fileverno length of %s is invalid!\n", ldi1->str_LID);
            exit(NVRAM_EXIT_CODE_ERROR);
        }       

        for (j = i + 1 ;j < nvram_gen_total_lid; j++)
        {
            ldi2 = &logical_data_item_table[j];

            if (ldi2 == NULL || (ldi2->LID == 0 && ldi2->size == 0 && ldi2->total_records == 0))
            {
                continue;   /* invalid LID */
            }
            if (strcasecmp(ldi1->fileprefix, ldi2->fileprefix) == 0)
            {
                fprintf(stderr, "error: duplicated fileprefix and fileverno %s %s of %s and %s\n", ldi1->fileprefix, ldi1->fileverno, ldi1->str_LID, ldi2->str_LID);
                exit(NVRAM_EXIT_CODE_ERROR);
            }
        }
   
    }

#ifdef __FS_RAMDISK__
    if(estimate_fs_size > RAM_FS_SIZE)
    {
        fprintf(stderr, "error: RAMDISK size is not enough.\n");
        fprintf(stderr, "error: NVRAM_ESTIMATE_FS_SIZE=%d\n", estimate_fs_size);
        fprintf(stderr, "error: RAMDISK_SIZE=%d\n", RAM_FS_SIZE);

        exit(NVRAM_EXIT_CODE_ERROR);
    }
#endif    
}


/*****************************************************************************
* FUNCTION
*  nvram_gen_statistic
* DESCRIPTION
*  Output nvram_lid_statistic.h
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_statistic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32   error = 0;
    FILE* outputHeader;
    kal_uint8    sys_str[2048];
    char pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN*2];
    char pathnameOrg[NVRAM_AUTO_GEN_MAX_PATH_LEN*2];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(pathname, "%s/nvram_auto_gen/nvram_lid_statistics_bak.h", base_path);
    sprintf(pathnameOrg, "%s/nvram_auto_gen/nvram_lid_statistics.h", base_path);
    outputHeader = fopen(pathname,"w+");
    if (outputHeader == NULL)
    {
        fprintf(stderr, "error: %s - %s\n",strerror(errno) ,pathname);
    }
    else
    {

        fprintf(outputHeader, COPYRIGHTS_HEADER, "nvram_lid_statistics_bak.h");

        fprintf(outputHeader, "#ifndef NVRAM_LID_STATISTIC_H\n#define NVRAM_LID_STATISTIC_H\n");

    #ifdef __NVRAM_OTP__
        fprintf(outputHeader, "#define NVRAM_OTP_SIZE    %d\n", otp_size_to_verify);
        fprintf(outputHeader, "#define NVRAM_OTP_TOTAL   %d\n", otp_total_to_verify);
    #endif

        fprintf(outputHeader, "#define NVRAM_CUSTPACK_TOTAL  %d\n", custpack_total_to_verify);

        fprintf(outputHeader, "#define NVRAM_SECUPACK_SIZE  %d\n", secupack_size_to_verify);
        fprintf(outputHeader, "#define NVRAM_SECUPACK_TOTAL  %d\n", secupack_total_to_verify);

    #if defined(__NVRAM_SECURE_DATA_STORAGE__)
        fprintf(outputHeader, "#define NVRAM_SDS_TOTAL  %d\n", sds_total_to_verify);
        fprintf(outputHeader, "#define NVRAM_SDS_SIZE  %d\n", sds_size_to_verify);
    #endif

    #ifdef __NVRAM_PSEUDO_MERGE__
        fprintf_blank_line(outputHeader);
        fprintf(outputHeader, "#ifdef __NVRAM_PSEUDO_MERGE__\n");
        fprintf(outputHeader, "#define NVRAM_PACKAGE_LID_NUM     %d\n", nvram_auto_package_num);
        fprintf(outputHeader, "#define NVRAM_PACKAGE_LID_SIZE    %d\n", nvram_auto_pack_file_offset);
        fprintf(outputHeader, "#endif /* __NVRAM_PSEUDO_MERGE__ */\n");
    #endif

        fprintf(outputHeader,"\n#endif /* NVRAM_LID_STATISTIC_H */\n\n");
        fclose(outputHeader);

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif        
    }
}


/*****************************************************************************
* FUNCTION
*  nvram_gen_array
* DESCRIPTION
*  Output formatted arrays to custom_nvram_secro, i.e. 16 bytes/line
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_array(FILE* handle, kal_char* indent, kal_uint8 type, kal_uint32 max_size, kal_uint8 *array, kal_bool calc_cksum, kal_bool last_block)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 i;
    kal_uint8 byte_chksum[2] = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* We only support checksum on NVRAM_AUTO_GEN_BYTE */

    for (i = 0; i < max_size; i += type)
    {
        if (calc_cksum && type == NVRAM_AUTO_GEN_BYTE)
        {
            if (i & 0x1)
            {
                byte_chksum[1] += array[i];
            }
            else
            {
                byte_chksum[0] += array[i];
            }
        }

        if (i % 16 == 0)
        {
            fprintf(handle, "\n%s", indent);
        }

        switch (type)
        {
            case NVRAM_AUTO_GEN_INTEGER:
                fprintf(handle, "0x%02X%02X%02X%02X", array[i + 3], array[i + 2], array[i + 1], array[i]);
                break;
            case NVRAM_AUTO_GEN_SHORT:
                fprintf(handle, "0x%02X%02X", array[i + 1], array[i]);
                break;
            case NVRAM_AUTO_GEN_BYTE:
            default:
                fprintf(handle, "0x%02X", array[i]);
                break;
        }

        if (i == max_size - type)
        {
            if (calc_cksum && type == NVRAM_AUTO_GEN_BYTE)
                fprintf(handle, ",\n%s/* check sum */\n%s0x%02x, 0x%02x", indent, indent, byte_chksum[0], byte_chksum[1]);

            if (!last_block)
            {
                fprintf(handle, ", ");
            }
        }
        else
        {
            fprintf(handle, ", ");
        }
    }


}

#ifndef __VENDOR_RELEASE__
/*****************************************************************************
* FUNCTION
*  nvram_gen_secro
* DESCRIPTION
*  Output custom_nvram_secro.c.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_secro(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i = 0;
    FILE* outputHeader;
    FILE* outputHeader2;
    char pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN*2];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(pathname, "%s/nvram_auto_gen/custom_nvram_secro.c", base_path);
    outputHeader = fopen(pathname,"w+");
    sprintf(pathname, "%s/nvram_auto_gen/custom_nvram_secro_tbl.c", base_path);    
    outputHeader2 = fopen(pathname,"w+");
    
    if ((outputHeader == NULL) || (outputHeader2 == NULL))    {
        fprintf(stderr, "error: %s - custom_nvram_secro.c\n", strerror(errno));
        if(outputHeader != NULL)
        {
            fclose(outputHeader);
        }
        if(outputHeader2 != NULL)
        {
            fclose(outputHeader2);
        }
    }
    else
    {
        fprintf(outputHeader, COPYRIGHTS_HEADER, "custom_nvram_secro.c");

        fprintf(outputHeader, "#if !defined(NVRAM_NOT_PRESENT)");

        fprintf(outputHeader, "\n#include \"kal_general_types.h\"");




        i = 0;
        secupack_idx = 0;
        fprintf(outputHeader2, "#if defined(NVRAM_SEC_C_ONLY)");
        fprintf(outputHeader2, "\nconst nvram_lid_enum secupack_nvram_lid_tbl[%d] = ", secupack_total_to_verify);
        fprintf(outputHeader2, "\n{");

        while (i < nvram_gen_total_lid)
        {
            nvram_ltable_entry_struct *ldi = &logical_data_item_table[i];
            if (ldi && ldi->category & NVRAM_CATEGORY_SECUPACK)
            {
                fprintf(outputHeader2, "\n   %d,", ldi->LID);


                secupack_idx++;
            }
            i++;
        }


        fprintf(outputHeader2, "\n};");
        fprintf(outputHeader2, "\n#endif");
        fclose(outputHeader2);
    



        fprintf(outputHeader, "\nconst kal_uint8 NVRAM_CUSTOM_KEY[] = ");

        fprintf(outputHeader, "\n    {");
        nvram_gen_array(outputHeader, "        ", NVRAM_AUTO_GEN_BYTE, NVRAM_SECRET_KEY_SIZE, custom_secret_key, KAL_FALSE, KAL_TRUE);
        fprintf(outputHeader, "\n    };");


        fprintf(outputHeader, "\nconst kal_uint8 NVRAM_CUSTOM_KEY_SEED[] = ");
        fprintf(outputHeader, "\n    {");
        nvram_gen_array(outputHeader, "        ", NVRAM_AUTO_GEN_BYTE, NVRAM_CUSTOM_KEY_SEED_SIZE, custom_key_seed, KAL_FALSE, KAL_TRUE);
        fprintf(outputHeader, "\n    };");
        // #endif
        fprintf(outputHeader, "\n#if defined(__RES_PROT__)");
        fprintf(outputHeader, "\n__attribute__((section(\"PROTECTED_RES_RW\")))");
        fprintf(outputHeader, "\n#endif");

        fprintf(outputHeader, "\nconst kal_uint8 NVRAM_SECUPACK_DEFAULT[] = ");

        fprintf(outputHeader, "\n    {");

        i = 0;
        secupack_idx = 0;
        while (i < nvram_gen_total_lid)
        {
            nvram_ltable_entry_struct *ldi = &logical_data_item_table[i];
            if (ldi && ldi->category & NVRAM_CATEGORY_SECUPACK)
            {
            #ifndef __NVRAM_PSEUDO_MERGE__
                if (secupack_idx != 0)
                    fprintf(outputHeader, "\n");

                fprintf(outputHeader, "\n        /* %s */", ldi->str_LID);
            #endif
                nvram_gen_array(outputHeader,
                    "        ",
                    NVRAM_AUTO_GEN_BYTE,
                    ldi->size * (ldi->attr & NVRAM_ATTR_MULTI_DEFAULT? ldi->total_records : 1),
                    (kal_uint8 *)ldi->default_value,
                    KAL_TRUE,
                    (secupack_idx + 1 == secupack_total_to_verify));
                secupack_idx++;
            }
            i++;
        }


        /* Fake data for special case */
        if (secupack_total_to_verify == 0)
        {
            fprintf(outputHeader, "\n        0x00, 0x00");
        }

        fprintf(outputHeader, "\n    };");



        fprintf(outputHeader, "\nkal_uint32 secupack_total_to_verify = %d;", secupack_total_to_verify);
        fprintf(outputHeader, "\n#endif /* NVRAM_NOT_PRESENT */");
        fclose(outputHeader);
    }
}
#endif /* __VENDOR_RELEASE__ */

/*****************************************************************************
* FUNCTION
*   nvram_gen_mmi_cache
* DESCRIPTION
*   output restore head file to nvram_restore_headfile.h
* PARAMETERS
*   project_name    [IN]
*   broad_ver       [IN]
* RETURNS
*   none
*****************************************************************************/
void nvram_gen_create_file(FILE **file_handle, char *file_path, char *file_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int  mode_result;
    char file_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(file_pathname, "%s/%s", file_path, file_name);

    mode_result = access(file_pathname, 0);

    if (mode_result == 0)
    {
        /* exists,but check if it can be written. */
        mode_result = access(file_pathname, 2);
        if (mode_result != 0)
        {
            fprintf(stderr, "error: %s exists,but it cannot be written.\n", file_name);
            exit(NVRAM_EXIT_CODE_ERROR);
        }
    }
    else
    {
        /* file not exist*/
        mode_result = access(file_path, 2);
        if (mode_result != 0)
        {
            fprintf(stderr, "error: cannot create file in folder: %s\n", file_path);
            exit(NVRAM_EXIT_CODE_ERROR);
        }
    }

    *file_handle = fopen(file_pathname, "w+");
    if (*file_handle == NULL)
    {
        fprintf(stderr, "error: cannot write to %s in folder: %s(%s)\n", file_name, file_path, strerror(errno));
        exit(NVRAM_EXIT_CODE_ERROR);
    }
    else
    {
         printf("Create %x:%s successfully!\n", *file_handle, file_pathname);   
    }
    return;
}

void nvram_gen_close_file(FILE **file_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    fclose(*file_handle);
}
/*****************************************************************************
* FUNCTION
*   nvram_gen_restore_function
* DESCRIPTION
*   output restore function to nvram_user_restore_factory.c
* PARAMETERS
*   project_name    [IN]
*   broad_ver       [IN]
* RETURNS
*   none
*****************************************************************************/
void nvram_gen_restore_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *fh_restore_factory_c;
    FILE *fh_restore_dom_h;
    char output_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    int  loop_app_idx;
    int  loop_space;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_pathname, "nvram_auto_gen/custom_nvram_restore.c");
    nvram_gen_create_file(&fh_restore_factory_c,base_path,output_pathname);

    sprintf(output_pathname,"nvram_auto_gen/nvram_restore_dom.h");
    nvram_gen_create_file(&fh_restore_dom_h,base_path,output_pathname);

    /* generate head file */
    fprintf(fh_restore_factory_c, COPYRIGHTS_HEADER, "nvram_user_restore_factory.h");

    fprintf_blank_line(fh_restore_factory_c);

    fprintf(fh_restore_factory_c, "#ifndef NVRAM_NOT_PRESENT\n");
    fprintf(fh_restore_factory_c, "#include \"kal_general_types.h\"\n");
    fprintf(fh_restore_factory_c, "#include \"nvram_enums.h\"\n");
    fprintf(fh_restore_factory_c, "#include \"custom_nvram_config.h\"\n");
    fprintf(fh_restore_factory_c, "#include \"nvram_data_items.h\"\n");


    /*
     * Begin deal with system cache
     */
    nvram_gen_check_sys_cache();
    nvram_gen_sys_cache_default(fh_restore_factory_c);
    nvram_gen_sys_cache_res_func(fh_restore_factory_c);

    /* Dom: data item (begin) */
    fprintf(fh_restore_dom_h, R_F_DOM_COMMENT, "LID");
    fprintf(fh_restore_dom_h, R_F_DOM_ENUM_BEGIN);

    for (loop_app_idx = 0; loop_app_idx < nvram_total_num_restore_lid; loop_app_idx++)
    {
        fprintf(fh_restore_dom_h, R_F_DOM_CONTENT_ID, nvram_restore_lid_enum_array[loop_app_idx]);
        for (loop_space = 0; loop_space < nvram_max_length_lid_str - strlen(nvram_restore_lid_enum_array[loop_app_idx]); loop_space++)
        {
            fprintf(fh_restore_dom_h, " ");
        }
        fprintf(fh_restore_dom_h, R_F_DOM_CONTENT_DESCRIPTION, nvram_restore_lid_description_point[loop_app_idx]);
    }
    fprintf(fh_restore_dom_h, R_F_DOM_ENUM_END, "LID", "LID");
    /* Dom: data item (begin) */

    /*
     * End deal with system cache
     */

    fprintf(fh_restore_factory_c, "#endif /* NVRAM_NOT_PRESENT */");

    nvram_gen_close_file(&fh_restore_factory_c);
    nvram_gen_close_file(&fh_restore_dom_h);
}

#ifndef __VENDOR_RELEASE__
/*****************************************************************************
* FUNCTION
*  nvram_gen_database_key
* DESCRIPTION
*  This function is used to generate the database key into custom_nvram_database.h
*  After that, codegen will use this file and generate the key into NVRAM database.
*  Metatool will read the key from database also.
*  Please notify codegen owner and metatool owner if you want to change the format.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void nvram_gen_database_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *database_h;
    FILE *fh_restore_dom_h;
    char output_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    int i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_pathname, "nvram_auto_gen/custom_nvram_database.h");
    nvram_gen_create_file(&database_h,base_path,output_pathname);

#if defined(__NVRAM_SECRET_DATA__) && !defined(__NVRAM_HIDE_DATABASE_KEY__)
    fprintf(database_h, "typedef enum \n");
    fprintf(database_h, "{\n");

    for (i = 0 ; i < NVRAM_DATABASE_KEY_SIZE ; i+=8)
    {
        fprintf(database_h, "    NVRAM_DB_KEY%02d_0x%02x_0x%02x_0x%02x_0x%02x_0x%02x_0x%02x_0x%02x_0x%02x = %d,\n",
                            (i >> 3) + 1,
                            custom_secret_data.m_custom_database_key[i],
                            custom_secret_data.m_custom_database_key[i+1],
                            custom_secret_data.m_custom_database_key[i+2],
                            custom_secret_data.m_custom_database_key[i+3],
                            custom_secret_data.m_custom_database_key[i+4],
                            custom_secret_data.m_custom_database_key[i+5],
                            custom_secret_data.m_custom_database_key[i+6],
                            custom_secret_data.m_custom_database_key[i+7],
                            i >> 3);
    }

    fprintf(database_h, "    NVRAM_DB_KEY_LAST_Enum_Idx\n");
    fprintf(database_h, "} NVRAM_DB_Key_enum_t;");
#endif

    nvram_gen_close_file(&database_h);
}
#endif  /* __VENDOR_RELEASE__ */

/*****************************************************************************
* FUNCTION
*   nvram_gen_custpack_table
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void nvram_gen_custpack_table(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *output, *output2;
    char output_path[NVRAM_AUTO_GEN_MAX_PATH_LEN*2], output_path2[NVRAM_AUTO_GEN_MAX_PATH_LEN*2];
    int i,j;
    nvram_ltable_entry_struct *ldi;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_path, "%s/nvram_auto_gen/nvram_custpack_table.c", base_path);
    sprintf(output_path2, "%s/nvram_auto_gen/nvram_custpack_table_lid.c", base_path);

    if(!(output = fopen(output_path, "w+")))
    {
        exit(NVRAM_EXIT_CODE_ERROR);
    }

    if(!(output2 = fopen(output_path2, "w+")))
    {
        exit(NVRAM_EXIT_CODE_ERROR);
    }

    fprintf(output,"#if defined(NVRAM_INTERNAL_USE) && !defined(NVRAM_NOT_PRESENT)\n");
    fprintf(output,"/********************************************************\n");
    fprintf(output," *  This file is generated automatically by nvram_auto_gen\n");
    fprintf(output," *  Please do not modify it here manually \n");
    fprintf(output," ***********************************************************/\n");

    fprintf(output2,"#if defined(NVRAM_LTABLE_C_ONLY)\n");
/*
    for (i = NVRAM_EF_START, j = 0; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];

        if (ldi == NULL ||
            (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }

        if (NVRAM_IS_CATEGORY_CUSTPACK(ldi->category))
        {
            j++;
            fprintf(output, "extern kal_uint8 *%s;\n", ldi->str_default_value);
        }
    }

    fprintf(output,"\n");    
*/
    fprintf(output, "const custpack_nvram_header custpack_nvram_ptr = \n");
    fprintf(output2, "const nvram_custpack_lid_tbl_struct custpack_nvram_lid_tbl = \n");

    fprintf(output, "{\n");         fprintf(output2, "{\n");
    fprintf(output, "    0,\n");    fprintf(output2, "    0,\n");
    fprintf(output, "    {\n");     fprintf(output2, "    {\n");

    for (i = NVRAM_EF_START, j = 0; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];

        if (ldi == NULL ||
            (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }

        if (NVRAM_IS_CATEGORY_CUSTPACK(ldi->category))
        {
            j++;
            fprintf(output, "        %s", ldi->str_default_value);
            fprintf(output2, "        %d", ldi->LID);

            if (j != custpack_total_to_verify)
            {
                fprintf(output,",");    fprintf(output2,",");
            }
            fprintf(output,"\n");       fprintf(output2,"\n");
        }
    }


    fprintf(output, "    }\n");         fprintf(output2, "    }\n");
    fprintf(output, "};\n");            fprintf(output2, "};\n");
    fprintf(output, "#endif /* NVRAM_INTERNAL_USE && NVRAM_NOT_PRESENT */\n\n");
    fprintf(output2, "#endif\n\n");

    fclose(output);        fclose(output2);
}

/*****************************************************************************
* FUNCTION
*  nvram_parsing_size_from_mapfile
* DESCRIPTION
*  get default value size.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
kal_uint32 nvram_parsing_size_from_mapfile(char *line_buf)
{
    char *pos = strrchr(line_buf, ' ');
    kal_uint32 val = 0;

    //skip LID name
    if(pos == NULL) {
        return 0;
    }
    *pos = '\0';
    pos = strrchr(line_buf, '0');
    if(pos == NULL) {
        return 0;
    }
    pos = strrchr(line_buf, '\t');
    if(pos == NULL) {
        return 0;
    }
    val = strtol(++pos, NULL, 16);
    //printf("%s:%d\n", pos, val);
    return val;
}

/*****************************************************************************
* FUNCTION
*  nvram_parsing_size_from_mapfile
* DESCRIPTION
*  get default value size.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
kal_uint32 nvram_split(char *line_buf, char **dest)
{
    kal_uint32 num = 0;
    char *pNext = line_buf;

    while(*pNext != '\0' && (*pNext == ' ' || *pNext == '\t')) {
        pNext++;
    }
    *dest = pNext;
    while(*pNext != '\0') {
        if(*pNext == ' ' || *pNext == '\t') {
           *pNext = '\0';
           while(*(++pNext) != '\0' && (*pNext == ' ' || *pNext == '\t'));
           *(++dest) = pNext;
           ++num;
        }
        pNext++;
    }
    return num;
}

/*****************************************************************************
* FUNCTION
*  nvram_parsing_default_from_elf
* DESCRIPTION
*  get default value from elf.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
kal_uint32 nvram_parsing_default_from_elf(char *file_path, nvram_ltable_entry_struct *ldi)
{
    kal_uint32 offset = 0, session = 0;
    kal_uint32 offset4 = 0, offset5 = 0, size = 0;
    FILE *file_handle = NULL;
    char file_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN] = {0};
    char line_buf[128];
    char session_name[128];
    char *dest[16];
    char *str_default_value = ldi->str_default_value;
        
    while(*str_default_value == '&') {
        str_default_value++;
    }
    //Get default value start address from map
    sprintf(file_pathname, "%s.map", file_path);
    file_handle = fopen(file_pathname, "r");
    if (file_handle == NULL)
    {
        printf("fail to open file %s\n", file_pathname);
        return 0;
    }
    while(!feof(file_handle))
    {
        fgets(line_buf, 128, file_handle);
        if((offset == 0) && strstr(line_buf, str_default_value)) {
            nvram_split(line_buf, dest);
            strcpy(session_name, dest[3]);
            sscanf(dest[0],"%x", &offset);
            sscanf(dest[4],"%x", &size);
            ldi->default_value = malloc(size);
            fseek(file_handle, 0, SEEK_SET);
            continue;
        }
        if((offset > 0) && strstr(line_buf, session_name)) {
            nvram_split(line_buf, dest);
            sscanf(dest[4],"%x", &offset4);
            sscanf(dest[5],"%x", &offset5);
            offset -= (offset4 - offset5);
            break;
        }        
    }
    fclose(file_handle);
    file_handle = fopen(file_path, "rb");
    if (file_handle == NULL)
    {
        printf("fail to open file %s\n", file_path);
        return 0;
    }
    fseek(file_handle, offset, SEEK_SET);
    fread(ldi->default_value, size, 1, file_handle);
    fclose(file_handle);

    return offset;
}

/*****************************************************************************
* FUNCTION
*  nvram_default_value_check
* DESCRIPTION
*  Check NVRAM LID size fit default value.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_default_value_check()
{
    kal_bool err = KAL_FALSE;
    int mode_result;
    FILE *file_handle;
    char file_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    char line_buf[128];
    nvram_ltable_entry_struct *ldi;
    kal_uint32 i, default_val_size, ldi_size;

    sprintf(file_pathname, "%s/nvram_auto_gen/nvram_auto_gen_target.map", base_path);
    mode_result = access(file_pathname, 0);

    if (mode_result != 0)
    {
        sprintf(file_pathname, "%s/nvram_auto_gen/nvram_auto_gen.map", base_path);
        mode_result = access(file_pathname, 0);
        if (mode_result != 0)
        {
            //file not exist
            printf("MAP file not exist: %s\n", file_pathname);
            return;
        }        
    }

    file_handle = fopen(file_pathname, "r");
    if (file_handle == NULL)
    {
        fprintf(stderr, "error: cannot open file %s\n", file_pathname);
        exit(NVRAM_EXIT_CODE_ERROR);
    }

    while(!feof(file_handle))
    {
        fgets(line_buf, 128, file_handle);
        for (i = 0; i < nvram_gen_total_lid; i++)
        {
            ldi = &logical_data_item_table[i];
            if((ldi->default_value == NVRAM_EF_FF_DEFAULT) || 
                (ldi->default_value == NVRAM_EF_ZERO_DEFAULT) ||
                (ldi->default_value == NVRAM_EF_SPECIAL_DEFAULT) ||
                (ldi->category & NVRAM_CATEGORY_FUNC_DEFAULT))
            {
                continue;
            }
            if(strstr(line_buf, ldi->str_default_value))
            {
                printf("%s", line_buf);
                default_val_size = nvram_parsing_size_from_mapfile(line_buf);
                if(!default_val_size) {
                    continue;
                }
                if (ldi->attr & NVRAM_ATTR_MULTI_DEFAULT) {
                    ldi_size = ldi->size * ldi->total_records;
                }
                else {
                    ldi_size = ldi->size;
                }
                
                if(default_val_size < ldi_size) {
                    fprintf(stderr, "error: %s[%d] does not match with %s (size %d)\n", ldi->str_default_value, default_val_size, ldi->str_LID, ldi_size);
                    err = KAL_TRUE;
                }
                else if((default_val_size > ldi_size) && (default_val_size % ldi_size)) {
                    fprintf(stderr, "error: %s[%d] does not match with %s (size %d)\n", ldi->str_default_value, default_val_size, ldi->str_LID, ldi_size);
                    err = KAL_TRUE;
                }
            }
        }
    }
    fclose(file_handle);

    if(err) {
        exit(NVRAM_EXIT_CODE_ERROR);
    }
    return;    
}

/*****************************************************************************
* FUNCTION
*  nvram_gen_cat_xml
* DESCRIPTION
*  Output NVRAM LID size Information.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_cat_xml(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *cat_xml_file;
    char output_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    kal_int32 i,j;
    nvram_ltable_entry_struct *ldi;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_pathname, "nvram_auto_gen/custom_nvram_lid_cat.xml");
    nvram_gen_create_file(&cat_xml_file,base_path,output_pathname);

    fprintf(cat_xml_file, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");

    fprintf(cat_xml_file, "<APP>\n");

    for (i = 0; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];

        if (ldi == NULL || (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }

        fprintf(cat_xml_file, "    <NVRAMITEM id=\"%s\"", ldi->str_LID);
        fprintf(cat_xml_file, " prefix=\"%s\"", ldi->fileprefix);
        fprintf(cat_xml_file, " version=\"%s\"", ldi->fileverno);
        fprintf(cat_xml_file, " record_size=\"%d\"", ldi->size);
        fprintf(cat_xml_file, " total_record=\"%d\">\n", ldi->total_records);

        if (ldi->category & NVRAM_CATEGORY_FUNC_DEFAULT)
        {
            fprintf(cat_xml_file, "        <DEFAULT_VALUE defaultByteFill=\"%s()\"></DEFAULT_VALUE>\n", ldi->str_default_value);
        }
        else if (ldi->default_value == NVRAM_EF_FF_DEFAULT)
        {
            fprintf(cat_xml_file, "        <DEFAULT_VALUE defaultByteFill=\"0xFF\"></DEFAULT_VALUE>\n");
        }
        else if (ldi->default_value == NVRAM_EF_ZERO_DEFAULT)
        {
            fprintf(cat_xml_file, "        <DEFAULT_VALUE defaultByteFill=\"0x00\"></DEFAULT_VALUE>\n");
        }
        else if (ldi->default_value == NVRAM_EF_SPECIAL_DEFAULT)
        {
            fprintf(cat_xml_file, "        <DEFAULT_VALUE defaultByteFill=\"0x00\"></DEFAULT_VALUE>\n");
        }    
        else
        {
            kal_uint32 default_value_size;


            if (ldi->attr & NVRAM_ATTR_MULTI_DEFAULT)
            {
                fprintf(cat_xml_file, "        <DEFAULT_VALUE isMultiple=\"TRUE\"> \n");
                default_value_size = ldi->size * ldi->total_records;
            }
            else
            {
                fprintf(cat_xml_file, "        <DEFAULT_VALUE> \n");
                default_value_size = ldi->size;
            }
            if(ldi->default_value == NULL) {
                default_value_size = 0;
            }

            for ( j = 0 ; j < default_value_size ; j++)
            {
                if(default_value_size == 1)
                {
                    fprintf(cat_xml_file, "            [0x%02X]\n        </DEFAULT_VALUE>\n", ldi->default_value[j]);
                }            
                else if (j == 0)
                {
                    fprintf(cat_xml_file, "            [0x%02X,", ldi->default_value[j]);
                }
                else if (j == (default_value_size - 1))
                {
                    fprintf(cat_xml_file, " 0x%02X]\n        </DEFAULT_VALUE>\n", ldi->default_value[j]);
                }
                else if ((j & 0x0F) == 0x0F)
                {
                    fprintf(cat_xml_file, " 0x%02X,\n", ldi->default_value[j]);
                }
                else if ((j & 0x0F) == 0)
                {
                    fprintf(cat_xml_file, "             0x%02X,", ldi->default_value[j]);
                }
                else
                {
                    fprintf(cat_xml_file, " 0x%02X,", ldi->default_value[j]);
                }
            }
        }

        //fprintf(cat_xml_file, "        <DESCRIPTION> %s </DESCRIPTION>\n", ldi->description);
        fprintf(cat_xml_file, "        <DESCRIPTION> %s </DESCRIPTION>\n", ldi->str_LID);
        fprintf(cat_xml_file, "    </NVRAMITEM>\n");
    }

    fprintf(cat_xml_file, "</APP>\n");

    nvram_gen_close_file(&cat_xml_file);
}

#ifndef __VENDOR_RELEASE__
/*****************************************************************************
* FUNCTION
*  nvram_gen_cat_xml
* DESCRIPTION
*  Output NVRAM LID size Information.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_trace(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *trace_file;
    char output_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    kal_int32 i,j;
    nvram_ltable_entry_struct *ldi;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_pathname, "nvram_auto_gen/nvram_gen_trc.h");
    nvram_gen_create_file(&trace_file,base_path,output_pathname);

    fprintf(trace_file, "typedef enum {\n");
    
    for (i = NVRAM_EF_SYS_LID; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];

        if (ldi == NULL || (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }
        else
        {
            fprintf(trace_file, "    _%s = %d,\n", ldi->str_LID, ldi->LID);
        }
    }

    fprintf(trace_file, "    NVRAM_TRC_LID_TOTAL\n}nvram_trc_lid_enum;\n");

    nvram_gen_close_file(&trace_file);
}

#endif    //__VENDOR_RELEASE__
#endif /* NVRAM_NOT_PRESENT */

void nvram_gen_check_multiple_attr_white_list()
{
    int i, j;
    nvram_ltable_entry_struct *ldi;
    kal_bool in_list;
    kal_bool check_result = KAL_TRUE;


    for (i = 0; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];
        if (ldi == NULL || (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }

        if (!NVRAM_IS_ATTR_MULTIPLE(ldi->attr))
        {
            continue;
        }

    #ifdef __NVRAM_BIND_TO_CHIP_CIPHER__
        if (ldi->attr & NVRAM_ATTR_MSP)
        {
            continue;
        }
    #endif

        if (ldi->str_LID == NULL) {
            continue;
        }

        in_list = KAL_FALSE;

        for (j = 0; j < g_nr_nvram_white_list_for_multiple_attr; j++)
        {
            if (0 == strcmp(ldi->str_LID, g_nvram_white_list_for_multiple_attr[j])) {
                in_list = KAL_TRUE;
                break;
            }
        }

        if (KAL_TRUE != in_list) {
            // Not in white list
            check_result = KAL_FALSE;
            fprintf(stderr, "error: LID %s have MULTIPLE attribute but not in white list!!\n", ldi->str_LID);
        }
    }

    if (KAL_TRUE != check_result) {
        fprintf(stderr, "error: Please contact NVRAM owner if you really need this attribute for the LID\n");
        exit(-1);
    }
}


void nvram_gen_check_write_protect_attr_white_list()
{
    int i, j;
    nvram_ltable_entry_struct *ldi;
    kal_bool in_list;
    kal_bool check_result = KAL_TRUE;

    for (i = 0; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];
        if (ldi == NULL || (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }

        if (!NVRAM_IS_ATTR_WRITEPROTECT(ldi->attr))
        {
            continue;
        }

        if (ldi->str_LID == NULL) {
            continue;
        }

        in_list = KAL_FALSE;

        for (j = 0; j < g_nr_nvram_white_list_for_write_protect_attr; j++)
        {
        if (0 == strcmp(ldi->str_LID, g_nvram_white_list_for_write_protect_attr[j])) {
        in_list = KAL_TRUE;
        break;
        }
        }

        if (KAL_TRUE != in_list) {
            // Not in white list
            check_result = KAL_FALSE;
            fprintf(stderr, "LID %s have WRITE_PROTECT attribute but not in white list!!\n", ldi->str_LID);
        }
    }

    if (KAL_TRUE != check_result) {
        fprintf(stderr, "Please contact NVRAM owner if you really need this attribute for the LID(s)\n");
        exit(-2);
    }
}

void nvram_gen_check_lid_enum_overlapping()
{
    int i, j;
    nvram_ltable_entry_struct *ldi1;
    nvram_ltable_entry_struct *ldi2;
    
    kal_bool check_result = KAL_TRUE;

	if(nvram_gen_total_lid < 2) {
		fprintf(stderr, "error: Invalid nvram_gen_total_lid during nvram_gen_check_lid_enum_overlapping()\n");
		exit(-3);
	}
    for (i = 0; i < nvram_gen_total_lid-1; i++)
    {
        ldi1 = &logical_data_item_table[i];
        for (j = i+1; j < nvram_gen_total_lid; j++) {
            ldi2 = &logical_data_item_table[j];
            if (ldi1->LID == ldi2->LID) {
                check_result = KAL_FALSE;
                fprintf(stderr, "error: %d:%s and %d:%s have same enum value, please check if LID duplicated defined or enum value overlapped\n", i, ldi1->str_LID, j, ldi2->str_LID);
            }
        }
    }

    if (KAL_TRUE != check_result) {
        fprintf(stderr, "error: Please contact NVRAM owner if your NVRAM sub-group size should be enlarged\n");
        exit(-3);
    }
}


typedef enum {
    NVRAM_CONFLICT_ATTR_ATTR,
    NVRAM_CONFLICT_CATE_ATTR,
    NVRAM_CONFLICT_CATE_CATE,
} nvram_CATE_ATTR_conflict_type_enum;

typedef struct  {
    nvram_CATE_ATTR_conflict_type_enum type;
    kal_uint32 cate_attr1;
    kal_char *cate_attr1_str;
    kal_uint32 cate_attr2;
    kal_char *cate_attr2_str;
}nvram_CATE_ATTR_conflict_struct;

#define CATE_ATTR(x)     (x), #x

static nvram_CATE_ATTR_conflict_struct nvram_CATE_ATTR_conflict_table[] = 
{
    // Attribute conflicts
    {NVRAM_CONFLICT_ATTR_ATTR, CATE_ATTR(NVRAM_ATTR_MULTIPLE), CATE_ATTR(NVRAM_ATTR_PACKAGE)},
    {NVRAM_CONFLICT_ATTR_ATTR, CATE_ATTR(NVRAM_ATTR_OTA_RESET), CATE_ATTR(NVRAM_ATTR_RESERVE_BACKWARD)},
    {NVRAM_CONFLICT_ATTR_ATTR, CATE_ATTR(NVRAM_ATTR_RAW_DATA), CATE_ATTR(NVRAM_ATTR_PACKAGE|NVRAM_ATTR_MULTIPLE|NVRAM_ATTR_RING)},
    {NVRAM_CONFLICT_ATTR_ATTR, CATE_ATTR(NVRAM_ATTR_RAW_DATA), CATE_ATTR(NVRAM_ATTR_WRITEPROTECT|NVRAM_ATTR_CONFIDENTIAL|NVRAM_ATTR_MSP)},

    // Categories conflicts
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_FUNC_DEFAULT), CATE_ATTR(NVRAM_CATEGORY_CUSTPACK|NVRAM_CATEGORY_SECUPACK)},
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_CALIBRAT), CATE_ATTR(~(NVRAM_CATEGORY_FUNC_DEFAULT|NVRAM_CATEGORY_CUSTPACK|NVRAM_CATEGORY_SECUPACK))},
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_IMPORTANT), CATE_ATTR(NVRAM_CATEGORY_IMPORTANT_L1|NVRAM_CATEGORY_IMPORTANT_L4|NVRAM_CATEGORY_INTERNAL|NVRAM_CATEGORY_OTP)},
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_IMPORTANT_L4), CATE_ATTR(NVRAM_CATEGORY_IMPORTANT_L1|NVRAM_CATEGORY_INTERNAL|NVRAM_CATEGORY_OTP)},
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_IMPORTANT_L1), CATE_ATTR(NVRAM_CATEGORY_INTERNAL|NVRAM_CATEGORY_OTP)},
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_INTERNAL), CATE_ATTR(NVRAM_CATEGORY_CUSTOM_SENSITIVE |NVRAM_CATEGORY_OTP)},
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_CUSTOM_SENSITIVE), CATE_ATTR(NVRAM_CATEGORY_CUSTPACK|NVRAM_CATEGORY_SECUPACK|NVRAM_CATEGORY_OTP)},
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_CUSTPACK), CATE_ATTR(NVRAM_CATEGORY_SECUPACK|NVRAM_CATEGORY_OTP)},
    {NVRAM_CONFLICT_CATE_CATE, CATE_ATTR(NVRAM_CATEGORY_SECUPACK), CATE_ATTR(NVRAM_CATEGORY_OTP)},

    //  Attribute & Category conflicts
    {NVRAM_CONFLICT_CATE_ATTR, CATE_ATTR(NVRAM_CATEGORY_CALIBRAT), CATE_ATTR(NVRAM_ATTR_MULTIPLE|NVRAM_ATTR_MSP|NVRAM_ATTR_RING)},
    {NVRAM_CONFLICT_CATE_ATTR, CATE_ATTR(NVRAM_CATEGORY_CALIBRAT), CATE_ATTR(NVRAM_ATTR_OTA_RESET|NVRAM_ATTR_RESERVE_BACKWARD)},
    {NVRAM_CONFLICT_CATE_ATTR, CATE_ATTR(NVRAM_CATEGORY_INTERNAL), CATE_ATTR(NVRAM_ATTR_PACKAGE)},
    {NVRAM_CONFLICT_CATE_ATTR, CATE_ATTR(NVRAM_CATEGORY_SECUPACK), CATE_ATTR(NVRAM_ATTR_PACKAGE|NVRAM_ATTR_RAW_DATA)},
    {NVRAM_CONFLICT_CATE_ATTR, CATE_ATTR(NVRAM_CATEGORY_CUSTPACK), CATE_ATTR(NVRAM_ATTR_RAW_DATA)},
    {NVRAM_CONFLICT_CATE_ATTR, CATE_ATTR(NVRAM_CATEGORY_FUNC_DEFAULT), CATE_ATTR(NVRAM_ATTR_RAW_DATA)},
    {NVRAM_CONFLICT_CATE_ATTR, CATE_ATTR(NVRAM_CATEGORY_OTP), CATE_ATTR(NVRAM_ATTR_AVERAGE)},
};

static kal_int32 nvram_CATE_ATTR_conflict_table_entries = sizeof(nvram_CATE_ATTR_conflict_table)/sizeof(nvram_CATE_ATTR_conflict_table[0]);

void nvram_gen_check_cate_attr_confilicts()
{
    int i, j;
    nvram_ltable_entry_struct *ldi;
    
    kal_bool check_result = KAL_TRUE;

    for (i = 0; i < nvram_gen_total_lid-1; i++)
    {
        ldi = &logical_data_item_table[i];
        for (j = 0; j < nvram_CATE_ATTR_conflict_table_entries; j++) {
            nvram_CATE_ATTR_conflict_struct *check_cond = &nvram_CATE_ATTR_conflict_table[j];
            switch (check_cond->type) {
            case NVRAM_CONFLICT_ATTR_ATTR:
                if ((ldi->attr & check_cond->cate_attr1) != 0  && (ldi->attr & (~check_cond->cate_attr1) & check_cond->cate_attr2) != 0) {
                    check_result = KAL_FALSE;
                    fprintf(stderr, "error: LID %s have conflict attributes %s and %s\n", ldi->str_LID, check_cond->cate_attr1_str, check_cond->cate_attr2_str);
                }
                break;
            case NVRAM_CONFLICT_CATE_ATTR:
                if ((ldi->category & check_cond->cate_attr1) != 0  && (ldi->attr & check_cond->cate_attr2) != 0) {
                    check_result = KAL_FALSE;
                    fprintf(stderr, "error: LID %s have conflict category %s with attribute %s\n", ldi->str_LID, check_cond->cate_attr1_str, check_cond->cate_attr2_str);
                }
                break;
            case NVRAM_CONFLICT_CATE_CATE:
                if ((ldi->category & check_cond->cate_attr1) != 0  && (ldi->category & (~check_cond->cate_attr1) & check_cond->cate_attr2) != 0) {
                    check_result = KAL_FALSE;
                    fprintf(stderr, "error: LID %s have conflict categories %s and %s\n", ldi->str_LID, check_cond->cate_attr1_str, check_cond->cate_attr2_str);
                }
                break;
            default:
                break;
            }
        }
    }

    if (KAL_TRUE != check_result) {
        fprintf(stderr, "error: Please adjust LID's attributes and/or categories\n");
        exit(-4);
    }
}

void nvram_gen_check_special_lid_parameter()
{
    int i, j;
    nvram_ltable_entry_struct *ldi;
    kal_bool check_result = KAL_TRUE;

    for (i = 0; i < nvram_gen_total_lid-1; i++)
    {
        ldi = &logical_data_item_table[i];
        
        // check RAW_DATA size and default value
        if(ldi->attr & NVRAM_ATTR_RAW_DATA) {
            if(ldi->total_records > 1) {
                check_result = KAL_FALSE;
                fprintf(stderr, "error: NVRAM_ATTR_RAW_DATA can not support multiple record.\n");
            }
            if(ldi->default_value != NVRAM_EF_ZERO_DEFAULT) {
                check_result = KAL_FALSE;
                fprintf(stderr, "error: NVRAM_ATTR_RAW_DATA can only use NVRAM_EF_ZERO_DEFAULT.\n");
            }            
        }

        
    }

    if (KAL_TRUE != check_result) {
        exit(-5);
    }
}

void nvram_fix_lid_size()
{
    kal_uint32 i, j, offset = 0;
    FILE *file_handle = NULL;
    char file_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN] = {0};
    nvram_ltable_entry_struct *ldi = NULL;
    nvram_ltable_entry_struct_target *ldi_target = NULL;
    char line_buf[128], *dest[16];
    char *ldi_buf = NULL;

    //Get NVRAM_LTABLE Start
    sprintf(file_pathname, "%s/nvram_auto_gen/nvram_auto_gen_target.map", base_path);
    file_handle = fopen(file_pathname, "r");
    if (file_handle == NULL)
    {
        printf("fail to open file %s\n", file_pathname);
        return;
    }
    while(!feof(file_handle))
    {
        fgets(line_buf, 128, file_handle);
        if(!offset && strstr(line_buf, "NVRAM_LTABLE")) {
            nvram_split(line_buf, dest);
            sscanf(dest[5],"%x", &offset);
            continue;
        }
        if(strstr(line_buf, "nvram_long_length")) {
            nvram_split(line_buf, dest);
            sscanf(dest[4],"%x", &nvram_long_length);
            continue;
        }
        if(strstr(line_buf, "nvram_ptr_length")) {
            nvram_split(line_buf, dest);
            sscanf(dest[4],"%x", &nvram_ptr_length);
            continue;
        }
        if(strstr(line_buf, "nvram_padding_length")) {
            nvram_split(line_buf, dest);
            sscanf(dest[4],"%x", &nvram_padding_length);
            continue;
        }
    }
    fclose(file_handle);

    //Fix LID size in ltable
    sprintf(file_pathname, "%s/nvram_auto_gen/nvram_auto_gen_target", base_path);
    file_handle = fopen(file_pathname, "rb");
    if (file_handle == NULL)
    {
        printf("fail to open file %s\n", file_pathname);
        return;
    }
    fseek(file_handle, offset, SEEK_SET);
    ldi_buf = malloc(sizeof(nvram_ltable_entry_struct_target) * nvram_gen_total_lid);
    fread(ldi_buf, sizeof(nvram_ltable_entry_struct_target) * nvram_gen_total_lid, 1, file_handle);
    fclose(file_handle); 
    
    for (i = 0; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];
        // search lid in target load
        for(ldi_target = ldi_buf, j = 0; j < nvram_gen_total_lid; j++, ldi_target++) {
            if((ldi->LID == ldi_target->LID) && 
               (*(kal_uint32*)ldi->fileprefix == *(kal_uint32*)ldi_target->fileprefix) ) 
            {
                break;
            }
        }
        if(ldi->LID != ldi_target->LID) {
            if((ldi->LID & 0xFF00) != NVRAM_LID_GRP_INTERNAL(0)) {
                printf("%s[%d] search fail in target load.\n", ldi->str_LID, ldi->LID);
            }
            continue;
        }
        if(ldi->size != ldi_target->size) {
            printf("%s[%d] fix record %s(size %d) <= %s(size %d)\n", ldi->str_LID, ldi->LID, ldi->fileprefix, ldi->size, ldi_target->fileprefix, ldi_target->size);
            ldi->size = ldi_target->size;
            //Mark default value mistake
            if (!(ldi->category & NVRAM_CATEGORY_FUNC_DEFAULT) &&
                (ldi->default_value != NVRAM_EF_FF_DEFAULT) &&
                (ldi->default_value != NVRAM_EF_ZERO_DEFAULT) )
            {
                offset = nvram_parsing_default_from_elf(file_pathname, ldi);
                printf("%s[%d] fix default %s from 0x%X\n", ldi->str_LID, ldi->LID, ldi->str_default_value, offset);
            }
        }
        else {
            //printf("%s[%d] check pass.\n", ldi->str_LID, ldi->LID);
        }
    }
    
}

/*****************************************************************************
* FUNCTION
*  main
* DESCRIPTION
*  main function.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
int main(int argc, char *argv[])
{

#ifndef NVRAM_NOT_PRESENT
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (argc > 0)
    {
        
        typedef void (*_indirect_init_func)(void);
        extern unsigned char indirect_init_begin, indirect_init_end;
        extern void fs_quota_init(void);

        kal_uint32 *value = (kal_uint32 *)&indirect_init_begin;
        kal_uint32 i, total = (kal_uint32)(&indirect_init_end - &indirect_init_begin)/sizeof(_indirect_init_func);

        printf("begin:%x, end:%x\n", &indirect_init_begin, &indirect_init_end);
        printf("init_func = %x, total = %d\n", *value, total);
        for (i = 0; i < total; i++)
        {
            _indirect_init_func init_func = (_indirect_init_func)*value + i ;

            printf("init_func[%i] = %x\n", i, init_func);    
            if (init_func)
            {
                init_func();
            }
        }

        printf("argv[1] = %s, argv[2] = %s\n", argv[1], argv[2]);

        if (strcasecmp(argv[1], "MSWin32") == 0)
        {
            sprintf(indirect_end_symbol, "_indirect_init_end = .");
        }
        else
        {
            sprintf(indirect_end_symbol, "indirect_init_end = .");
        }


        printf("nvram_gen_construct_ltable\n");
        nvram_gen_construct_ltable();

        sprintf(base_path, "%s", argv[1]);

        printf("nvram_fix_lid_size\n");
        nvram_fix_lid_size();
		
        printf("nvram_default_value_check\n");
        nvram_default_value_check();
		
    #ifndef __VENDOR_RELEASE__
        printf("nvram_gen_trace\n");
        nvram_gen_trace();
    #endif

        printf("nvram_gen_cat_xml\n");
        nvram_gen_cat_xml();

        printf("nvram_gen_lid_size\n");
        nvram_gen_lid_size();

        printf("nvram_gen_statistic\n");
        nvram_gen_statistic();

        printf("nvram_gen_restore_function\n");
        nvram_gen_restore_function();

    #if !defined(__L1_STANDALONE__) && defined(__MMI_FMI__)
        printf("nvram_gen_custpack_table\n");
        nvram_gen_custpack_table();
    #endif

    #ifndef __VENDOR_RELEASE__
        printf("nvram_gen_secro\n");
        nvram_gen_secro();
    #endif
    
    #if !defined(__VENDOR_RELEASE__)
        printf("nvram_gen_database_key\n");
        nvram_gen_database_key();
    #endif

        printf("nvram_gen_fs_quota: begin\n");
        nvram_gen_fs_quota(base_path);
        printf("nvram_gen_fs_quota: end\n");

        printf("build time check: begin\n");
        printf("build time check: lid enum overlapping\n");
        nvram_gen_check_lid_enum_overlapping();
        //printf("build time check: multiple attr white list\n");
        //nvram_gen_check_multiple_attr_white_list();
        printf("build time check: write protect attr white list\n");
        nvram_gen_check_write_protect_attr_white_list();
        printf("build time check: cate attr confilicts\n");
        nvram_gen_check_cate_attr_confilicts();
        printf("build time check: special lid parameter\n");
        nvram_gen_check_special_lid_parameter();
        printf("build time check: end\n");

        nvram_gen_ltable_list();

       
    
    }
    return 0;
#else
    printf("NVRAM_NOT_PRESENT\n");
    return 0;
#endif
}
