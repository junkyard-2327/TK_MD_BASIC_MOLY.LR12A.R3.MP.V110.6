/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2006
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   custom_scatstruct.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *   This file provides the scatter file dependent APIs
 *
 * Author:
 * -------
 *   Claudia Lo (mtk01876)     [AUTOGEN_GenVersion]
 * 
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * $Revision$
 * $Modtime$
 * $Log$
 *
 * 06 13 2019 yao.liu
 * [MOLY00411538] [LR12] minidump patch back
 * [LR12A.R3.MP] mini-dump.
 *
 * 01 18 2018 tero.jarkko
 * [MOLY00302507] [MT6739][Zion] Add uSIP memory layout for Zion DSP without EVS support
 * 	
 * 	.
 *
 * 12 07 2017 tero.jarkko
 * [MOLY00294413] Remove unused OTDOA feature from Zion DSP to reduce modem memory usage
 * 	
 * 	.
 *
 * 09 08 2017 tero.jarkko
 * [MOLY00268904] [System Service][MOLY Kernel Internal Request]for fatal 0x9, modify custom_query_code_region to work similarly as custom_query_dump_region.
 * 	
 * 	.
 *
 * 08 16 2017 carl.kao
 * [MOLY00247878] [Gen93] [SystemService] [Auto-Gen] [DSMGR] Fix SYS_SVC/DSMGR build warning
 * .
 *
 * 07 25 2017 carl.kao
 * [MOLY00265930] [Gen93] [SystemService] [Auto-Gen] AMMS DRDI stage 3 (integrate AMMS with MD DRDI)
 * [AMMS STAGE 3/DRDI] main code
 *
 * 07 05 2017 tero.jarkko
 * [MOLY00258516] [Gen93][SystemService][Auto-Gen]custom query code region generated by autogen
 * 	
 * 	.
 *
 * 06 28 2017 tero.jarkko
 * [MOLY00260386] [Gen93][AutoGen]Remove custom_scatstruct.c build warning
 * 	
 * 	.
 *
 * 05 10 2017 tero.jarkko
 * [MOLY00248620] [Gen93][SystemService][Auto-Gen] Assert in Dynamic L2C loack area seen as breakpoint
 * 	
 * 	.
 *
 * 05 04 2017 carl.kao
 * [MOLY00246779] [BIANCO] Enable ASM addon,SWTR and stream mode
 * Remove unused API : custom_get_MaxAvailableMemorySegment
 *
 * 04 07 2017 carl.kao
 * [MOLY00240094] [Gen93] [SystemService] [Auto-Gen] Refine setting of EMI RMPU for Gen93
 * .
 *
 * 03 28 2017 tero.jarkko
 * [MOLY00238285] [Gen93/LR13][SystemService][Auto-Gen][MT6763]Custom query code region for ADT
 * 	
 * 	.
 *
 * 02 13 2017 tero.jarkko
 * [MOLY00229329] [Gen93/LR13][SystemService][Auto-Gen]L2C code query fixed
 * 	
 * 	.
 *
 * 01 25 2017 hw.jheng
 * [MOLY00226817] [System Service] Shrink SWLA Size for Gen93 2 Cores, total 4 MB.
 *
 * 01 23 2017 tero.jarkko
 * [MOLY00226093] [Gen93/LR13][SystemService][Auto-Gen][Bianco Bring-up]Modify SPRAM size and address
 * 	
 * 	.
 *
 * 01 18 2017 tero.jarkko
 * [MOLY00225631] [Gen93/LR13][SystemService][Auto-Gen]Added L2C code check
 * 	
 * 	.
 *
 * 01 04 2017 kari.suvanto
 * [MOLY00196319] [System Service][MOLY Kernel Internal Request]Umoly merge
 * sst: fix nested exception at cache invalidation
 *
 * 10 27 2016 tero.jarkko
 * [MOLY00187425] [LR12][SystemService][Auto-Gen] custom_query_code_region refined
 * 	
 * 	.
 *
 * 09 30 2016 carl.kao
 * [MOLY00205905] [LR12][SystemService][Auto-Gen] Whitney TCM only load
 * .
 *
 * 09 06 2016 tero.jarkko
 * [MOLY00201797] [Gen93/LR13][SystemService][Auto-Gen] Hardcode lds for Gen93 layout
 * 	
 * 	.
 *
 * 06 28 2016 carl.kao
 * [MOLY00179472] [SYSTEM SERVICE][KAL] Fix KAL build warning
 * Fix CUSTOM lib build warning
 *
 * 06 20 2016 carl.kao
 * [MOLY00174068] [LR13][SystemService][Auto-Gen] 93 lds
 * New 93 image layout for MPU setting
 *
 * 05 23 2016 carl.kao
 * [MOLY00180706] [LR12] [SystemService] [Auto-Gen] SWLA space requirement
 * SWLA 3MB -> 6MB (still using NC)
 *
 * 04 13 2016 carl.kao
 * [MOLY00174068] [LR13][SystemService][Auto-Gen] 93 lds
 * Do not use ISPRAM2, DSPRAM2 and L2SRAM in 93
 *
 * 03 11 2016 carl.kao
 * [MOLY00160518] [LR12] [SYSTEM SERVICE] [KAL] [IPC] Fix converity warning in UMOLY TRUNK
 * .
 *
 * 03 04 2016 carl.kao
 * [MOLY00146830] [System Service][MOLY Kernel Internal Request][LR12] SMP SWLA/SWTR modification
 * .
 *
 * 03 03 2016 carl.kao
 * [MOLY00167331] [LR12] [SystemService] [Auto-Gen] [DSMGR] Set DSPRAM and ISPRAM to DSM_UNINIT_STAMP during boot
 * .
 *
 * 02 25 2016 tero.jarkko
 * [MOLY00166535] [LR12][SystemService][Auto-Gen] [Internal Refinement][MT6292] custom_query_dump_region
 * 	
 * 	.
 *
 * 02 24 2016 tero.jarkko
 * [MOLY00164073] [LR12][SystemService][Auto-Gen] [Internal Refinement][MT6292] [sysGen2] Generate custom_scatstruct.c using sysGen2
 * 	
 * 	Added L2SRAM_L2NC and L2SRAM_L2C functions
 *
 * 02 16 2016 tero.jarkko
 * [MOLY00165076] [LR12][SystemService][Auto-Gen] [Internal Refinement][MT6292] [sysGen2] Support custom_query_dynamic_code_region
 * 	
 * 	.
 *
 * 02 04 2016 tero.jarkko
 * [MOLY00164073] [LR12][SystemService][Auto-Gen] [Internal Refinement][MT6292] [sysGen2] Generate custom_scatstruct.c using sysGen2
 * 	
 * 	custom_ram_mk_info
 *
 * 02 03 2016 tero.jarkko
 * [MOLY00164073] [LR12][SystemService][Auto-Gen] [Internal Refinement][MT6292] [sysGen2] Generate custom_scatstruct.c using sysGen2
 * 	
 * 	L2SRAM_L2NC base and length functions added
 *
 * 02 02 2016 tero.jarkko
 * [MOLY00164073] [LR12][SystemService][Auto-Gen] [Internal Refinement][MT6292] [sysGen2] Generate custom_scatstruct.c using sysGen2
 * 	
 * 	.
 *
 * 01 18 2016 carl.kao
 * [MOLY00159955] [LR12][SystemService][Auto-Gen] remove core 3 SPRAM and make SPRAM APIs more robust
 * .
 *
 * 01 14 2016 tero.jarkko
 * [MOLY00160038] [LR12][SystemService][Auto-Gen] [Internal Refinement][MT6292] Support for custom_get_dump_info
 * 	
 * 	Fixed custom_get_dump_info dynamically cached default uncached region comparation
 *
 * 01 13 2016 tero.jarkko
 * [MOLY00160038] [LR12][SystemService][Auto-Gen] [Internal Refinement][MT6292] Support for custom_get_dump_info
 * 	
 * 	Added support for core specific cached address info in custom_get_dump_info
 *
 * 01 12 2016 qmei.yang
 * [MOLY00151351] [SystemService][DebuggingSuite][Internal Refinement][92] Support full exception flow framework
 * 	
 * 	.
 *
 * 01 11 2016 qmei.yang
 * [MOLY00151351] [SystemService][DebuggingSuite][Internal Refinement][92] Support full exception flow framework
 * .
 *
 * 12 29 2015 carl.kao
 * [MOLY00154292] [LR12][SystemService][Auto-Gen] Enable the feature: embed VoLTE core bin address and size information to MD header
 * .
 *
 * 12 23 2015 carl.kao
 * [MOLY00154292] [LR12][SystemService][Auto-Gen] Enable the feature: embed VoLTE core bin address and size information to MD header
 * Rename CACHED_EXTSRAM_VOLTE_CORE_ZI to CACHED_EXTSRAM_ZI_VOLTE_CORE3
 *
 * 11 12 2015 carl.kao
 * [MOLY00148842] [LR12][SystemService][Auto-Gen] 92 lds, for Full region ready, Code in Right Location
 * Support VoLTE core section
 *
 * 11 11 2015 carl.kao
 * [MOLY00148842] [LR12][SystemService][Auto-Gen] 92 lds, for Full region ready, Code in Right Location
 * New image layout for "Full region ready, Code in Right Location"
 *
 * 09 21 2015 carl.kao
 * [MOLY00136979] [92][SYSTEM SERVICE][KAL][IPC] Fix KAL build fail
 * custom_scat
 *
 * 08 28 2015 carl.kao
 * [MOLY00136979] [92][SYSTEM SERVICE][KAL][IPC] Fix KAL build fail
 * .
 *
 * 08 26 2015 carl.kao
 * [MOLY00138715] [92] [SystemService][Auto-Gen] Remove legacy linker symbol
 * .
 *
 * 07 07 2015 carl.kao
 * [MOLY00126388] [UMOLY] [SYSTEM SERVICE][KAL][DSMGR] Add dsmgr to pcore
 * .
 *
 * 07 03 2015 carl.kao
 * [MOLY00125736] [MT6755][BRINGUP_FIRSTCALL] [SystemService][Auto-Gen] add custom_get_L1CORE_INTSRAM_Base and custom_get_L1CORE_INTSRAM_End
 * get l1core tcm base and length
 *
 * 06 15 2015 carl.kao
 * [MOLY00121235] [TK6291] [SystemService][Auto-Gen][Request For Design Change] Query TCM base and end address
 * .
 *
 * 04 16 2015 carl.kao
 * [MOLY00106652] [TK6291] [SystemService][Auto-Gen] add a dynamic switchable default cached MCU-RW, HW-RW section
 * add 4 sections for EMI RMPU
 *   1) (MCU RO, MDHW RW)  DNC 
 *   2) (MCU RO, MDHW RW)  NC 
 *   3) (MCU RW, MDHW RW)  DNC 
 *   4) (MCU RW, MDHW RW)  NC
 *
 * 02 24 2015 qmei.yang
 * [MOLY00096717] [SystemService][DebuggingSuite][Internal Refinement] Support to dump l1core l2sram
 * .
 *
 * 02 24 2015 qmei.yang
 * [MOLY00096717] [SystemService][DebuggingSuite][Internal Refinement] Support to dump l1core l2sram
 * .
 *
 * 12 23 2014 carl.kao
 * [MOLY00088578] [TK6291] [SystemService] [Auto-Gen] Support L2SRAM section (in L1CORE)
 * aa.
 *
 * 12 22 2014 carl.kao
 * [MOLY00087532] [Denali-1] [SystemService][Auto-Gen] Refactor AutoGen Code and Remove Legacy Code
 * .
 *
 * 12 22 2014 carl.kao
 * [MOLY00087532] [Denali-1] [SystemService][Auto-Gen] Refactor AutoGen Code and Remove Legacy Code
 * .
 *
 * 12 02 2014 carl.kao
 * [MOLY00086328] [TK6291] [SystemService][Auto-Gen]  Refine custom_get_l1core_dump_info()
 * .
 *
 * 11 28 2014 carl.kao
 * [MOLY00085983] [TK6291] [SystemService][Auto-Gen] Merge ATCM and BTCM as a single TCM
 * .
 *
 * 11 15 2014 carl.kao
 * [MOLY00083302] [SYSTEM SERVICE][TASK CONFIG] Merge code from MT6291_DEV
 * mcu/pcore
 *
 * 11 06 2014 carl.kao
 * [MOLY00083492] [TK6291] [SystemService][Auto-Gen][Request For Design Change] Add custom_get_MD_RAMEnd() for MPU
 * Add custom_get_MD_RAMEnd() for PCORE MPU
 *
 * 09 11 2014 qmei.yang
 * [MOLY00078623] [SystemService][DebuggingSuite][Internal Refinement][MT6291] Support memory dump
 * .
 *
 * 07 31 2014 carl.kao
 * [MOLY00074124] [SystemService][DebuggingSuite][MT6291] Support multi-core exception
 * dump L1CORE region by PCORE
 *
 * 04 07 2014 carl.kao
 * [MOLY00061797] [SYSTEM SERVICE] porting features from U3G_TK6280_DEV and MOLY.U3G.90IT.DEV branches
 * 9) Rename "l1dsp" to "l1core", "L1DSP" to "L1CORE"
 *
 * 04 02 2014 carl.kao
 * [MOLY00061134] [SYSTEM SERVICE][AutoGen] AutoGen for MT6291
 * 1) pcore sysGen2.
 * 2) Remove useless secure region query API
 *
 * 06 25 2013 qmei.yang
 * [MOLY00025806] [SystemService][Auto-Gen][Request For Design Change] Support COPRO
 * support COPRO_arm7's L1Cache
 *
 * 04 26 2013 qmei.yang
 * [MOLY00020542] [SystemService][MOLY] To remove useless input sections by the request
 * support SWLA space as well
 *
 * 04 09 2013 qmei.yang
 * [MOLY00013707] [SystemService][Auto-Gen][Request For Design Change] Support code integrity for offline SST
 * .
 *
 * 10 31 2012 qmei.yang
 * [MOLY00005605] [SystemService][Auto-Gen][Request For Design Change][sysgen2] Create new API: custom_get_DSPTXRX_MaxSize()
 * .
 * 
 * 08 27 2012 qmei.yang
 * [MOLY00001774] [SystemService][Region_Init][Internal Refinement] Support MT6577 region init and remove useless regions and compile option
 * .
 * 
 * 07 26 2012 qmei.yang
 * [MOLY00001213] [SystemService][Auto-Gen][Internal Refinement] Fix GCC warnings
 * .
 *
 * 05 28 2012 qmei.yang
 * [MAUI_03164047] [SystemService][Auto-Gen][GCC][Internal Refinement] support AutoGen on GCC
 * Support GCC to use attribute instead of pragma
 *
 * 05 10 2012 qmei.yang
 * [MAUI_03182425] [Reason]sync codes between modem_dev and 11B
 * .
 *
 * 04 16 2012 qmei.yang
 * [MAUI_03169203] [SystemService][Auto-Gen][Request For Design Change] Add 3 objs into TCM and put 3 functions to TCM on MT6280
 * add 3 functions to TCM
 *
 * 03 08 2012 qmei.yang
 * [MAUI_03145378] [SystemService][Auto-Gen][Sys Gen][scatGen][Internal Refinement] Phase in AutoGen new flow to support GCC
 * .
 *
 * 02 15 2012 qmei.yang
 * [MAUI_03130553] [SystemService][Auto-Gen][Sys Gen][scatGen][Internal Refinement] Support cmmgen sync with sysgen2
 * Modify custom_query_dump_region() API
 *
 * 02 15 2012 qmei.yang
 * [MAUI_03130553] [SystemService][Auto-Gen][Sys Gen][scatGen][Internal Refinement] Support cmmgen sync with sysgen2
 * Modify custom_query_dump_region() API
 *
 * 01 31 2012 qmei.yang
 * [MAUI_03120516] [SystemService][Auto-Gen][Sys Gen][scatGen][Internal Refinement] Refactory sysgen2.pl
 * .
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/


#include "kal_general_types.h"
#include "kal_iram_section_defs.h"

#include "init.h"
#include "cache_sw_int.h"
#include "cache_sw.h"
#include "custom_scatstruct.h"

#ifdef __MTK_TARGET__
extern kal_uint32 custom_get_fat_addr();
extern kal_uint32 custom_get_fat_len();
extern kal_uint32 INT_RetrieveFlashBaseAddr(void);
/*******************************************************************************
 * Define import global data.
 *******************************************************************************/

[AUTOGEN_SCAT_C_Gen_REGION_SYMBOL]


#define NUM_AVAILABLE_CORE (2)

/***temp************************************************************************/
DECLARE_NOINLINE kal_uint32 scat_max(kal_uint32 A1, kal_uint32 A2)
{
	return ( ((A1)>=(A2)) ? (A1) : (A2) );
}


#define LoadBase(ID, spram_index)       Load$$##ID##SPRAM##spram_index##$$Base
#define ImageBase(ID, spram_index)      Image$$##ID##SPRAM##spram_index##$$Base
#define ImageLimit(ID, spram_index)     Image$$##ID##SPRAM##spram_index##$$Limit
#define ImageLength(ID, spram_index)    Image$$##ID##SPRAM##spram_index##$$Length
#define ImagePhyLength(ID, spram_index) Image$$##ID##SPRAM##spram_index##_PHYSICAL_BOUNDARY$$Length
#define ImageZIBase(ID, spram_index)    Image$$##ID##SPRAM##spram_index##$$ZI$$Base
#define ImageZILimit(ID, spram_index)   Image$$##ID##SPRAM##spram_index##$$ZI$$Limit
#define ImageZILength(ID, spram_index)  Image$$##ID##SPRAM##spram_index##$$ZI$$Length


#define SPRAM_LINKER_SYMBOL_DEFINE(spram_index) \
    extern kal_uint32 LoadBase(I, spram_index); \
    extern kal_uint32 ImageBase(I, spram_index); \
    extern kal_uint32 ImageLimit(I, spram_index); \
    extern kal_uint32 ImageLength(I, spram_index); \
    extern kal_uint32 LoadBase(D, spram_index); \
    extern kal_uint32 ImageBase(D, spram_index); \
    extern kal_uint32 ImageLimit(D, spram_index); \
    extern kal_uint32 ImageLength(D, spram_index); \
    extern kal_uint32 ImageZIBase(D, spram_index); \
    extern kal_uint32 ImageZILimit(D, spram_index); \
    extern kal_uint32 ImageZILength(D, spram_index);


SPRAM_LINKER_SYMBOL_DEFINE(0)
SPRAM_LINKER_SYMBOL_DEFINE(1)


static const kal_uint32 _ispram_load_addr[NUM_AVAILABLE_CORE]   = {(kal_uint32)&LoadBase(I,0),      (kal_uint32)&LoadBase(I,1)};
static const kal_uint32 _ispram_start_addr[NUM_AVAILABLE_CORE]  = {(kal_uint32)&ImageBase(I,0),     (kal_uint32)&ImageBase(I,1)};
static const kal_uint32 _ispram_end_addr[NUM_AVAILABLE_CORE]    = {(kal_uint32)&ImageLimit(I,0),    (kal_uint32)&ImageLimit(I,1)};

static const kal_uint32 _dspram_load_addr[NUM_AVAILABLE_CORE]   = {(kal_uint32)&LoadBase(D,0),      (kal_uint32)&LoadBase(D,1)};
static const kal_uint32 _dspram_start_addr[NUM_AVAILABLE_CORE]  = {(kal_uint32)&ImageBase(D,0),     (kal_uint32)&ImageBase(D,1)};
static const kal_uint32 _dspram_end_addr[NUM_AVAILABLE_CORE]    = {(kal_uint32)&ImageLimit(D,0),    (kal_uint32)&ImageLimit(D,1)};
static const kal_uint32 _dspram_zi_start_addr[NUM_AVAILABLE_CORE]= {(kal_uint32)&ImageZIBase(D,0),     (kal_uint32)&ImageZIBase(D,1)};
static const kal_uint32 _dspram_zi_end_addr[NUM_AVAILABLE_CORE]  = {(kal_uint32)&ImageZILimit(D,0),    (kal_uint32)&ImageZILimit(D,1)};
static const kal_uint32 _dspram_phy_length[NUM_AVAILABLE_CORE]    = {(kal_uint32)&ImagePhyLength(D,0),    (kal_uint32)&ImagePhyLength(D,1)};
[AUTOGEN_SCAT_C_Gen_ARRAY_DYNAMIC_CODE_REGION]

[AUTOGEN_SCAT_C_Gen_ARRAY_CODE_REGIONS]
/***temp************************************************************************/

typedef struct dump_info_str {
    kal_uint32 start;
    kal_uint32 end;
    kal_uint8 op;

}dump_info_str;

static dump_info_str dump_info[] = {
       [AUTOGEN_SCAT_C_Gen_TEMPLATE_CORE0_CACHEABLE_ASSING],
       [AUTOGEN_SCAT_C_Gen_TEMPLATE_CORE1_CACHEABLE_ASSING]
};

/*******************************************************************************
 * Define import global data.
 *******************************************************************************/

#if defined(__ARM9_MMU__) || defined(__ARM11_MMU__)

/* define pool size for fine page table and coarse page table */
/*     CPT : 1 (TCM) 
 *       + 4 * (number of continous dynamic CACHEABLE default non-cacheable region)
 *       + 4 * (number of continous dynamic CACHEABLE default cacheable region)
 *       + 4 * (number of continous CACHED region)
 *       + 4 * (number of continous CACHED code region)
 *       + 2 * (number of non-cacched EXTSRAM RW region)
 *       + 2 * (number of non-cacched EXTSRAM RO region)
 *       + 1   (DSP_TX DSP_RX ... )
 *       +     (number of ROM - 1)
 *       + 2   (at the beginning and at the end of FAT)
 * */
#if defined(__ARM9_MMU__)
[AUTOGEN_SCAT_C_Gen_ARM9_PT_POOLSIZE]
#elif defined(__ARM11_MMU__)
[AUTOGEN_SCAT_C_Gen_ARM11_PT_POOLSIZE]
#endif /* __ARM11_MMU__ */

#if defined(__ARM9_MMU__)
/* memory pool of fine page table */
#if (MAX_FPT_POOL_SIZE > 0)
__PT_Aligned(4 * 1024) static kal_uint32 FPT_POOL[MAX_FPT_POOL_SIZE / 4];
#endif /* MAX_FPT_POOL_SIZE > 0 */
#endif /* __ARM9_MMU__ */
/* memory pool of coarse page table */
__PT_Aligned(1024) static  kal_uint32 CPT_POOL[MAX_CPT_POOL_SIZE / 4];

#endif /* __ARM9_MMU__ || __ARM11_MMU__ */

#if defined(__DYNAMIC_SWITCH_CACHEABILITY__)

[AUTOGEN_SCAT_C_Gen_ARRAY_EXTSRAM_REGION]

#endif /* __DYNAMIC_SWITCH_CACHEABILITY__ */


#if defined(__ARM9_MMU__) || defined(__ARM11_MMU__)
#if defined(__ARM9_MMU__)
/*************************************************************************
* FUNCTION
*  custom_query_fpt_pool
*
* DESCRIPTION
*  This function gets the address and size of fpt pool.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_query_fpt_pool(kal_uint32 **pool, kal_uint32 *pool_size)
{
#if (MAX_FPT_POOL_SIZE > 0)
    *pool = FPT_POOL;
    *pool_size = MAX_FPT_POOL_SIZE;
#else /* MAX_FPT_POOL_SIZE > 0 */
    *pool = NULL;
    *pool_size = 0;
#endif /* MAX_FPT_POOL_SIZE > 0 */

    return 0;
}
#endif /* __ARM9_MMU__ */

/*************************************************************************
* FUNCTION
*  custom_query_cpt_pool
*
* DESCRIPTION
*  This function gets the address and size of cpt pool.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_query_cpt_pool(kal_uint32 **pool, kal_uint32 *pool_size)
{
    *pool = CPT_POOL;
    *pool_size = MAX_CPT_POOL_SIZE;

    return 0;
}

#endif /* __ARM9_MMU__ || __ARM11_MMU__ */

#if defined(__DYNAMIC_SWITCH_CACHEABILITY__)

/************************************************************************
* FUNCTION
*  custom_query_dynamic_cached_extsram_default_nc_region
*
* DESCRIPTION
*  This function gets info of dynamic cached default non-cached EXT SRAM regions.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_query_dynamic_cached_extsram_default_nc_region(EXTSRAM_REGION_INFO_T **region)
{
    *region = DYNAMIC_CACHED_EXTSRAM_DNC_REGION;

    return 0;
}

/************************************************************************
* FUNCTION
*  custom_query_dynamic_cached_extsram_default_c_region
*
* DESCRIPTION
*  This function gets info of dynamic cached default cached EXT SRAM regions.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_query_dynamic_cached_extsram_default_c_region(EXTSRAM_REGION_INFO_T **region)
{
    *region = DYNAMIC_CACHED_EXTSRAM_DC_REGION;

    return 0;
}

/*************************************************************************
* FUNCTION
*  custom_query_cached_extsram_region
*
* DESCRIPTION
*  This function gets info of cached EXT SRAM regions.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_query_cached_extsram_region(EXTSRAM_REGION_INFO_T **region)
{
    *region = CACHED_EXTSRAM_REGION;

    return 0;
}

/*************************************************************************
* FUNCTION
*  custom_query_cached_extsram_code_region
*
* DESCRIPTION
*  This function gets info of cached EXT SRAM code regions.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
__TCMROCODE
kal_int32 custom_query_cached_extsram_code_region(EXTSRAM_REGION_INFO_T **region)
{
    *region = CACHED_EXTSRAM_CODE_REGION;

    return 0;
}

/*************************************************************************
* FUNCTION
*  custom_query_noncached_extsram_region
*
* DESCRIPTION
*  This function gets info of non-cached RW EXT SRAM regions.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
__TCMROCODE
kal_int32 custom_query_noncached_extsram_region(EXTSRAM_REGION_INFO_T **region)
{
    *region = NONCACHED_EXTSRAM_REGION;

    return 0;
}

/*************************************************************************
* FUNCTION
*  custom_query_noncached_extsram_ro_region
*
* DESCRIPTION
*  This function gets info of non-cached RO EXT SRAM regions.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
__TCMROCODE
kal_int32 custom_query_noncached_extsram_ro_region(EXTSRAM_REGION_INFO_T **region)
{
    *region = NONCACHED_EXTSRAM_RO_REGION;

    return 0;
}
#endif /* __DYNAMIC_SWITCH_CACHEABILITY__ */

/*************************************************************************
* FUNCTION
*  custom_query_dynamic_code_region
*
* DESCRIPTION
*  This function gets info of dynamic code regions.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_query_dynamic_code_region(DYNAMIC_CODE_MEM_T core_id,DYNAMIC_CODE_REGION_INFO_T **region)
{
	switch(core_id)
        {
	case DC_ISPRAM0:
    	  *region = (DYNAMIC_CODE_REGION_INFO_T *)ISPRAM0_CODE_SECTIONS;
	break;
	case DC_ISPRAM1:
    	  *region = (DYNAMIC_CODE_REGION_INFO_T *)ISPRAM1_CODE_SECTIONS;
	break;
	default:
          *region = (DYNAMIC_CODE_REGION_INFO_T *)0;
	  return -1;
	}  
    return 0;
}


/*************************************************************************
* FUNCTION
*  custom_get_1st_ROM_ROMBase
*
* DESCRIPTION
*  Retrieve the base address of the 1st ROM (Load View)
*  This function must sync with scatter file structure
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_1st_ROM_ROMBase(void)
{
    kal_uint32 address = (kal_uint32)&Image$$[AUTOGEN_SCAT_C_Gen_RegionName_EV_1stROM_BEGIN]$$Base;
    address = MAP2CREGPA(address);	   
    return address;
}

/*************************************************************************
* FUNCTION
*  custom_get_1st_ROM_ROMLength
*
* DESCRIPTION
*  Retrieve the actual ROM length of 1st ROM (Load View)
*  This function must sync with scatter file structure
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_1st_ROM_ROMLength(void)
{
    kal_uint32 ROMLength = 0;
    kal_uint32 ROM_Regions[] = {
[AUTOGEN_SCAT_C_Gen_TEMPLATE_1stROM_LENGTH]};
    kal_uint32 index;
    kal_uint32 address = 0 ;
    kal_uint32 length = 0;
    for(index = 0; index < (sizeof(ROM_Regions)/sizeof(kal_uint32));index=index+2){
        if (!index) {
            if ( (MAP2CREGPA(ROM_Regions[index])+MAP2CREGPA(ROM_Regions[index+1])) > (address+length) ) {
                address = MAP2CREGPA(ROM_Regions[index]);
                length = MAP2CREGPA(ROM_Regions[index+1]);
	        }
        } else {
            address = MAP2CREGPA(ROM_Regions[index]);
            length = MAP2CREGPA(ROM_Regions[index+1]);
        }
    }
	    
    ROMLength = address + length;
    return ROMLength; 
}

/*************************************************************************
* FUNCTION
*  custom_get_1st_ROM_RAMBase
*
* DESCRIPTION
*  Retrieve the RAM base address of the 1st ROM (Load View)
*  This function must sync with scatter file structure
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_1st_ROM_RAMBase(void)
{
    return [AUTOGEN_SCAT_C_Gen_TEMPLATE_1stRAM_BEGIN];
}

/*************************************************************************
* FUNCTION
*  custom_get_1st_ROM_RAMLength
*
* DESCRIPTION
*  Retrieve the actual RAM length of 1st ROM (Load View)
*  This function must sync with scatter file structure
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_1st_ROM_RAMLength(void)
{
    kal_uint32 RAMLength = 0;
    
    return RAMLength; 
}

/*************************************************************************
* FUNCTION
*  custom_get_1st_ROM_RAMEnd
*
* DESCRIPTION
*  Retrieve the actual end address of 1st ROM (Exec View)
*  This function must sync with scatter file structure
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_1st_ROM_RAMEnd(void)
{
    kal_uint32 EndAddr = 0;

    EndAddr  = (kal_uint32)&Image$$[AUTOGEN_SCAT_C_Gen_RegionName_EV_1stRAM_END]$$ZI$$Limit;

    return EndAddr; 
}

/*************************************************************************
* FUNCTION
*  custom_get_1st_ROM_LoadEnd
*
* DESCRIPTION
*  Retrieve the actual end address of 1st ROM (Load View)
*  This function must sync with scatter file structure
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_1st_ROM_LoadEnd(void)
{
    kal_uint32 EndAddr = 0;

    EndAddr  = (kal_uint32)&Load$$[AUTOGEN_SCAT_C_Gen_RegionName_EV_1stROM_END]$$Base;
    EndAddr += (kal_uint32)&Image$$[AUTOGEN_SCAT_C_Gen_RegionName_EV_1stROM_END]$$Length;

    return EndAddr; 
}

/*************************************************************************
* FUNCTION
*  custom_get_1st_ROM_MCURWBase
*
* DESCRIPTION
*  Retrieve the base address for MDMCU_RW MDHR_RO base, keyword, EXTSRAM and non-MCURO
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_1st_ROM_MCURWBase(void)
{
    kal_uint32 BaseAddr = 0;

    BaseAddr  = (kal_uint32)&Image$$[AUTOGEN_SCAT_C_Gen_TEMPLATE_1st_MCURW_SECTION]$$Base;

    return BaseAddr; 
}


/*************************************************************************
* FUNCTION
*  custom_get_ISPRAM_Load_Base
*
* DESCRIPTION
*  Retrieve the base view address of ISPRAM by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_ISPRAM_Load_Base(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = _ispram_load_addr[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}

/*************************************************************************
* FUNCTION
*  custom_get_ISPRAM_CODE_Base
*
* DESCRIPTION
*  Retrieve the execution view base address of ISPRAM code by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_ISPRAM_CODE_Base(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = _ispram_start_addr[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}

/*************************************************************************
* FUNCTION
*  custom_get_ISPRAM_End
*
* DESCRIPTION
*  Retrieve the execution view end address of ISPRAM code by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_ISPRAM_CODE_End(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = _ispram_end_addr[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}

/*************************************************************************
* FUNCTION
*  custom_get_ISPRAM_Base
*
* DESCRIPTION
*  Retrieve the execution view base address of ISPRAM by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_ISPRAM_Base(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    return custom_get_ISPRAM_CODE_Base(core_id, ret_addr);
}

/*************************************************************************
* FUNCTION
*  custom_get_ISPRAM_End
*
* DESCRIPTION
*  Retrieve the execution view end address of ISPRAM by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_ISPRAM_End(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    extern kal_uint32 Image$$ISPRAM$$Length ;

    kal_status ret;
    kal_uint32 base;

    ret = custom_get_ISPRAM_Base(core_id, &base);
    if (KAL_SUCCESS!=ret)
    {
        *ret_addr = 0;
        return ret;
    }

    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = base + (kal_uint32) &Image$$ISPRAM$$Length ; /*we assume the length of all ISPRAMs are the same */
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}



/*************************************************************************
* FUNCTION
*  custom_get_DSPRAM_Load_Base
*
* DESCRIPTION
*  Retrieve the base view address of DSPRAM by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_DSPRAM_Load_Base(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = _dspram_load_addr[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}

/*************************************************************************
* FUNCTION
*  custom_get_DSPRAM_DATA_Base
*
* DESCRIPTION
*  Retrieve the execution view base address of DSPRAM RW by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_DSPRAM_DATA_Base(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = _dspram_start_addr[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}

/*************************************************************************
* FUNCTION
*  custom_get_DSPRAM_DATA_End
*
* DESCRIPTION
*  Retrieve the execution view end address of DSPRAM RW by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_DSPRAM_DATA_End(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = _dspram_end_addr[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}


/*************************************************************************
* FUNCTION
*  custom_get_DSPRAM_DATA_ZI_Base
*
* DESCRIPTION
*  Retrieve the execution view base address of DSPRAM ZI by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_DSPRAM_DATA_ZI_Base(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = _dspram_zi_start_addr[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}

/*************************************************************************
* FUNCTION
*  custom_get_DSPRAM_DATA_ZI_End
*
* DESCRIPTION
*  Retrieve the execution view end address of DSPRAM ZI by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_DSPRAM_DATA_ZI_End(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = _dspram_zi_end_addr[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}



/*************************************************************************
* FUNCTION
*  custom_get_DSPRAM_Base
*
* DESCRIPTION
*  Retrieve the execution view base address of DSPRAM by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_DSPRAM_Base(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    return custom_get_DSPRAM_DATA_Base(core_id, ret_addr);
}

/*************************************************************************
* FUNCTION
*  custom_get_ISPRAM_End
*
* DESCRIPTION
*  Retrieve the execution view end address of DSPRAM by core id
*
* PARAMETERS
* core id
*
* RETURNS
*
*************************************************************************/
kal_status custom_get_DSPRAM_End(kal_uint8 core_id, kal_uint32 *ret_addr)
{
    kal_status ret;
    kal_uint32 base;

    ret = custom_get_DSPRAM_Base(core_id, &base);
    if (KAL_SUCCESS!=ret)
    {
        *ret_addr = 0;
        return ret;
    }

    if (core_id<NUM_AVAILABLE_CORE)
    {
        *ret_addr = base + (kal_uint32) _dspram_phy_length[core_id];
        return KAL_SUCCESS;
    }

    *ret_addr = 0;
    return KAL_ERROR;
}

/*************************************************************************
* FUNCTION
*  custom_get_DYNAMIC_SECTION_L2CACHE_LOCK_Base
*
* DESCRIPTION
*  Retrieve the base of DYNAMIC L2CACHE LOCK
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_get_DYNAMIC_SECTION_L2CACHE_LOCK_Base(void)
{
    extern kal_uint32 DYNAMIC_SECTION_L2CACHE_LOCK_0$$Base;

    return (kal_uint32) &DYNAMIC_SECTION_L2CACHE_LOCK_0$$Base;
}

/*************************************************************************
* FUNCTION
*  custom_get_DYNAMIC_SECTION_L2CACHE_LOCK_Length
*
* DESCRIPTION
*  Retrieve the end of DYNAMIC L2CACHE LOCK
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_get_DYNAMIC_SECTION_L2CACHE_LOCK_RW_Base(void)
{
    extern kal_uint32 DYNAMIC_SECTION_L2CACHE_LOCK_0_DATA$$Base;

    return (kal_uint32) &DYNAMIC_SECTION_L2CACHE_LOCK_0_DATA$$Base;
}

/*************************************************************************
* FUNCTION
*  custom_get_L2CACHE_LOCK_Base
*
* DESCRIPTION
*  Retrieve the base of L2CACHE LOCK
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_get_L2CACHE_LOCK_Base(void)
{
    extern kal_uint32 L2CACHE_LOCK$$Base;

    return (kal_uint32) &L2CACHE_LOCK$$Base;
}

/*************************************************************************
* FUNCTION
*  custom_get_L2CACHE_LOCK_End
*
* DESCRIPTION
*  Retrieve the end of L2CACHE LOCK
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_get_L2CACHE_LOCK_End(void)
{
    extern kal_uint32 L2CACHE_LOCK$$Limit;

    return (kal_uint32) &L2CACHE_LOCK$$Limit;
}

/*************************************************************************
* FUNCTION
*  custom_get_L2CACHE_LOCK_Length
*
* DESCRIPTION
*  Retrieve the end of L2CACHE LOCK
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_get_L2CACHE_LOCK_Length(void)
{
    extern kal_uint32 L2CACHE_LOCK$$Length;

    return (kal_uint32) &L2CACHE_LOCK$$Length;
}

/*************************************************************************
* FUNCTION
*  custom_get_L2CACHE_LOCK_Length
*
* DESCRIPTION
*  Retrieve the end of L2CACHE LOCK
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_get_L2CACHE_LOCK_RW_Base(void)
{
    extern kal_uint32 L2CACHE_LOCK_DATA$$Base;

    return (kal_uint32) &L2CACHE_LOCK_DATA$$Base;
}

/*************************************************************************
* FUNCTION
*  custom_get_DSPTXRX_Base
*
* DESCRIPTION
*  Retrieve the lowest base address of DSP_TX or DSP_RX
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_get_DSPTXRX_Base(void)
{
    return [AUTOGEN_SCAT_C_Gen_TEMPLATE_DSPTXRX_BEGIN];
}
/*************************************************************************
* FUNCTION
*  custom_get_DSPTXRX_MaxSize
*
* DESCRIPTION
*  Retrieve the reserved size of DSP_TX plus DSP_RX
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_int32 custom_get_DSPTXRX_MaxSize(void)
{
    return [AUTOGEN_SCAT_C_Gen_TEMPLATE_DSPTXRX_MAXSIZE];
}

/*************************************************************************
* FUNCTION
*  custom_get_FAT_StartAddr
*
* DESCRIPTION
*  Retrieve FAT base address
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_FAT_StartAddr(void)
{
    return (custom_get_fat_addr() | INT_RetrieveFlashBaseAddr());
}

/*************************************************************************
* FUNCTION
*  custom_get_FAT_Length
*
* DESCRIPTION
*  Retrieve FAT length
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_FAT_Length(void)
{
    return custom_get_fat_len();
}

kal_uint32 custom_get_MD_RAMEnd(void)
{
    kal_uint32 EndAddr = 0;

    EndAddr  = (kal_uint32)&Image$$DUMMY_END$$Base;

    return EndAddr; 
}



/*************************************************************************
* FUNCTION
*  custom_mk_ram_info
*
* DESCRIPTION
*  This function builds up EXTSRAM info tables.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
#if defined(__ARM9_MMU__) || defined(__ARM11_MMU__) || defined(__MTK_MMU__) || defined(__CR4__) || defined(__MTK_MMU_V2__) || defined(__MIPS_IA__)
kal_int32 custom_mk_ram_info()
{
    /* This table contains all dynamic cacheable default non-cacheable regions. */
[AUTOGEN_SCAT_C_Gen_TEMPLATE_EXTSRAM_REGION_DYNAMIC_DNC_ASSIGN]

    /* This table contains all dynamic cacheable default cacheable regions. */
[AUTOGEN_SCAT_C_Gen_TEMPLATE_EXTSRAM_REGION_DYNAMIC_DC_ASSIGN]

    /* This table contains all cached regions. */
[AUTOGEN_SCAT_C_Gen_TEMPLATE_EXTSRAM_REGION_CACHED_RW_ASSIGN]

    /* This table contains all cached code regions. */
[AUTOGEN_SCAT_C_Gen_TEMPLATE_EXTSRAM_REGION_CACHED_RO_ASSIGN]

    /* This table contains all non-cached rw regions. */
[AUTOGEN_SCAT_C_Gen_TEMPLATE_EXTSRAM_REGION_NONCACHED_RW_ASSIGN]

    /* This table contains all non-cached ro regions. */
[AUTOGEN_SCAT_C_Gen_TEMPLATE_EXTSRAM_REGION_NONCACHED_RO_ASSIGN]


    return 0;
}
#endif /* __ARM9_MMU__ || __ARM11_MMU__ || __MTK_MMU__ || __CR4__ || __MTK_MMU_V2__ || __MIPS_IA__*/


/*************************************************************************
* FUNCTION
*  custom_get_NVRAM_LTABLE_Base
*
* DESCRIPTION
*  Retrieve the base address of NVRAM_LTABLE
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_NVRAM_LTABLE_Base(void)
{
    return [AUTOGEN_SCAT_C_Gen_TEMPLATE_NVRAM_BASE];
}

/*************************************************************************
* FUNCTION
*  custom_get_NVRAM_LTABLE_Length
*
* DESCRIPTION
*  Retrieve the length of NVRAM_LTABLE
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_NVRAM_LTABLE_Length(void)
{
    return [AUTOGEN_SCAT_C_Gen_TEMPLATE_NVRAM_LENGTH];
}


/*************************************************************************
* FUNCTION
*  custom_get_VOLTE_CORE_ZI_base
*
* DESCRIPTION
*  Retrieve the base of CACHED_EXTSRAM_ZI_VOLTE_CORE3 section
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_VOLTE_CORE_ZI_base(void)
{
    extern kal_uint32 Image$$CACHED_EXTSRAM_ZI_VOLTE_CORE3$$Base;

    return (kal_uint32) &Image$$CACHED_EXTSRAM_ZI_VOLTE_CORE3$$Base;
}


/*************************************************************************
* FUNCTION
*  custom_get_VOLTE_CORE_ZI_End
*
* DESCRIPTION
*  Retrieve the end of CACHED_EXTSRAM_ZI_VOLTE_CORE3 section
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_get_VOLTE_CORE_ZI_End(void)
{
    extern kal_uint32 Image$$CACHED_EXTSRAM_ZI_VOLTE_CORE3$$ZI$$Limit;

    return (kal_uint32) &Image$$CACHED_EXTSRAM_ZI_VOLTE_CORE3$$ZI$$Limit;
}


/*************************************************************************
* FUNCTION
*  custom_query_dump_region
*
* DESCRIPTION
*  This function builds up the table of DUMP REGIONs.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_query_dump_region(EXTSRAM_REGION_INFO_T* region)
{
[AUTOGEN_SCAT_C_Gen_TEMPLATE_DUMP_REGION_ASSIGN]
}

/*************************************************************************
* FUNCTION
*  custom_query_dump_region_without_UC_ROM
*
* DESCRIPTION
*  This function builds up the table of DUMP REGIONs without UC ROM.
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_query_dump_region_without_UC_ROM(EXTSRAM_REGION_INFO_T* region)
{
[AUTOGEN_SCAT_C_Gen_TEMPLATE_DUMP_REGION_NO_UC_ROM_ASSIGN]
}

kal_uint8 custom_get_dump_info(kal_uint32 *address)
{
    extern kal_uint32 sst_get_main_exception_core(void);

    kal_uint32 nCachedPrefix;
    kal_uint32 nonCacheAddr;
    kal_uint32 CachedAddr = (*address);
    kal_uint8 op = DUMP_OP_NONE;
    kal_uint32 index = 0;
    nCachedPrefix = [AUTOGEN_SCAT_C_Gen_TEMPLATE_CACHEABLE_PREFIX];

    if ( ((CachedAddr & 0xF0000000) ^  nCachedPrefix) == 0) /*if it's cached address*/
    {
	nonCacheAddr = CachedAddr & (~nCachedPrefix);
    	for (index = 0; index < (sizeof(dump_info)/sizeof(dump_info_str));index++)
    	{
		//size check, if start==end then empty section
		if ((dump_info[index].start&0x0FFFFFFF) == (dump_info[index].end&0x0FFFFFFF))
			continue;

		if ( (((dump_info[index].start&0x0FFFFFFF)|nCachedPrefix)<= CachedAddr) && 
              	(CachedAddr <= ((dump_info[index].end&0x0FFFFFFF)|nCachedPrefix)) )
        	{
			op = dump_info[index].op;
			(*address) = nonCacheAddr;
	    		break;
        	}
    	}
    }
    if ((op == (sst_get_main_exception_core()+1)) && (op != DUMP_OP_NONE))
    {
        op = DUMP_OP_NONE;   
    }
    return op;
}


/*************************************************************************
* FUNCTION
*  custom_query_code_region
*
* DESCRIPTION
*  This function builds up the table of DUMP REGIONs.
*
* PARAMETERS
*  core_id
* RETURNS
*
*************************************************************************/
kal_bool custom_query_code_region(kal_uint32 code_addr, kal_uint32 core_id)
{
    kal_uint32 index = 0;
    while((CODE_SECTIONS[index][0] !=0) || (CODE_SECTIONS[index][1] !=0))
    {
        if( (CODE_SECTIONS[index][0] <= code_addr) && (code_addr < (CODE_SECTIONS[index][0]+CODE_SECTIONS[index][1])))
        {
             return KAL_TRUE;
        }
	index++;
    }
    return KAL_FALSE;
}




/*************************************************************************
* FUNCTION
*  custom_query_EMI_RMPU_region_info
*
* DESCRIPTION
*  This function gets info of EMI RMPU for setting to BUS MPU
*
* PARAMETERS
*
* RETURNS
*
*************************************************************************/
kal_uint32 custom_query_EMI_RMPU_region_info(EMI_MPU_REGION_INFO_T **region)
{
     extern kal_uint32 MD_USED_END$$Limit;

    /*
     * Please align below setting to @aEMI_MPU_config in EMI_MPIinfo.pm
     */
    static EMI_MPU_REGION_INFO_T EMI_MPU_REGION[5] =
    {
        {(kal_uint32)&Image$$ROM_GFH$$Base,              0,  EMI_MPU_MDMCU_RO,   EMI_MPU_MDHW_RO},
        {(kal_uint32)&Image$$MCURO_HWRW$$Base,           0,  EMI_MPU_MDMCU_RO,   EMI_MPU_MDHW_RW},
        {(kal_uint32)&Image$$EXTSRAM$$Base,              0,  EMI_MPU_MDMCU_RW,   EMI_MPU_MDHW_RO},
        {(kal_uint32)&Image$$EXTSRAM_MCURW_HWRW$$Base,   0,  EMI_MPU_MDMCU_RW,   EMI_MPU_MDHW_RW},
        {(kal_uint32)&MD_USED_END$$Limit,                0,  EMI_MPU_INVALIDE,   EMI_MPU_INVALIDE}
    };

    kal_uint32 i=1, num_of_region;

    num_of_region = sizeof(EMI_MPU_REGION)/sizeof(EMI_MPU_REGION_INFO_T);
    
    EMI_MPU_REGION[0].addr = EMI_MPU_REGION[0].addr & 0x0FFFFFFF;

    for(i=1; i<num_of_region; ++i)
    {
        EMI_MPU_REGION[i].addr = EMI_MPU_REGION[i].addr & 0x0FFFFFFF;
        EMI_MPU_REGION[i-1].len = EMI_MPU_REGION[i].addr - EMI_MPU_REGION[i-1].addr;
    }

	*region = EMI_MPU_REGION;

    return (num_of_region-1);
}




/* to be removed */
kal_uint32 custom_get_L2SRAM_L2NC_CODE_base(void)
{
    return 0;
}

/* to be removed */
kal_uint32 custom_get_L2SRAM_L2NC_CODE_load_base(void)
{
    return 0;
}

/* to be removed */
kal_uint32 custom_get_L2SRAM_L2NC_CODE_Length(void)
{
    return 0;
}

/* to be removed */
kal_uint32 custom_get_L2SRAM_L2C_CODE_base(void)
{
    return 0;
}

/* to be removed */
kal_uint32 custom_get_L2SRAM_L2C_CODE_load_base(void)
{
    return 0;
}

/* to be removed */
kal_uint32 custom_get_L2SRAM_L2C_CODE_Length(void)
{
    return 0;
}

/* to be removed */
kal_uint32 custom_get_INTSRAMCODE_Base(void)
{
    return 0;
}

#endif /* __MTK_TARGET__ */
