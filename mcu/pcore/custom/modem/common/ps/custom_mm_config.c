/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*******************************************************************************
 *
 * Filename:
 * ---------
 * custom_mm_config.c
 *
 * Project:
 * --------
 *   MONZA
 *
 * Description:
 * ------------
 *   This file is used to define the MM configuration.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/

#include "kal_general_types.h"
#include "kal_public_defs.h"
#include "custom_mm_config.h"
#include "ps_public_enum.h"
#include "gmss_public.h"

/****************************************************************************
* MTK default value of Timer for Paging Retry is 8sec.
* Use MM_CUSTOM_PAGING_GUARD_TIMER_VALUE to increase or decrease 
* Paging Retry Timer(value in seconds). 
* When MM_CUSTOM_PAGING_GUARD_TIMER_VALUE is 0, MTK shall use default Paging Retry Timer is 8 sec.
* Example: say if Paging Retry Timer needs to be customized to 5 secs then set MM_CUSTOM_PAGING_GUARD_TIMER_VALUE = 5.
****************************************************************************/
const kal_uint32 MM_CUSTOM_PAGING_GUARD_TIMER_VALUE = 0;

/****************************************************************************
* MTK default value of T3311 value is 15 secs as per 3GPP spec. 24.008, sec.11.2.2
* Use MM_CUSTOM_T3311_TIMER_VALUE_ON_RSIM_STACK to increase or decrease 
* T3311 Time period (value in seconds) for ATTACH retry on RSIM stack.
* The range for values of MM_CUSTOM_T3311_TIMER_VALUE_ON_RSIM_STACK are (1-15)
* if the values are out of above range then MTK default value will be used.
* Example: say if T3311 Timer needs to be customized to 5 secs then 
* set MM_CUSTOM_T3311_TIMER_VALUE_ON_RSIM_STACK = 5.
*****************************************************************************/
const kal_uint32 MM_CUSTOM_T3311_TIMER_VALUE_ON_RSIM_STACK = 2;
/****************************************************************************

* MTK default value of T3310 value is 15 secs as per 3GPP spec. 24.008, sec.11.2.2
* Use MM_CUSTOM_T3310_TIMER_VALUE_ON_RSIM_STACK to increase or decrease 
* T3310 Time period (value in seconds) for ATTACH  on RSIM stack.
* When MM_CUSTOM_T3310_TIMER_VALUE_ON_RSIM_STACK is 0, MTK shall use default value for T3310 i.e. 15 secs
* Example: say  T3310 Timer needs to be customized to 5 secs then 
* set MM_CUSTOM_T3310_TIMER_VALUE_ON_RSIM_STACK = 5.
* Note : This functionality is guarded under "SBP_GMM_EMM_T3310_T3410_TIMER_VALUE_ON_RSIM_STACK" .
*****************************************************************************/
const kal_uint32 MM_CUSTOM_T3310_TIMER_VALUE_ON_RSIM_STACK = 30;

/****************************************************************************
* MTK default value of T3311 value is 15 secs as per 3GPP spec. 24.008, sec.11.2.2
* Use MM_CUSTOM_T3311_TIMER_VALUE_ON_AKA_STACK to increase or decrease 
* T3311 Time period (value in seconds) for ATTACH retry on AKA stack (virtual SIM card).
* The range for values of MM_CUSTOM_T3311_TIMER_VALUE_ON_AKA_STACK are (1-15)
* if the values are out of above range then MTK default value will be used.
* Example: say if T3311 Timer needs to be customized to 5 secs then 
* set MM_CUSTOM_T3311_TIMER_VALUE_ON_AKA_STACK = 5.
****************************************************************************/
const kal_uint32 MM_CUSTOM_T3311_TIMER_VALUE_ON_AKA_STACK = 2;

/*************************************************************************
 * This custom array can be used by our customers to enhance lazy mode operation and 
 *  choose a custom IRAT_TAU_TYPE
 * 
 *   Ex: CUSTOM_IRAT_TAU_TYPE_FOR_LAZY_GMM[] = 
 *           {"46697F","46689F",INVALID_CUSTOM_PLMN}         
 *************************************************************************/

const char *CUSTOM_IRAT_TAU_TYPE_FOR_LAZY_GMM[] = {"46697F","42902F","45008F","41004F","63903F","52503F","46060F","52047F","50218F","29701F","52501F","46001F",INVALID_CUSTOM_PLMN};
const kal_uint32 CUSTOM_IRAT_TAU_TYPE_FOR_LAZY_GMM_NUM = sizeof(CUSTOM_IRAT_TAU_TYPE_FOR_LAZY_GMM)/sizeof(char *);

/*************************************************************************
* On IRAT from 2G to 3G or RAT MODE change from 2G to 3G, then RESET GMM CKSN and 
* GMM KEYS so that NW will apply new authentication parameters through 
* GMM AUTHENTICATION and CIPHERING procedure for PLMN mentioned in below 
* PLMN array.
*************************************************************************/
const char *CUSTOM_RESET_GMM_KEYS_LIST[] = {"40410F",INVALID_CUSTOM_PLMN};
const kal_uint32 CUSTOM_RESET_GMM_KEYS_LIST_NUM = sizeof(CUSTOM_RESET_GMM_KEYS_LIST)/sizeof(char *);

/*************************************************************************
*  When LAU has been rejected with cause #12, MM will request AS to add
*  the LA in forbidden LA for Roaming list for PLMN mentioned in below 
*  PLMN array
*************************************************************************/
const char *CUSTOM_MM_STAY_ON_LA_OF_REGIONAL_PROVISIONAL_SERVICE_PLMN_LIST[] = {"732103",INVALID_CUSTOM_PLMN};
const kal_uint32 CUSTOM_MM_STAY_ON_LA_OF_REGIONAL_PROVISIONAL_SERVICE_PLMN_LIST_NUM = sizeof(CUSTOM_MM_STAY_ON_LA_OF_REGIONAL_PROVISIONAL_SERVICE_PLMN_LIST)/sizeof(char *);


/****************************************************************************
*
* Sync RAU procedure will be started when UE is in IDLE mode and earlier RRC CNX on RAT_UMTS
* was aborted forcefully causing the network to still page the UE on PAGE_TYPE-2 thinking RRC_CNX exists.
* Since Network will only maintain its RRC CNX for a brief time, its an optimization from UE to let
* network know about the abrupt RRC CNX release(When peer stack takes RF resources instantly)
* after UE is back to idle
* Sync RAU guard timer will ensure that UE does not perform an RAU procedure
* to sync RNC network states after the specified value.
* Please note that this timer is only effective when RAT_UMTS is MAIN_PS stack (Data Preferred Stack)
* of with an active RRC connection and peer stack interrupts the MAIN_PS (Data Preferred Stack)
* and the RRC connection of Data Preferred Stack is abruptly ended.
*
****************************************************************************/

const kal_uint32 CUSTOM_GMM_SYNC_RAU_GUARD_TIMER_VALUE = 60;


/*****************************************************************************
* FUNCTION
*  mm_custom_stay_on_la_of_regional_provisional_service
* DESCRIPTION
*  This function is for customize MM behavior when entering forbidden LA of #12
*
* PARAMETERS
*
* RETURNS
*  MM_STAY_ON_LA_OF_REGIONAL_PROVISIONAL_SERVICE
*      follow spec (enter limited service and stay on forbidden LA of #12)
*  MM_STAY_ON_LA_OF_REGIONAL_PROVISIONAL_ONLY_IF_TEST_SIM_TEST_MODE
*      follow spec (enter limited service and stay on forbidden LA of #12) 
*      only when test sim is inserted or test mode(CTA/FTA/Operator) is enabled
*  MM_NOT_STAY_ON_LA_OF_REGINOAL_PROVISIONAL_SERVICE
*      allow MS directly retry other PLMN/RAT for normal service
* GLOBALS AFFECTED
*   None
*****************************************************************************/
mm_rej_12_handle_enum mm_custom_stay_on_la_of_regional_provisional_service(protocol_id_enum ps_id)
{
    //suggest to use default setting [MM_STAY_ON_LA_OF_REGIONAL_PROVISIONAL_SERVICE]
    //change this setting might affect the result of FTA or IOT.
    //may only be changed on production version of software after pass all lab test
    if (sbp_query_md_feature_by_ps(SBP_MM_NOT_STAY_ON_FBLA_FOR_REG_PROV,ps_id) == KAL_TRUE)
    {
        return MM_STAY_ON_LA_OF_REGIONAL_PROVISIONAL_ONLY_IF_TEST_SIM_TEST_MODE;
    }
    else
    {
        return MM_STAY_ON_LA_OF_REGIONAL_PROVISIONAL_SERVICE;
    }
}

/*****************************************************************************
* FUNCTION
* mm_custom_get_T3240_timer_value_for_specific_plmn
*
* DESCRIPTION
*  This function is to get different T3240 timer value for specific plmns.
*  MTK default value of T3240 timer is 10sec.
*  Use mm_custom_get_T3240_timer_value_for_specific_plmn to increase or decrease
*  T3240 timer value for specific plmn.
*  Example : say, if T3240 timer value is to be customize for CMCC (46000f) operator
*  to be 12 sec. then compare with oplmn variable and return corresponding value 
*  which is defined below code.
*  This feature is guarded with SBP SBP_MM_CUSTOMIZE_T3240_TIMEOUT_VALUE.
*  SBP SBP_MM_CUSTOMIZE_T3240_TIMEOUT_VALUE is by default OFF.
*  To use this feature, Turn ON SBP SBP_MM_CUSTOMIZE_T3240_TIMEOUT_VALUE.
* PARAMETERS
* oplmn : operator plmn
* RETURNS
*  kal_unit32
* GLOBALS AFFECTED
*   
*****************************************************************************/

kal_uint32 mm_custom_get_T3240_timer_value_for_specific_plmn(kal_uint8 *oplmn)
{  
    //CMCC  
   if(kal_mem_cmp(oplmn,"46000F",6)  == 0)
   {
      return 12; 
   }
   /* Want to set different T3240 value for other operator like CU(46001F), use similar logic as defined below example.
   else if(kal_mem_cmp(oplmn,"40001F",6)  == 0)
   {
      return 15;
   } */
   else
   {
  	  return 10;
   }
}

/*****************************************************************************
* FUNCTION
*  mm_custom_registration_related_setting
* DESCRIPTION
*  This function is used to query registration related setting.
*
* PARAMETERS
*  Which setting
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool mm_custom_registration_related_setting(mm_setting_enum setting)
{

  switch(setting)
  { 
   
   case MM_ENABLE_LR_REJ111_RETRY:
      {
#ifndef __DISABLE_LR_REJ111_RETRY__   
			  return KAL_TRUE;
#else
			  return KAL_FALSE;
#endif
        break;
      } 
   case MM_ENABLE_HPPLMN_SEARCH_FORCE_RELEASE_PCH_CONNECTION:
	  {	 
#ifndef __DISABLE_HPPLMN_SEARCH_FORCE_RELEASE_PCH_CONNECTION__
			  return KAL_TRUE;
#else
			  return KAL_FALSE;
#endif  
		break;
	  } 
 
   default:
   		break;
  }
  
  return KAL_FALSE;
} 

/* MAUI_03014009 Russia Operator BeeLine request to use ECC with IMEI */
/*****************************************************************************
* FUNCTION
*  mm_custom_force_ecc_with_imei
* DESCRIPTION
*  This function configures emergency call force to use IMEI during phone lock period.
*  default: KAL_FALSE (using TMSI->IMSI->IMEI)
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool mm_custom_force_ecc_with_imei(void)
{
    return KAL_FALSE;
}

/* ALPS01451877 UK should be allowed to make emergency calls with expired SIM cards */
const kal_uint32 ECC_IMSI_MCC_LIST[] = {234, 235};
const kal_uint32 ECC_IMSI_MCC_NUM = sizeof(ECC_IMSI_MCC_LIST)/sizeof(kal_uint32);

/**********************************************************************************************************
 * On IRAT from 4G to 3G, In cases where RAU procedure is not complete or un-successful with NW and
 * followed by UE moves back to 4G as part of network recovery search, EMM shall use TAU type as Combined 
 * TA/LA updating with IMSI attach for the PLMN mentioned in the below custom array.  
 * 
 *   Ex: CUSTOM_PLMN_IRAT_TAU_TYPE[] = 
 *           {"46001F",INVALID_CUSTOM_PLMN}         
 **********************************************************************************************************/

const char *CUSTOM_PLMN_IRAT_TAU_TYPE[] = {"46001F",INVALID_CUSTOM_PLMN};

const kal_uint32 CUSTOM_PLMN_IRAT_TAU_TYPE_NUM = sizeof(CUSTOM_PLMN_IRAT_TAU_TYPE)/sizeof(char *);

/**********************************************************************************************************
 * As per Spec 24.008 Rel-13,The MS shall include old lai during combined attach/RAU procedure if MS hold
 * valid LAI & support EMM combined procedure. This implementation is controlled via the custom array.
 * UE can send old lai only  for the PLMN mentioned in the below custom array.  
 * 
 *   Ex: CUSTOM_PLMN_OLD_LAI_LIST[] = 
 *           {"46001F",INVALID_CUST_PLMN}         
 **********************************************************************************************************/

const char *CUSTOM_PLMN_OLD_LAI_LIST[] = {INVALID_CUST_PLMN};
const kal_uint32 CUSTOM_PLMN_OLD_LAI_LIST_NUM = sizeof(CUSTOM_PLMN_OLD_LAI_LIST)/sizeof(char *);

/**********************************************************************************************************
 *  When CM_SERVICE_REQUEST for SMS in MM_WAIT_FOR_ADDITIONAL_OUTGOING_MM_CONN state has been rejected with
 *  cause IMSI_UNKNOWN_IN_VLR then convert the cause #4 to #17 (NETWORK FAILURE) so that other established 
 *  MM connection should not be impacted.
 **********************************************************************************************************/

const char *CUSTOM_CM_SERV_REJ_CAUSE_CONVERT_TO_17_FOR_ADDIT_OUTGOING_MM_CONN_LIST[] = {"41409F", INVALID_CUST_PLMN};
const kal_uint32 CUSTOM_CM_SERV_REJ_CAUSE_CONVERT_TO_17_FOR_ADDIT_OUTGOING_MM_CONN_LIST_NUM = 
	          sizeof(CUSTOM_CM_SERV_REJ_CAUSE_CONVERT_TO_17_FOR_ADDIT_OUTGOING_MM_CONN_LIST)/sizeof(char *);

/**************************************************************************************************************
 *  When previous registered RAT was 4G and current RAT MODE setting supports 3G, then GMM ATTACH REQUEST
 *  will be triggered with IMSI as MS identity.
 ***************************************************************************************************************/

const char *CUSTOM_TRIGGER_ATTACH_WITH_IMSI_LIST[] = {"25506F", INVALID_CUST_PLMN};
const kal_uint32 CUSTOM_TRIGGER_ATTACH_WITH_IMSI_LIST_NUM = 
	                    sizeof(CUSTOM_TRIGGER_ATTACH_WITH_IMSI_LIST)/sizeof(char *);


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif 
/*****************************************************************************
* FUNCTION
*  mm_custom_start_timer_for_mt_mm_conn
* DESCRIPTION
*  This function is used to configure whether start T3240 for page.
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool mm_custom_start_timer_for_mt_mm_conn(void)
{
    /*work around CMCC 3G network issue
    1. PS signaling exist, receive page for CS domain
    2. send page response, enter MM_WAIT_FOR_NETWORK_COMMAND
    3. handover to another LA, then no MM or CM message from network
    4. can not process CM request until cs signaling or RRC release
    */
    return KAL_TRUE;
}

/*For Customer Default test plmn. Follows TS34.123 Table 6.2  */
const char *CUSTOM_TEST_PLMN[] = 
    {"00101", "00211", "00321", "00431", "00541", "00651",
     "00761", "00871", "00902", "01012", "01122", "01232" , CUSTOM_TEST_PLMN_SET_END};

const kal_uint32 CUSTOM_TEST_PLMN_NUM = sizeof(CUSTOM_TEST_PLMN)/sizeof(char *);

/*****************************************************************************
* FUNCTION
*  mm_custom_get_erase_forbidden_la_list_timer_period
* DESCRIPTION
*  This function is used to get ERASE_FORBIDDEN_LA_LIST timer period.
*
* PARAMETERS
*  None
*
* RETURNS
*  kal_uint32
*
* GLOBALS AFFECTED
*  None
*
*****************************************************************************/
kal_uint32 mm_custom_get_erase_forbidden_la_list_timer_period(void)
{
    // TS24.008 specifies this timer should be 12~24hr.
    // Default 12hr.
    // Set 0 to disable this timer
    #ifdef __HAPS_FPGA_CLK_ADJUST__   //fix build warning "integer overflow in expression [-Woverflow]"
    return 0;
    #else
    return 12*60*KAL_TICKS_1_MIN;
    #endif
}

/*************************************************************************
 * In Japan, UE can not perform MO emergency call if UE has not completed registration procedure 
 * (so, MSC does not know MSISDN of mobile originating user), because transferring MSISDN of
 * mobile originating user to emergency authority is mandatory
 *
 * Example:
 * 1.
 * const kal_uint32 LR_BEFORE_ECC_MCC_LIST[] = {440}; // Only in Japan does UE need perform LR before ECC
 * 2.
 * const kal_uint32 LR_BEFORE_ECC_MCC_LIST[] = {NO_MCC_ALLOWED}; // UE shall perform ECC before LR regardless of MCC
 * 3.
 * const kal_uint32 LR_BEFORE_ECC_MCC_LIST[] = {ALL_MCC_ALLOWED}; // UE shall perform LR before ECC regardless of MCC
 *
 *************************************************************************/
#if defined(__MM_PERFORM_LU_BEFORE_ECC__)
const kal_uint32 LR_BEFORE_ECC_MCC_LIST[] = {ALL_MCC_ALLOWED};
#elif defined(__DOCOMO_IOT_LR_BEFORE_ECC__)
const kal_uint32 LR_BEFORE_ECC_MCC_LIST[] = {440};
#else
const kal_uint32 LR_BEFORE_ECC_MCC_LIST[] = {NO_MCC_ALLOWED};
#endif
const kal_uint32 LR_BEFORE_ECC_MCC_NUM = sizeof(LR_BEFORE_ECC_MCC_LIST)/sizeof(kal_uint32);

#ifndef __MM_DISABLE_PERFORM_LU_BEFORE_CSFB_ECC__
const char *LR_BEFORE_CSFB_ECC_PLMN_LIST[] = {"23420" ,"23594" , LR_BEFORE_CSFB_ECC_PLMN_SET_END};
#else
const char *LR_BEFORE_CSFB_ECC_PLMN_LIST[] = {LR_BEFORE_CSFB_ECC_PLMN_SET_END};
#endif
const kal_uint32 LR_BEFORE_CSFB_ECC_PLMN_NUM = sizeof(LR_BEFORE_CSFB_ECC_PLMN_LIST)/sizeof(char *);

/*****************************************************************************
* FUNCTION
*  mm_custom_enable_early_oos_ind
* DESCRIPTION
*  If enabled, AP will display OOS when lost coverage and AS start cell reselection
*  If disabled, AP will display OOS after lost coverage and cell reselection failure
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool mm_custom_enable_early_oos_ind(protocol_id_enum ps_id)
{
    return sbp_query_md_feature_by_ps(SBP_OOS_EARLY_IND,ps_id);
}


/*****************************************************************************
* FUNCTION
*  mm_custom_reattach_for_mt_gprs_detach_other_cause
*
* DESCRIPTION
*  If the UE receives network initiated GPRS detach request of type "re-attach not required",
*  and the reject cause is not defined in SPEC (not one of #2/#3/#6/#7/#8/#11/#12/#13/#14/#15/#25),
*  according to the SPEC, further actions of MS are implementation dependent.
*
* PARAMETERS
*
* RETURNS
*   KAL_TRUE:
*    - The UE will re-attach immediatedly after performing GPRS detach 
*   KAL_FALSE:
*    - The UE will not re-attach immediately after performing GPRS detach
*    - The UE will re-attach when user starts a new data transmission
*
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool mm_custom_reattach_for_mt_gprs_detach_other_cause(protocol_id_enum ps_id)
{
    if (sbp_query_md_feature_by_ps(SBP_GMM_REATTACH_FOR_NW_DETACH_OTHER_CAUSE,ps_id) == KAL_TRUE)
    {
        return KAL_TRUE;
    }	
    else
    {
        return KAL_FALSE;
    }
}

/*****************************************************************************
* FUNCTION
*  mm_custom_imsi_detach_when_mm_conn_active
* DESCRIPTION
*  If enabled, AP will display OOS when lost coverage and AS start cell reselection
*  If disabled, AP will display OOS after lost coverage and cell reselection failure
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool mm_custom_imsi_detach_when_mm_conn_active(protocol_id_enum ps_id)
{
    if (sbp_query_md_feature_by_ps(SBP_MM_IMSI_DETACH_WHEN_MM_CONN_ACTIVE,ps_id) == KAL_TRUE)
    {
        return KAL_TRUE;
    }    
    else
    {
        return KAL_FALSE;
    }
}

/*****************************************************************************
* FUNCTION
*  mm_custom_enable_dynamic_set_modem2_imei
* DESCRIPTION
*  CMCC requires: Two Modems of TDD GEMINI UE shall use the same IMEI in CMCC Network.
*  And by FT experience, Core Network may reject UE if two modems use the same IMEi.
*  The feature implement: 
*      In China network, two modems use the same IMEI.
*      In other network, two modems use different IMEI.
*
* PARAMETERS
*    sim_index    current sim index
* RETURNS
*  KAL_TRUE: The feature is enabled.
    KAL_FALSE: The feature is disabled. In all networks, two modems use the SAME IMEI.
*  None
*****************************************************************************/
kal_bool mm_custom_enable_dynamic_set_modem2_imei(kal_uint8 sim_index)
{
    #ifdef __TDD_2G_OP01__
    kal_bool tdd_2g_op01 = KAL_TRUE;
    #else
    kal_bool tdd_2g_op01 = KAL_FALSE;
    #endif
    
    if(tdd_2g_op01 == KAL_TRUE || gmss_is_tdscdma_mode_activated(sim_index) == KAL_TRUE)
    {
        return KAL_TRUE;
    }
    else
    {
        return KAL_FALSE;
    }
}

/*****************************************************************************
* FUNCTION
*  mm_custom_report_reg_when_csfb_ecc_lu_needed
* DESCRIPTION
*  For 4G23 CSFB ECC and LU needed, UE may delay LU until ECC end.
*  During ECC, no registration result will report to AP due to LU is pending.
*  AP will keep displaying 4G icon.
*  To solve this problem, we provide this function for RAT icon display when registration status is unknown.
* PARAMETERS
*   current_plmn_type  PLMN type of current camp on cell.
* RETURNS
*   KAL_TRUE:  Display registered on 2/3G.
*   KAL_FALSE: Display network lost.
*  None
*****************************************************************************/
kal_bool mm_custom_report_reg_when_csfb_ecc_lu_delayed(mm_custom_plmn_type current_plmn_type)
{
    switch (current_plmn_type)
    {
        case MM_CUSTOM_HPLMN:
        case MM_CUSTOM_R_E_PLMN:
            return KAL_TRUE;
        case MM_CUSTOM_UNKNOWN_PLMN_TYPE:
        default:
            return KAL_FALSE;
    }
}
/*****************************************************************************
* Set FOR bit in GMM ATTACH Request false when PLMN is in CUSTOM list
*
*   - If PLMN is listed in the array, then UE shall Reset FOR bit in GMM ATTACH Request
*      
*
*****************************************************************************/
const char *SET_FOR_BIT_FALSE_IN_ATTACH_FOR_CUSTOM_PLMN[] = {"40411F", SET_FOR_BIT_FALSE_IN_ATTACH_FOR_CUSTOM_PLMN_END};
const kal_uint32 SET_FOR_BIT_FALSE_IN_ATTACH_FOR_CUSTOM_PLMN_NUM = sizeof(SET_FOR_BIT_FALSE_IN_ATTACH_FOR_CUSTOM_PLMN)/sizeof(char *);

/*****************************************************************************
* When RAU is performed with FOR bit set as FALSE, After RAU procedure is successful, perform PDP 
* activation over the new Connection when PLMN is in CUSTOM list
*
*   - If PLMN is listed in the array, then UE shall shall trigger PDP ACTIVATION over new connection
*   - This customization is not applicable on test sim and FTA mode.  
*
*****************************************************************************/
const char *ALLOW_PDP_ACTIVATION_OVER_NEW_CONNECTION_WHEN_RAU_FOR_FALSE_FOR_CUSTOM_PLMN[] = {INVALID_CUST_PLMN};
const kal_uint32 ALLOW_PDP_ACTIVATION_OVER_NEW_CONNECTION_WHEN_RAU_FOR_FALSE_FOR_CUSTOM_PLMN_NUM =
	         sizeof(ALLOW_PDP_ACTIVATION_OVER_NEW_CONNECTION_WHEN_RAU_FOR_FALSE_FOR_CUSTOM_PLMN)/sizeof(char *);


/*************************************************************************
 * Ignore Reject cause 7, GPRS serive not allowed, in ATTACH REJECT or 
 * in ROUTING AREA UPDATING REJECT message when roaming. Reject Cause 
 * 14, GPRS serive not allowed in this PLMN, insteads of.
 * 
 * - IGNORE_GPRS_SERVICE_NOT_ALLOWED_WHEN_ROAMING_OPERATOR
 *     - If PLMN is defined in the list, UE take action as receiving reject
 *        cause 14 when UE receive ATTACH REJECT or ROUTING AREA UPDATING
 *        REJECT message with cause 7 and roaming.
 * 
 *************************************************************************/
#ifdef __GMM_CELCOM_IGNORE_GPRS_SERVICE_NOT_ALLOWED_WHEN_ROAMING__
const char *IGNORE_GPRS_SERVICE_NOT_ALLOWED_WHEN_ROAMING_OPERATOR[] = {"50219F", IGNORE_GPRS_SERVICE_NOT_ALLOWED_WHEN_ROAMING_OPERATOR_SET_END};
#else
const char *IGNORE_GPRS_SERVICE_NOT_ALLOWED_WHEN_ROAMING_OPERATOR[] = {IGNORE_GPRS_SERVICE_NOT_ALLOWED_WHEN_ROAMING_OPERATOR_SET_END};
#endif

const kal_uint32 IGNORE_GPRS_SERVICE_NOT_ALLOWED_WHEN_ROAMING_OPERATOR_NUM = sizeof(IGNORE_GPRS_SERVICE_NOT_ALLOWED_WHEN_ROAMING_OPERATOR)/sizeof(char *);


/*************************************************************************
 * Convert Attach  Reject cause #14, GPRS serive not allowed in PLMN in 
 * ATTACH REJECT or to cause #111,Protocol error
 *
 ************************************************************************/
const char *CONVERT_GPRS_NOT_ALLOWED_IN_PLMN_TO_PROTOCOL_ERROR[] = {"46000F", "46001F", CONVERT_GPRS_NOT_ALLOWED_IN_PLMN_TO_PROTOCOL_ERROR_SET_END};
const kal_uint32 CONVERT_GPRS_NOT_ALLOWED_IN_PLMN_TO_PROTOCOL_ERROR_NUM = sizeof(CONVERT_GPRS_NOT_ALLOWED_IN_PLMN_TO_PROTOCOL_ERROR)/sizeof(char *);

/*************************************************************************
 * Convert RAU  Reject cause #7, GPRS serive not allowed  in 
 * RAU REJECT  to cause #111,Protocol error
 * Customer needs to add PLMN values to the below array .Ex : { "46001F",CONVERT_GPRS_NOT_ALLOWED_TO_PROTOCOL_ERROR_SET_END};
 ************************************************************************/
const char *CONVERT_GPRS_NOT_ALLOWED_TO_PROTOCOL_ERROR[] = {CONVERT_GPRS_NOT_ALLOWED_TO_PROTOCOL_ERROR_SET_END};
const kal_uint32 CONVERT_GPRS_NOT_ALLOWED_TO_PROTOCOL_ERROR_NUM = sizeof(CONVERT_GPRS_NOT_ALLOWED_TO_PROTOCOL_ERROR)/sizeof(char *);

/*************************************************************************
 * Some operators cannot decode IEs for SRVCC correctly brought in attach/RAU request
 * (i.e. MS Classmark2/MS Classmark3/Supported Codecs)
 *
 * - DISABLE_SRVCC_IE_PLMN
 *   - Do not bring new IEs for SRVCC in Attach/RAU request while trying registration on PLMNs specified in this array
 * 
 *************************************************************************/
const char *DISABLE_SRVCC_IE_PLMN[] = {"40468F", DISABLE_SRVCC_IE_PLMN_SET_END};
const kal_uint32 DISABLE_SRVCC_IE_PLMN_NUM = sizeof(DISABLE_SRVCC_IE_PLMN)/sizeof(char *);

/*****************************************************************************
* FUNCTION
*  mm_custom_get_t3x11_period
* DESCRIPTION
*  This function is used to get t3x11 timer period for enhance SoR, only rejected by network failure start t3211 would call this function
*  Not applicable for GCF test
* PARAMETERS
*  None
*
* RETURNS
*  kal_uint32
*
* GLOBALS AFFECTED
*  None
*
*****************************************************************************/
kal_uint32 mm_custom_get_t3x11_period(protocol_id_enum ps_id)
{
    if (sbp_query_md_feature_by_ps(SBP_ENHANCED_SOR,ps_id) == KAL_TRUE)
    {
        return (5  * KAL_TICKS_1_SEC );
    }

    return (15  * KAL_TICKS_1_SEC );
}

/*****************************************************************************
* FUNCTION
*  mm_custom_get_paging_guard_timer_period
* DESCRIPTION
*  This function is to get paging guard timer value provided by customer to trigger the
*  MM paging respone retry mechanism.
* PARAMETERS
*  None
*
* RETURNS
*  kal_uint32
*
* GLOBALS AFFECTED
*  None
*
*****************************************************************************/
kal_uint32 mm_custom_get_paging_guard_timer_period(void)
{
    return MM_CUSTOM_PAGING_GUARD_TIMER_VALUE;
}

/*****************************************************************************
* FUNCTION
*  mm_custom_get_T3311_timer_period_on_rsim_stack
* DESCRIPTION
*  MM will use this function to get T3311 value for ATTACH request retry
*  on RSIM stack if SBP_MM_CUSTOMIZE_T3311_TIMEOUT_VALUE_FOR_RSIM is enabled.
* PARAMETERS
*  protocol_id_enum protocol stack 
*
* RETURNS
*  kal_uint32
*
* GLOBALS AFFECTED
*  None
*
*****************************************************************************/
kal_uint32 mm_custom_get_T3311_timer_period_on_rsim_stack(protocol_id_enum ps_id)
{
	if (sbp_query_md_feature_by_ps(SBP_MM_CUSTOMIZE_T3311_TIMEOUT_VALUE_FOR_RSIM, ps_id) == KAL_TRUE)
	{
		return MM_CUSTOM_T3311_TIMER_VALUE_ON_RSIM_STACK;
	}
	else
	{
        return 15;
	}
}

/*****************************************************************************
* FUNCTION
*  mm_custom_get_T3311_timer_period_on_aka_stack
* DESCRIPTION
*  MM will use this function to get T3311 value for ATTACH request retry
*  on AKA stack for virtual SIM card if SBP_MM_CUSTOMIZE_T3311_TIMEOUT_VALUE_FOR_RSIM is enabled.
* PARAMETERS
*  protocol_id_enum protocol stack 
*
* RETURNS
*  kal_uint32
*
* GLOBALS AFFECTED
*  None
*
*****************************************************************************/
kal_uint32 mm_custom_get_T3311_timer_period_on_aka_stack(protocol_id_enum ps_id)
{
    if (sbp_query_md_feature_by_ps(SBP_MM_CUSTOMIZE_T3311_TIMEOUT_VALUE_FOR_RSIM, ps_id) == KAL_TRUE)
	{
		return MM_CUSTOM_T3311_TIMER_VALUE_ON_AKA_STACK;
	}
    else
	{
        return 15;
	}
}

/*****************************************************************************
* In some network, the CSMT flag cannot be set in paging response during MT CSFB calls.
* 
* - DISABLE_PAGING_CSMT_FLAG_PLMN_END
*   - If PLMN is listed in the array, the CSMT flag shall never be set
*
*****************************************************************************/
const char *DISABLE_PAGING_CSMT_FLAG_PLMN[] = {"40410", "22201", "46601", "23415", "23410", "51011", "45406", "21401", "46001", "310260", "50501", "20801", DISABLE_PAGING_CSMT_FLAG_PLMN_END};
const kal_uint32 DISABLE_PAGING_CSMT_FLAG_PLMN_NUM = sizeof(DISABLE_PAGING_CSMT_FLAG_PLMN)/sizeof(char *);

const char *CUSTOM_CAUSE_PLMN[] = {CUSTOM_CAUSE_PLMN_SET_ANY};

const kal_uint32 CUSTOM_CAUSE_PLMN_NUM = sizeof(CUSTOM_CAUSE_PLMN)/sizeof(char *);

/*****************************************************************************
* Enable CSMT flag in paging response
* 
* - DISABLE_PAGING_CSMT_FLAG_PLMN_END
*   - If PLMN is listed in the array, the CSMT flag shall never be set
*
*****************************************************************************/
const char *ENABLE_PAGING_CSMT_FLAG_PLMN[] = {"310410", "46000", ENABLE_PAGING_CSMT_FLAG_PLMN_END};
const kal_uint32 ENABLE_PAGING_CSMT_FLAG_PLMN_NUM = sizeof(ENABLE_PAGING_CSMT_FLAG_PLMN)/sizeof(char *);

/*****************************************************************************
* Trigger detach when user set rat G->L
*
*   - If PLMN is listed in the array, then UE will trigger detach when user set rat from G to L
*
*****************************************************************************/
const char *CONFIGURE_USER_SET_RAT_DETACH_G2L_PLMN[] = {"26003F", CONFIGURE_USER_SET_RAT_DETACH_G2L_PLMN_END};
const kal_uint32 CONFIGURE_USER_SET_RAT_DETACH_G2L_PLMN_NUM = sizeof(CONFIGURE_USER_SET_RAT_DETACH_G2L_PLMN)/sizeof(char *);

/*****************************************************************************
* Enable SKIP_LU_AFTER_CSFB_FOR_EAFR Feature
*
*   - If PLMN is listed in the array, then behave as SKIP_LU_AFTER_CSFB_FOR_EAFR Enabled
*
*****************************************************************************/
const char *CONFIGURE_SKIP_LU_AFTER_CSFB_FOR_EAFR_PLMN[] = {"25002F","71006F","71010F","71017F","722310","40492F","40410F","40505F", CONFIGURE_SKIP_LU_AFTER_CSFB_FOR_EAFR_PLMN_END};
const kal_uint32 CONFIGURE_SKIP_LU_AFTER_CSFB_FOR_EAFR_PLMN_NUM = sizeof(CONFIGURE_SKIP_LU_AFTER_CSFB_FOR_EAFR_PLMN)/sizeof(char *);

/*****************************************************************************
* Disable DoS Feature
*
*   - If PLMN is listed in the array,DoS feature will be disabled when device camps on this PLMN.
*   - For more details of DoS feature visit 24.008 4.1.1.6A and 24.301 5.3.7b
*****************************************************************************/
const char *PLMN_LIST_TO_DISABLE_DOS[] = {"46000F", PLMN_LIST_TO_DISABLE_DOS_END};
const kal_uint32 PLMN_LIST_TO_DISABLE_DOS_NUM = sizeof(PLMN_LIST_TO_DISABLE_DOS)/sizeof(char *);

/**********************************************************************************
* Trigger detach when user set rat G->W
*
*   - If PLMN is listed in the array, then UE will trigger detach when user set rat from G to W
*
*****************************************************************************/
const char *CONFIGURE_USER_SET_RAT_DETACH_G2W_PLMN[] = {"40403F", CONFIGURE_USER_SET_RAT_DETACH_G2W_PLMN_END};
const kal_uint32 CONFIGURE_USER_SET_RAT_DETACH_G2W_PLMN_NUM = sizeof(CONFIGURE_USER_SET_RAT_DETACH_G2W_PLMN)/sizeof(char *);

/*****************************************************************************
* Set FOR bit in GMM ATTACH or RAU when data is enabled and PDP Activation procedure will follow subequently.
*
*   - If PLMN is listed in the array, then UE shall set FOR bit in GMM ATTACH or RAU 
*      when data is enabled and PDP Activation procedure will follow subequently.
*
*****************************************************************************/
const char *SET_FOR_BIT_IN_ATTACH_RAU_WHEN_DATA_ENABLED_PLMN[] = {SET_FOR_BIT_IN_ATTACH_RAU_WHEN_DATA_ENABLED_PLMN_END};
const kal_uint32 SET_FOR_BIT_IN_ATTACH_RAU_WHEN_DATA_ENABLED_PLMN_NUM = sizeof(SET_FOR_BIT_IN_ATTACH_RAU_WHEN_DATA_ENABLED_PLMN)/sizeof(char *);

/*******************************************************************************************
* Convert VPLMN PS Reject cause # 7 to cause # 15 to retry PS registration again on same VPLMN, another LA/RAT
*
*   - If VPLMN is listed in the array, then convert PS reject cause # 7 to cause # 15
*
********************************************************************************************/
const char *CUSTOM_VPLMN_PS_REJ_CAUSE_7TO15_PLMN[] = {"40471F", CUSTOM_VPLMN_PS_REJ_CAUSE_7TO15_PLMN_END};
const kal_uint32 CUSTOM_VPLMN_PS_REJ_CAUSE_7TO15_PLMN_NUM = sizeof(CUSTOM_VPLMN_PS_REJ_CAUSE_7TO15_PLMN)/sizeof(char *);

/*****************************************************************************
* Retry ECC call after CM_SERVICE_REJECT received for ECC call.
*
*   - If PLMN is listed in the array, then UE shall retry ECC call after CM_SERVICE_REJECT received for ECC call.
*
*****************************************************************************/
const char *CUSTOM_RETRY_ECC_CALL_AFTER_CM_SERV_REJ_IN23G_PLMN[] = {"40411F",CUSTOM_RETRY_ECC_CALL_AFTER_CM_SERV_REJ_IN23G_PLMN_END};
const kal_uint32 CUSTOM_RETRY_ECC_CALL_AFTER_CM_SERV_REJ_IN23G_PLMN_NUM = sizeof(CUSTOM_RETRY_ECC_CALL_AFTER_CM_SERV_REJ_IN23G_PLMN)/sizeof(char *);

/*****************************************************************************
* FUNCTION
*  mm_custom_get_cause_converter
* DESCRIPTION
*  This function is used to get customizable reject cause mapping.
*  CUSTOM_CAUSE_PLMN might restrict applying network
* CUSTOM_CAUSE_PLMN_SET_ANY : all network
* "00101f" : only applying on 00101 reject cause
*
* PARAMETERS
*  None
*
* RETURNS
*  kal_uint32
*
* GLOBALS AFFECTED
*  None
*
*****************************************************************************/
kal_uint8 mm_custom_get_customize_cause(protocol_id_enum ps_id,kal_uint8 cause, mm_custom_proc_type proc, kal_bool is_on_hplmn, kal_bool is_test, kal_bool convert_vplmn_ps_cause7to15 ,kal_bool is_aka_sim)
{
    if (is_on_hplmn || is_test)
    {
       if ((is_aka_sim == KAL_TRUE) && (is_on_hplmn) && (cause == 0x7) && (proc == MM_CUSTOM_GMM))
       {

	       if(sbp_query_md_feature_by_ps(SBP_CONVERT_REJ_CAUSE7_TO_14_ON_HPLMN_FOR_AKASIM,ps_id) == KAL_TRUE)
	       {
	       	    return 0xe; /*GPRS_NOT_ALLOWED_IN_PLMN */
	       }
           else
           {
               /* MTK Default behavior is to return the same cause (i.e. 0x7) for HPLMN if SBP is not enable & current stack is AKA. 
                              Customer could change to any other reject cause based on the need basis at their own risk.
                               Ex. If customer likes to convert from cause #7 to #14. please change the value to 0x0e */
                return cause;  
           }
       }
       	
        return cause;
    }
    
    if (proc == MM_CUSTOM_MM)
    {
        switch (cause)
        {
            case 0x02:/* IMSI_UNKNOWN_IN_HLR */
            case 0x03:/* ILLEGAL_MS */
            case 0x06:/* ILLEGAL_ME */
                if (sbp_query_md_feature_by_ps(SBP_ENHANCED_SOR,ps_id) == KAL_TRUE)
                {
                    return 0xd; /* ROAMING_AREA_NOT_ALLOWED */
                }
                break;
            case 0x0d: /* ROAMING_AREA_NOT_ALLOWED */
                if (sbp_query_md_feature_by_ps(SBP_ROAMING_NOT_ALLOW_AS_NO_SUITABLE,ps_id) == KAL_TRUE)
                {
                    return 0xf; /* NO_SUITABLE_CELLS_IN_LA */
                }
        default:
            break;
        }
    }

    if (proc == MM_CUSTOM_GMM)
    {
        switch (cause)
        {            
            case 0x03:/* ILLEGAL_MS */
            case 0x06:/* ILLEGAL_ME */
            case 0x07:/* GPRS_NOT_ALLOWED */
            case 0x08:/* GPRS_NON_GPRS_NOT_ALLOWED */
                if (sbp_query_md_feature_by_ps(SBP_ENHANCED_SOR,ps_id) == KAL_TRUE)
                {
                    return 0xd; /* ROAMING_AREA_NOT_ALLOWED */
                }
				/* GPRS_NOT_ALLOWED on VPLMN*/
				else if(cause == 0x07 && convert_vplmn_ps_cause7to15 == KAL_TRUE) 
				{
					/*VPLMN returned GPRS_NOT_ALLOWED. Convert to NO_SUITABLE_CELLS_IN_LA 
					 *so that PS Attach retried in other LA/other RAT on same VPLMN
					 */
					return 0xf; /* NO_SUITABLE_CELLS_IN_LA */
				}
                break;
            case 0x0d: /* ROAMING_AREA_NOT_ALLOWED */
                if (sbp_query_md_feature_by_ps(SBP_ROAMING_NOT_ALLOW_AS_NO_SUITABLE,ps_id) == KAL_TRUE)
                {
                    return 0xf; /* NO_SUITABLE_CELLS_IN_LA */
                }
            default:
            break;
        }
    }
    return cause;
}

#ifdef __TC7__CS__SUPPORT__

/*****************************************************************************

* FUNCTION

*  mm_custom_fake_lu_needed

* DESCRIPTION

*  IronMan requirement

*

* PARAMETERS

*

* RETURNS

*  KAL_TRUE: The feature is enabled.

    KAL_FALSE: The feature is disabled.

*  None

*****************************************************************************/

kal_bool mm_custom_fake_lu_needed(void)

{

#if defined(__TC7_CS_OPT1__)

    return KAL_TRUE;

#else

    return KAL_FALSE;

#endif

}

#endif

/*****************************************************************************
* FUNCTION
*  mm_custom_get_sync_rau_guard_timer_period
* DESCRIPTION
* Sync RAU procedure will be started when UE is in IDLE mode and earlier RRC CNX on RAT_UMTS
* was aborted forcefully causing the network to still page the UE on PAGE_TYPE-2 thinking RRC_CNX exists.
* Since Network will only maintain its RRC CNX for a brief time, its an optimization from UE to let
* network know about the abrupt RRC CNX release(When peer stack takes RF resources instantly)
* after UE is back to idle
* Sync RAU guard timer will ensure that UE does not perform an RAU procedure
* to sync RNC network states after the specified value.
* Please note that this timer is only effective when RAT_UMTS is data preferred stack
* and Peer stack is attached to LTE.
*
* PARAMETERS
*   NONE
*
* RETURNS
*   Seconds
*
* GLOBALS AFFECTED
*   None
*****************************************************************************/
kal_uint32 mm_custom_get_sync_rau_guard_timer_period()
{
    return (CUSTOM_GMM_SYNC_RAU_GUARD_TIMER_VALUE);
}

/*****************************************************************************
* FUNCTION
*  mm_custom_is_ecc_retry_after_cm_serv_rej_in_23g
*  DESCRIPTION
*  Customer can utilize this function to turn ON/OFF this feauture depend on the 
*  current camped PLMN is HPLMN or VPLMN.
* PARAMETERS
*   is_on_hplmn: current camped PLMN is hplmn or not
*   protocol_id: SIM id.
* RETURNS
*   kal_bool : ECC call retried enabled or disabled
*
* GLOBALS AFFECTED
*   None
*****************************************************************************/
kal_bool mm_custom_is_ecc_retry_after_cm_serv_rej_in_23g(kal_bool is_on_hplmn,protocol_id_enum protocol_id)
{
    kal_bool ret_val = KAL_TRUE;
    /*Below code added for expample customer can use given arguments to customize as per requirement*/
  
    if(KAL_TRUE == is_on_hplmn )
    {
        //ret_val = KAL_FALSE;
    }
    
	return ret_val;
}

/*****************************************************************************
* FUNCTION
*  mm_custom_get_T3310_timer_period_on_rsim_stack
* DESCRIPTION
*  MM will use this function to get T3310 value for ATTACH request on RSIM stack when 
*  the "SBP_GMM_EMM_T3310_T3410_TIMER_VALUE_ON_RSIM_STACK" is enabled.
* PARAMETERS
*  protocol_id_enum protocol stack 
*
* RETURNS
*  kal_uint32
*
* GLOBALS AFFECTED
*  None
*
*****************************************************************************/
kal_uint32 mm_custom_get_T3310_timer_period_on_rsim_stack(protocol_id_enum ps_id)
{
    return MM_CUSTOM_T3310_TIMER_VALUE_ON_RSIM_STACK;
}


/*****************************************************************************
* FUNCTION
*  mm_custom_skip_force_lu
* DESCRIPTION
*   During inter RAT change between 23G<->4G, where UE was previously camped on 23G,
*   searched on 4G (due to Higher Priority PLMN search/recovery search to 4G), but could not find a 
*   suitable cell to camp on 4G and returned to 23G, MM need not perform a force LU in this case
*   as there was no intimation to the network about the transient inter RAT status or no T3212 expiry
* PARAMETERS
*  protocol_id_enum protocol stack 
*
* RETURNS
*  kal_bool
*   KAL_FALSE: Perform Force LU in the above scenario
*   KAL_TRUE: Do not perform Force LU in the above scenario
*
* GLOBALS AFFECTED
*  None
*
*****************************************************************************/
kal_bool mm_custom_skip_force_lu(protocol_id_enum ps_id)
{
    if (sbp_query_md_feature_by_ps(SBP_IS_OP12, ps_id) == KAL_TRUE)
    {
        return KAL_TRUE;
    }
    return KAL_FALSE;
}


