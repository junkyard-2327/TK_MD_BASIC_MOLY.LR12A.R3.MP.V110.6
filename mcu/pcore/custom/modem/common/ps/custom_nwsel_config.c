/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*******************************************************************************
 *
 * Filename:
 * ---------
 * custom_nwsel_config.c
 *
 * Project:
 * --------
 *   MONZA
 *
 * Description:
 * ------------
 *   This file is used to define the configurations of Selection customization feature
 *
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
==== THEIRS //UMOLY/BRANCHES_LR12/LR12.W1645.MD.MP/mcu/pcore/custom/modem/common/ps/custom_nwsel_config.c#3
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
==== YOURS //ws_zhipeng.feng_mbjswgwt3012_1579/UMOLY/TRUNK/LR12/mcu/pcore/custom/modem/common/ps/custom_nwsel_config.c
<<<<
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!

 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/
#include "string.h"
#include "kal_general_types.h"
#include "kal_public_defs.h"
#include "l3_inc_enums.h"
#include "custom_nwsel_config.h"
#include "custom_mm_config.h"
#include "ps_public_enum.h"
#include "gmss_public.h"
#include "l4_ps_api.h"

extern kal_bool nwsel_query_sbp_feature(sbp_md_feature_enum feature, kal_bool print_feature);
extern kal_bool nwsel_query_sbp_feature_with_simslot(kal_uint8 simInterface, sbp_md_feature_enum feature, kal_bool print_feature);
extern void nwsel_trace_rplmn_hpplmn_mcc_list(void);
/*************************************************************************
* EUTRAN disable timer
*
* TS 24.301, subclause 4.5:
*   As an implementation option, the UE may start a timer for enabling E-UTRA...
*
* AT&T spec, <CDR-DAM-320> Timer Value T_Disable-LTE:
*   T_Disable-LTE defines the duration that EUTRAN is to be 
*   disabled for. Its default value shall be 12mins ...
*   should be overwritten by t3402
*************************************************************************/
/* This value should NOT be 0, minimum value is 1 min */
/* If SBP_EUTRAN_DISABLE_TIMER_VALUE is set, this value will be ignored */
const kal_uint32 NWSEL_EUTRAN_DISABLE_TIMER_VALUE = KAL_TICKS_1_MIN * 12;

/* RJIO don't support any 23G NW so when SIM2 is RJIO SIM and recover search will effect the plmn list performance on SIM1 */
const kal_uint32 NWSEL_FOR_RJIO_RECOVER_TIMER_VALUE = KAL_TICKS_1_MIN * 60 * 3;


/*************************************************************************
* EUTRAN disable TD timer
*
* TS 23.122 subclause 3.1
*    If MS that has disabled its E-UTRA capability re-enables it when PLMN selection is performed, then the MS 
*    should, for duration of timer TD, memorize the PLMNs where E-UTRA capability was disabled as PLMNs where voice
*    service was not possible.
*************************************************************************/
/* This value should NOT be 0, minimum value is 1 min 
 * Default value is invalid, which means the value is as same as Higher Priority PLMN search timer (EF_HPPLMN in (U)SIM)
 * if SBP_EUTRAN_DISABLE_TD_TIMER_VALUE is set, this value will be ignored.
 */
const kal_uint32 NWSEL_EUTRAN_DISABLE_TD_TIMER_VALUE = NWSEL_INVALID_TIMER_VALUE;

/*************************************************************************
* EUTRAN disable ESM timer
*
* Clear Codes Data requirement - Telcel (Mexico)
*   The phone must not trigger Clear code 33 procedure unless 
*      5. LTE disable timer, 2 hours, (included on phones side) is reached then the procedure starts all over again.
*************************************************************************/
 /* This value is 2 hrs */
const kal_uint32 NWSEL_EUTRAN_DISABLE_ESM_TIMER_VALUE = KAL_TICKS_1_MIN * 120;

/*************************************************************************
* EUTRAN disable timer for reject cause #15 in HPLMN
*
* For 23G only SIM, UE will be reject with cause #13, #15 in 4G NW.
* To opitimize power consumption, disable EUTRAN in HPLMN if reject cause #13, #15 is received in 4G PLMN.
*************************************************************************/
 /* This value is 12 hrs */
#ifdef __HAPS_FPGA_CLK_ADJUST__
const kal_uint32 NWSEL_EUTRAN_DISABLE_FOR_REJ_IN_HPLMN_TIMER_VALUE = (KAL_TICKS_1_MIN/160) * 60 * 12;
#else
const kal_uint32 NWSEL_EUTRAN_DISABLE_FOR_REJ_IN_HPLMN_TIMER_VALUE = KAL_TICKS_1_MIN * 60 * 12;
#endif
/*************************************************************************
* customize EUTRAN disable timer 
*************************************************************************/
 /* This value is 12 hrs */
#ifdef __HAPS_FPGA_CLK_ADJUST__
const kal_uint32 NWSEL_CUSTOM_DISABLE_EUTRAN_TIMER_PERIOD = (KAL_TICKS_1_MIN/160) * 60 * 12;
#else
const kal_uint32 NWSEL_CUSTOM_DISABLE_EUTRAN_TIMER_PERIOD = KAL_TICKS_1_MIN * 60 * 12;
#endif
/*************************************************************************
* Incremental timer value for disabling EUTRAN for reject #13 / #15
* Starts timer for both HPLMN & VPLMN
* The timer unit represented in this array is minute e.g. 3 means 3 minute
* 
* Decide timer value depending on rejected counter
*************************************************************************/
/* Value is decided depending on counter */
#ifdef __NWSEL_INCREMENTAL_LTE_DISABLE_TIMER_QUICK_RETRY__
//Customer's requirement to quickly retry LTE 5 times and start 12hr timer
const kal_uint32 NWSEL_INCREMENTAL_LTE_DISABLE_TIMER_VALUE[] = {0, 0, 0, 0, 720};
#else
const kal_uint32 NWSEL_INCREMENTAL_LTE_DISABLE_TIMER_VALUE[] = {3, 30, 120, 720};
#endif


const kal_uint32 NWSEL_INCREMENTAL_LTE_DISABLE_TIMER_MAX_COUNT = sizeof(NWSEL_INCREMENTAL_LTE_DISABLE_TIMER_VALUE)/sizeof(kal_uint32);

#ifdef __MODEM_EM_MODE__
/*************************************************************************
* Timer value to report NWSEL timer EM info report periodically
*************************************************************************/
const kal_uint32 NWSEL_EM_REPORT_TIMER_VALUE = KAL_TICKS_1_SEC * 5;
#endif

#if 0 // phase out for table
#ifdef __ME_STORED_EHPLMN__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif // end of phase out for table

/*****************************************************************************
* FUNCTION
*   nwsel_custom_is_display_roaming_hplmn_in_eplmn
*
* DESCRIPTION
*   This function is used to configure whether display roaming when HPLMN is add into EPLMN list
*
* PARAMETERS
*   none
*
* RETURNS
* GLOBALS AFFECTED
*   none
*****************************************************************************/
kal_bool nwsel_custom_is_display_roaming_hplmn_in_eplmn(kal_uint8 sim_interface)
{
    return (nwsel_query_sbp_feature_with_simslot(sim_interface, SBP_DISABLE_DISPLAY_ROAMING_HPLMN_IN_EPLMN,KAL_FALSE)==KAL_FALSE);
}


/*****************************************************************************
* FUNCTION
*   nwsel_custom_is_skip_new_fplmn_manual_resel
*
* DESCRIPTION
*   This function is used to configure whether to skip the remainning RAT for rejected by FORBIDDEN PLMN
*
* PARAMETERS
*   none
*
* RETURNS
* GLOBALS AFFECTED
*   none
*****************************************************************************/
kal_bool nwsel_custom_is_disable_skip_new_fplmn_manual_resel(void)
{
    return nwsel_query_sbp_feature(SBP_DISABLE_SKIP_NEW_FPLMN_MANUAL_RESEL,KAL_FALSE);
}

/*****************************************************************************
* FUNCTION
*   nwsel_custom_enable_plmnsel_oplmn_coexist
*
* DESCRIPTION
*   This function is used to configure whether enable ef_plmnsel and ef_oplmn both take effect
*
* PARAMETERS
*   none
*
* RETURNS
* GLOBALS AFFECTED
*   none
*****************************************************************************/
kal_bool nwsel_custom_enable_plmnsel_oplmn_coexist(void)
{
    return (nwsel_query_sbp_feature(SBP_DISABLE_PLMNSEL_OPLMN_COEXIST,KAL_FALSE)==KAL_FALSE);
}

/*****************************************************************************
* FUNCTION
*   nwsel_custom_ignore_eqplmn_in_manual_mode
*
* DESCRIPTION
*   This function is used to configure whether shall ignore equivalent PLMN only in manual mode or not
*
* PARAMETERS
*   none
*
* RETURNS
*   KAL_TRUE:
*   KAL_FALSE:
* GLOBALS AFFECTED
*   none
*****************************************************************************/
kal_bool nwsel_custom_ignore_eqplmn_in_manual_mode(void)
{
    return nwsel_query_sbp_feature(SBP_MM_IGNORE_EQPLMN_IN_MANUAL_MODE,KAL_FALSE);
}

/*****************************************************************************
* FUNCTION
*   nwsel_custom_ignore_eqplmn_in_auto_mode
*
* DESCRIPTION
*   This function is used to configure whether shall ignore equivalent PLMN only in auto mode or not
*
* PARAMETERS
*   none
*
* RETURNS
*   KAL_TRUE:
*   KAL_FALSE:
* GLOBALS AFFECTED
*   none
*****************************************************************************/
kal_bool nwsel_custom_ignore_eqplmn_in_auto_mode(void)
{
    return nwsel_query_sbp_feature(SBP_MM_IGNORE_EQPLMN_IN_AUTO_MODE,KAL_FALSE);
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_allow_rplmn_hplmn_combined_search
*
* DESCRIPTION
*  This function is used to configure whether search RPLMN and HPLMN together.
*
*  [Important!]
*  If return value of nwsel_custom_is_search_hplmn_before_rplmn is set to KAL_TRUE, 
*  configuration of nwsel_custom_allow_rplmn_hplmn_combined_search will not take effect.
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_allow_rplmn_hplmn_combined_search(kal_uint8 sim_interface)
{
    /*if search RPLMN and HPLMN together, it is more quickly to camp on HPLMN,
    and no need to do high priority plmn search later.
    But it may disobey test case 6.2.1.1 in spec 34.123. 
    */

    if(nwsel_query_sbp_feature(SBP_RPLMN_HPLMN_COMBINED_SEARCH,KAL_FALSE) == KAL_TRUE)
    {
        return KAL_TRUE;
    }
    else
    {
        if( gmss_is_tdscdma_mode_activated(sim_interface) == KAL_TRUE) /*for TDD project, this compile option is open*/
        {
            return KAL_FALSE;
        }
        else
        {
        #if defined(__DUMMY_OFF_R7_AUTO_RHPLMN_SEL__)
            return KAL_TRUE;            
        #else
            return KAL_FALSE;
        #endif
        }
    }
} 

/*************************************************************************
 * Define cause list that NWSEL will  disable EUTRAN when receiving NWSEL_EMM_DETACH_MT_REATTACH_NOT_REQD.
 *
 * Without this table, NWSEL uses SBP_DISABLE_EUTRAN_AFTER_DETACH_NOT_REQ_ABNORMAL 
 * to decide if need to disable EUTRAN or not when receiving NWSEL_EMM_DETACH_MT_REATTACH_NOT_REQD.
 *
 * With this table, customer can decide to disable EUTRAN or not based on different cause.
 * For example, IMPLICIT_DETACH is in this table, and NW sends DETACH_MT_REATTACH_NOT_REQD with this cause(IMPLICIT_DETACH).
 * NWSEL will  disable EUTRAN for this DETACH_MT_REATTACH_NOT_REQD even the SBP(SBP_DISABLE_EUTRAN_AFTER_DETACH_NOT_REQ_ABNORMAL) is off.
 *
 * The following causes has specific handling descripted by spec, so do NOT add them in the list.
 * #2, #3, #6, #7, #8, #11, #12, #13, #14, #15, #25, #35
 *
 * Please refer to 5.5.2.3.4 in TS 24.301 for standard behavior.
 *
 *************************************************************************/
#define INVALID_CUSTOM_CAUSE 0xFF
const mm_cause_enum CUSTOM_CAUSE_TBL_NEED_DISABLE_EUTRAN_FOR_REATTACH_NOT_REQIRED[] = {INVALID_CUSTOM_CAUSE};
const kal_uint32 CUSTOM_CAUSE_TBL_NEED_DISABLE_EUTRAN_FOR_REATTACH_NOT_REQIRED_NUM = sizeof(CUSTOM_CAUSE_TBL_NEED_DISABLE_EUTRAN_FOR_REATTACH_NOT_REQIRED)/sizeof(mm_cause_enum);

/*****************************************************************************
* FUNCTION
*  nwsel_custom_is_disable_eutran_after_no_suitable_cell_exist
* DESCRIPTION
*  AT&T requirement <CDR-DAM-415>When a Combined Attach/TAU Request is rejected with
* cause #17, a maximum of 5 attempts shall be made. Disable EUTRAN for PLMN 310-410
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_is_disable_eutran_after_reject(nwsel_disable_eutran_cause_enum cause)
{
    return nwsel_custom_is_disable_eutran_after_reject_with_cause(cause, EMM_CAUSE_CAUSE_NONE);
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_is_disable_eutran_after_reject_with_cause
* DESCRIPTION
*  extension of nwsel_custom_is_disable_eutran_after_reject
*
* PARAMETERS
*
* RETURNS
*  KAL_TRUE: disable eutran.  KAL_FALSE: not disable eutran
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_is_disable_eutran_after_reject_with_cause(nwsel_disable_eutran_cause_enum cause, mm_cause_enum mm_cause)
{
    if(cause == NWSEL_REJECT_15)
    {
        return nwsel_query_sbp_feature(SBP_DISABLE_EUTRAN_AFTER_NO_SUITABLE,KAL_FALSE);
    }
    else if(cause == NWSEL_REJECT_ABNORMAL)
    {
        return nwsel_query_sbp_feature(SBP_DISABLE_EUTRAN_AFTER_ABNORMAL,KAL_FALSE);
    }
    else if(cause == NWSEL_REJECT_13)
    {
        return nwsel_query_sbp_feature(SBP_DISABLE_EUTRAN_AFTER_ROAMING_NOT_ALLOWED, KAL_FALSE);
    }
    /*
     * MW R13 TS24301 CR2037.  Please refer to 5.5.2.3.4 in TS 24.301
     * A UE supporting A/Gb mode or Iu mode and operating in CS/PS mode 1 of operation or CS/PS mode 2 of operation shall
     * -enter EMM-DERREGISTERED and attempt to select GERAN or UTRAN and proceed with MM or GMM specific procedure. In this case, the UE may disable the E-UTRA capability; or
     * -enter EMM-DEREGISTERED.PLMN-SEARCH in order to perform a PLMN selection according to 3GPP TS 23.122
     */  
    else if(cause == NWSEL_DETACH_NOT_REQ_ABNORMAL)
    {
        if (nwsel_query_sbp_feature(SBP_DISABLE_EUTRAN_AFTER_DETACH_NOT_REQ_ABNORMAL, KAL_FALSE) == KAL_TRUE)
        {
            // SBP on, need disable EUTRAN.
            return KAL_TRUE;
        }
        else
        {
            // SBP off, may disable EUTRAN, need check emm cause
            kal_uint32 i = 0;

            for (i = 0; i < CUSTOM_CAUSE_TBL_NEED_DISABLE_EUTRAN_FOR_REATTACH_NOT_REQIRED_NUM; i++)
            {
                if (CUSTOM_CAUSE_TBL_NEED_DISABLE_EUTRAN_FOR_REATTACH_NOT_REQIRED[i] == INVALID_CUSTOM_CAUSE)
                {
                    continue;
                }

                if (CUSTOM_CAUSE_TBL_NEED_DISABLE_EUTRAN_FOR_REATTACH_NOT_REQIRED[i] == mm_cause)
                {
                    // Cause in the table, need disable EUTRAN
                    return KAL_TRUE;
                }
            }

            // cause is not in the table, not disable EUTRAN
            return KAL_FALSE;
        }
    }
    
    return KAL_FALSE;
}


/*************************************************************************
 * International Higher Priorirty PLMN Search
 * 
 * [Important!] Enable this option will violate TS23.122 and thus fail FTA cases
 *
 * - NWSEL_RPLMN_MCC_LIST / NWSEL_HPPLMN_MCC_LIST:
 *   - The UE is allowed to perform international HPPLMN search when the UE
 *     1. registers on a PLMN belonging to one of the MCCs defined in NWSEL_RPLMN_MCC_LIST, and
 *     2. the HPPLMN belongs to one of the MCCs defined in NWSEL_HPPLMN_MCC_LIST
 *
 * - If the MCC of RPLMN or HPPLMN is not restricted
 *   - NWSEL_RPLMN_MCC_LIST or NWSEL_HPPLMN_MCC_LIST shall contain only one entry {ALL_MCC_ALLOWED}
 *
 * - If the UE is not allowed to perform international HPPLMN search
 *   - NWSEL_RPLMN_MCC_LIST and NWSEL_HPPLMN_MCC_LIST shall contain only one entry {NO_MCC_ALLOWED}
 *************************************************************************/
/*  The UE is allowed to perform international HPPLMN search when the UE
 *  1. registers on a PLMN belonging to any MCC, and 
 *  2. the HPPLMN belongs to any MCC
 */
kal_uint32 NWSEL_RPLMN_MCC_LIST_ANY[] = {ALL_MCC_ALLOWED};
kal_uint32 NWSEL_HPPLMN_MCC_LIST_ANY[] = {ALL_MCC_ALLOWED};
/*  The UE is allowed to perform international HPPLMN search when the UE
 *  1. registers on a PLMN belonging to US/Canada/Mexico/British Virgin Islands, and 
 *  2. the HPPLMN belongs to any MCC
 */
kal_uint32 NWSEL_RPLMN_MCC_LIST_ATNT[] = {310, 311, 312, 313, 314, 315, 316, 302, 334, 330, 348, 544};
kal_uint32 NWSEL_HPPLMN_MCC_LIST_ATNT[] = {ALL_MCC_ALLOWED};
/*  The UE is allowed to perform international HPPLMN search when the UE
 *  1. registers on a PLMN belonging to US, and 
 *  2. the HPPLMN belongs to Canada
 */
kal_uint32 NWSEL_RPLMN_MCC_LIST_INT[] = {310, 311, 312, 313, 314, 315, 316};
kal_uint32 NWSEL_HPPLMN_MCC_LIST_INT[] = {302};
/* The UE is not allowed to perform international HPPLMN search */

kal_uint32 NWSEL_RPLMN_MCC_LIST_DEF[] = {NO_MCC_ALLOWED};
kal_uint32 NWSEL_HPPLMN_MCC_LIST_DEF[] = {NO_MCC_ALLOWED};

kal_uint32 *NWSEL_RPLMN_MCC_LIST = NULL;
kal_uint32 *NWSEL_HPPLMN_MCC_LIST = NULL;

kal_uint32 NWSEL_RPLMN_MCC_NUM=0;
kal_uint32 NWSEL_HPPLMN_MCC_NUM=0;
/*************************************************************************
 * Country Boarder Resolution
 * 
 * add countries that are close to each other in the same group, fast roaming would take it into consideration.
 * e.g. HK and China you might add {454,460} >> kal_uint32 NWSEL_BD_MCC_LIST[][NUM_OF_BD_MCC] = {{234,460},{454,460}};
 * you might also add more than two entries, 
 *  e.g. {454,460,466} but you need to adjust NUM_OF_BD_MCC into 3 and add one dummy entry
 * (e.g. all 0, don't use ALL_MCC_ALLOWED/NO_MCC_ALLOWED for dummy entry) for previous setting
 *************************************************************************/
kal_uint32 NWSEL_BD_MCC_LIST[][NUM_OF_BD_MCC] = {{234,460},{440,450}};
nwsel_custom_sim_operator_enum NWSEL_BD_SIM_LIST[] = {CUTSOM_SIM_VZW, CUSTOM_SIM_KDDI_TEST};
const kal_uint32 NWSEL_BD_MCC_AREA_NUM = sizeof(NWSEL_BD_MCC_LIST)/(sizeof(kal_uint32)*NUM_OF_BD_MCC);

/*****************************************************************************
* FUNCTION
*   nwsel_custom_get_bd_mcc_num
*
* DESCRIPTION
*   get the number of BD MCC
*
* PARAMETERS
*   none
*
* RETURNS
*   kal_uint32  - the number of BD MCC
*
* GLOBALS AFFECTED
*   use function for customization without re-new library relase
*
*****************************************************************************/
kal_uint32 nwsel_custom_get_bd_mcc_num(void)
{
    return NUM_OF_BD_MCC;
}


/*************************************************************************
 * Non-US PLMN
 * 
 * <CDR-NWS-550> Definition of International Roaming
 * Summary: For the purposes of this feature only, the UE shall consider itself to be roaming internationally under the following conditions: 
 * o When the MCC of the serving PLMN is not in the range 310 to 316, or 
 * o When the serving PLMN code is one of the following: 
 * o 310-110 - Pacific Telecom 
 * o 310-140 - Pulse Mobile 
 * o 310-400 - Guam Wireless/WaveRunner 
 * o 310-470 - Northern Marianna Islands 
 * o 311-170 - Petrocom Note: These PLMNs use a US-based MCC, but operate outside of mainland USA and are to be considered as international roaming carriers by AT&T. 
 *************************************************************************/
const char *CUSTOM_NON_US_PLMN[] = {"310110", "310140", "310400","310470","311170",CUSTOM_EQ_PLMN_SET_END};

const kal_uint32 CUSTOM_NON_US_PLMN_NUM = sizeof(CUSTOM_NON_US_PLMN)/sizeof(char *);

/*****************************************************************************
* FUNCTION
*   mm_custom_state_after_lu_abnormal
*
* DESCRIPTION
*   According to 3GPP TS24.008 4.4.4.9, the UE may enter the MM IDLE sub-state ATTEMPTING TO UPDATE or
*   optionally the MM IDLE sub-state PLMN SEARCH after LU abnormal 4 times.
*
* PARAMETERS
*   none
*
* RETURNS
*   MM_ENTER_STATE_DEPEND_ON_CONDITION  - Default behavior
*   MM_ENTER_STATE_PLMN_SEARCH          - Always enter MM IDLE sub-state PLMN SEARCH and perform PLMN selection
*   MM_ENTER_STATE_ATTEMPTING_TO_UPDATE - Always enter MM IDLE sub-state ATTEMPTING TO UPDATE and stay on current cell
*
* GLOBALS AFFECTED
*   none
*****************************************************************************/
mm_state_after_lu_abnormal_enum nwsel_custom_state_after_lu_abnormal(void)
{
    if(nwsel_query_sbp_feature(SBP_MM_PERFORM_PLMN_SEARCH_AFTER_LU_ABNORMAL,KAL_FALSE) == KAL_TRUE)
    {
        return MM_ENTER_STATE_PLMN_SEARCH;
    }
    else
    {
        return MM_ENTER_STATE_DEPEND_ON_CONDITION;
    }
}

/*****************************************************************************
* FUNCTION
*   nwsel_custom_state_after_detach_not_req_abnormal
*
* DESCRIPTION
*   According to 3GPP TS24.301 5.5.2.3.4, the UE may enter the EMM-DEREGISTERED.PLMN-SEARCH state or EMM-DEREGISTERED.ATTEMPTING-TO-ATTACH.
*
* PARAMETERS
*   none
*
* RETURNS
*   EMM_ENTER_STATE_PLMN_SEARCH          - Always enter EMM-DEREGISTERED.PLMN-SEARCH and perform PLMN selection
*   EMM_ENTER_STATE_ATTEMPTING_TO_ATTACH - Always enter EMM-DEREGISTERED.ATTEMPTING-TO-ATTACH and stay on current cell
*
* GLOBALS AFFECTED
*   none
*****************************************************************************/
emm_state_after_detach_not_req_abnormal_enum nwsel_custom_state_after_detach_not_req_abnormal(void)
{
    if (nwsel_query_sbp_feature(SBP_EMM_PERFORM_PLMN_SEARCH_AFTER_DETACH_NOT_REQ_ABNORMAL,KAL_FALSE) == KAL_TRUE)
    {
        return EMM_ENTER_STATE_PLMN_SEARCH;
    }
    else
    {
        return EMM_ENTER_STATE_ATTEMPTING_TO_ATTACH;
    }
}

/*****************************************************************************
* FUNCTION
*   nwsel_custom_is_try_abnormal_lai_once_more
* DESCRIPTION
*   If abnormal LU 4 times happen, MS will try to search other available and allowable PLMNs. If no other PLMN is found,
*   MS will go back to the abnormal-4-times PLMN and do registration with another 4 attempts.
*
* PARAMETERS
*   none
* RETURNS
*   kal_bool - indicate if "try abnormal lai once more" is enabled.
* GLOBALS AFFECTED
*   none
*****************************************************************************/
kal_bool nwsel_custom_is_try_abnormal_lai_once_more(void)
{
    return nwsel_query_sbp_feature(SBP_MM_TRY_ABNORMAL_LAI_ONCE_MORE, KAL_FALSE);
}


/*************************************************************************
 * HPLMN matching criteria enhance and customized equivalent PLMN definition
 * 
 * [Important!] Inappropriate setting may violate spec and thus fail FTA cases
 *
 * - CUSTOM_EQ_PLMN[]
 *   Ex: CUSTOM_EQ_PLMN[] = 
 *           {"001010", "00101F", "00202F", CUSTOM_EQ_PLMN_SET_END, //the first 3 PLMNs are regarded as eqivalent to each other
 *            "100011", "10002F", CUSTOM_EQ_PLMN_SET_END}           //100011 and 10002F are regarded as equivalent. 
 *************************************************************************/
/*  Regards 31026F and 310260 as eqivalent. To allow cell reselection between 310260 and 31026F (T-Mobile)  */
const char *CUSTOM_EQ_PLMN_TMO[] = {"31026F", "310260", CUSTOM_EQ_PLMN_SET_END};

/* Default. Follows TS23.122 Annex A. Eg. In 310260, MS can reselect to 31026F. 
 * But if in 31026F, MS can't reselect to 310260. 
 */
const char *CUSTOM_EQ_PLMN_DEF[] = {CUSTOM_EQ_PLMN_SET_END,};

const char **CUSTOM_EQ_PLMN = NULL;

kal_uint32 CUSTOM_EQ_PLMN_NUM = 0;

/*********************************************************************************
 * Customized equivalent plmn list
 * This feature is let customer to add some equivalent plmn list if 
 * DUT meet the specific SIM and RPLMN combination.
 *
 * [Important!] Inappropriate setting may violate spec and thus fail FTA cases
 *              Also cause unexpected plmn selection and received unexpected reject cause
 *              Please add it carefully
 *
 * Specific SIM is identified by SIM's the first entry of EHPLMN(i.e. EHPLMN[0]), 
 * or identified by the plmn of IMSI if ther no EHPLMN file.
 *
 * RPLMN means DUT current registered PLMN
 *
 * Each array has 5 elements: {EHPLMN[0], RPLMN, EPLMN1, EPLMN2, EPLMN3}
 * Only if the current SIM's EHPLMN[0] is matched the specified EHPLMN[0] and 
 * DUT's current registered RPLMN is matched the specified RPLMN, then DUT will
 * add EPLMN1/2/3 into equivalent plmn list automatically even though network not assign
 * NOTE: EPLMN = FFFFFF if you do not want to specify
 *
 * Take Malaysia UNIFI operator as a example
 * The EHPLMN[0] for UNIFI USIM is 502153. If DUT using UNIFY SIM registered in 50219F plmn,
 * case 1: you want add 502100, 502101, 502102 as equivelent PLMN,
 * you can write {"502153", "50219F", "502100", "502101", "502102"}
 * case 2: you want add 502100, 502101, as equivelent PLMN,
 * you can write {"502153", "50219F", "502100", "502101", "FFFFFF"}
 *********************************************************************************/
const char *CUSTOM_SIM_SPECIFIC_EQ_PLMN_LIST[][CUSTOM_SIM_SPECIFIC_EQ_PLMN_MAX_NUM] = {
                                {"502153", "50219F", "502153", "FFFFFF", "FFFFFF"}, // Malaysia UNIFI operator
                                };
const kal_uint32 CUSTOMSIM_SPECIFIC_EQ_PLMN_SET = sizeof(CUSTOM_SIM_SPECIFIC_EQ_PLMN_LIST)/(sizeof(char *)*CUSTOM_SIM_SPECIFIC_EQ_PLMN_MAX_NUM);

/*****************************************************************************
* FUNCTION
*   nwsel_custom_get_sim_specific_eq_plmn_max_num
*
* DESCRIPTION
*   get the max. number of customiized EQ PLMN
*
* PARAMETERS
*   none
*
* RETURNS
*   kal_uint32  - the max. number of customiized EQ PLMN
*
* GLOBALS AFFECTED
*   use function for customization without re-new library relase
*
*****************************************************************************/
kal_uint32 nwsel_custom_get_sim_specific_eq_plmn_max_num(void)
{
    return CUSTOM_SIM_SPECIFIC_EQ_PLMN_MAX_NUM;
}


/*************************************************************************
 * Customized EHPLMN
 * Make sure SBP_NWSEL_CUSTOMIZE_EHPLMN is turned on, and add entries as following
 *************************************************************************/
const char *CUSTOM_NWSEL_EHPLMN_LIST[][CUSTOM_NWSEL_EHPLMN_MAX_NUM] = {
                                        {"46011F","46003F","FFFFFF","FFFFFF","FFFFFF"},  //CT
                                        {"46000F","46002F","46004F","46007F","46008F"},  //CMCC
                                        {"52005F","52018F","52047F","FFFFFF","FFFFFF"},  //DTAC
                                        {"52000F","52004F","52099F","FFFFFF","FFFFFF"},  //TRUEMOVE
                                        {"52001F","52003F","52023F","FFFFFF","FFFFFF"},  //AIS
                                        {"46001F","46006F","46009F","FFFFFF","FFFFFF"},  //CU
                                        {"22603F","22606F","FFFFFF","FFFFFF","FFFFFF"},  //Telekom Romania
                                        };
/* How many sets */
const kal_uint32 CUSTOM_NWSEL_EHLMN_SET = sizeof(CUSTOM_NWSEL_EHPLMN_LIST)/(sizeof(char *)*CUSTOM_NWSEL_EHPLMN_MAX_NUM);

/*****************************************************************************
* FUNCTION
*   nwsel_custom_get_nwsel_ehplmn_max_num
*
* DESCRIPTION
*   get the max. number of customized EHPLMN
*
* PARAMETERS
*   none
*
* RETURNS
*   kal_uint32  - the max. number of customized EHPLMN
*
* GLOBALS AFFECTED
*   use function for customization without re-new library relase
*
*****************************************************************************/
kal_uint32 nwsel_custom_get_nwsel_ehplmn_max_num(void)
{
    return CUSTOM_NWSEL_EHPLMN_MAX_NUM;
}


/*****************************************************************************
* NWSEL use this lists to decide plmn search rat order when CSFB by PLMN Search
* If RPLMN is in this list, then search rat order will be 2G=>3G
* Otherwise, search rat order will be 3G=>2G
*****************************************************************************/
const char *CUSTOM_CSFB_PREFER_2G_PLMN[] = {"45412F", "46000F", "46002F", "46007F", "46008F", CUSTOM_EQ_PLMN_SET_END};

/*****************************************************************************
* NWSEL use this lists to avoid live network influence for SS test, not used for NS-IOT test* 
*****************************************************************************/
const char *CUSTOM_FPLMN[] = {"46000F", "46001F", "46011F", INVALID_CUSTOM_BL_PLMN};
const kal_uint32 CUSTOM_FPLMN_NUM = sizeof(CUSTOM_FPLMN)/sizeof(char *);


/*****************************************************************************
* FUNCTION
*  nwsel_custom_use_fplmn
* DESCRIPTION
*   For PCT or some SS test cases , NWSEL treat live NW plmn as forbiden.
*
* PARAMETERS
*
* RETURNS
*   KAL_TRUE:
*    - MS will applay CUSTOM_FPLMN when plmn search
*   KAL_FALSE:
*    - MS will not applay CUSTOM_FPLMN when plmn search
* GLOBALS AFFECTED
*  None
*****************************************************************************/

kal_bool nwsel_custom_use_fplmn(void)
{
    return nwsel_query_sbp_feature(SBP_CUSTOM_FPLMN_USED,KAL_FALSE);
}


/*****************************************************************************
* FUNCTION
*  nwsel_custom_config_custom_eq_plmn_list
* DESCRIPTION
*  This function is used to configure CUSTOM_EQ_PLMN by SBP function 
*
* PARAMETERS
*
* RETURNS
*  NONE
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void nwsel_custom_config_custom_eq_plmn_list(void)
{
    if (nwsel_query_sbp_feature(SBP_TMO_PLMN_MATCHING,KAL_FALSE) == KAL_TRUE)
    {
        CUSTOM_EQ_PLMN_NUM = sizeof(CUSTOM_EQ_PLMN_TMO)/sizeof(char *);
        CUSTOM_EQ_PLMN = CUSTOM_EQ_PLMN_TMO;
    }
    
    else
    {
        CUSTOM_EQ_PLMN_NUM = sizeof(CUSTOM_EQ_PLMN_DEF)/sizeof(char *);
        CUSTOM_EQ_PLMN = CUSTOM_EQ_PLMN_DEF;
    } 
}


/*************************************************************************
 * After abnormal LU 4 times, UE should wait T3212 timeout and then start next LU attempt round.
 * Customization can be done here. Config the RETRY_ABNORMAL_LAI timer value as below. UE will 
 * start the next LU attempt when the RETRY_ABNORMAL_LAI timer expires.
 *************************************************************************/
/* default value: 10 minutes */
const kal_uint32 NWSEL_RETRY_ABNORMAL_LAI_TIMER_PERIOD = 10 * KAL_TICKS_1_MIN;
const kal_uint32 NWSEL_RETRY_ABNORMAL_RAI_TIMER_PERIOD = 15 * KAL_TICKS_1_MIN;

/*************************************************************************
Customer needs customizable HPLMN_SEARCH_TIMER value only if SIM_PROVIDED value is 0
Retaining the default as 0, but customer can make necessary changes to the 
desired value and NWSEL will consider this value only if SIM_PROVIDED value is 0
1 unit = NWSEL_HPLMN_SEARCH_TIMER_UNIT (6 minute steps)
*************************************************************************/
const kal_uint32 NWSEL_CUSTOM_HPPLMN_SEARCH_PERIOD = 0; //In NWSEL_HPLMN_SEARCH_TIMER_UNIT

/*************************************************************************
 * Sniff guard timer
 * if the specified RAT sniff retry reach its max attempt counters,
 * should start a timer to stop retry in following time period
 *************************************************************************/
/* default value: 2minutes */
const kal_uint32 NWSEL_UAS_SNIFF_GUARD_TIMER_PERIOD = KAL_TICKS_1_MIN;
const kal_uint32 NWSEL_EAS_SNIFF_GUARD_TIMER_PERIOD = 2 * KAL_TICKS_1_MIN;

const kal_uint8 NWSEL_UAS_SNIFF_MAX_ATTEMPT = 2;
const kal_uint8 NWSEL_EAS_SNIFF_MAX_ATTEMPT = 2;

/*************************************************************************
* KOREA MCC are added in this array
* Used for different optimizations
*************************************************************************/
const kal_uint16 KOREA_MCC[] = {450};
const kal_uint8 KOREA_MCC_NUM = (kal_uint8) (sizeof(KOREA_MCC) / sizeof(kal_uint16));

//machaine test cell TA area [0-100]
const kal_uint8 CUSTOM_MAX_LATA_FOR_TEST_CELL[2] = {0x00,0x64};

/*************************************************************************
 * Ignore equivalent PLMN list assigned by operator
 * 
 * - IGNORE_EQPLMN_OPERATOR
 *     - If HPLMN belongs to any PLMN defined in the list,
 *       all eqivalent PLMNs assigned by this HPLMN will be ignored.
 * 
 *************************************************************************/
char *IGNORE_EQPLMN_OPERATOR[] = {IGNORE_EQPLMN_OPERATOR_SET_END, IGNORE_EQPLMN_OPERATOR_SET_END, IGNORE_EQPLMN_OPERATOR_SET_END};
kal_uint32 IGNORE_EQPLMN_OPERATOR_NUM = sizeof(IGNORE_EQPLMN_OPERATOR)/sizeof(char *);
/* It is only used for temporary storage, changing this array would not affect any UE behavior */
char *IGNORE_EQPLMN_OPERATOR_TEMP[] = {IGNORE_EQPLMN_OPERATOR_SET_END, IGNORE_EQPLMN_OPERATOR_SET_END, IGNORE_EQPLMN_OPERATOR_SET_END};

/* It is only used for YOIGO recovery search plmn in manual selection mode */
char* ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH [] = {INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                      INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                      INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                      INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                      INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                      INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH};

kal_uint32 ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH_NUM = sizeof(ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH)/sizeof(char *);

/* It is only specified YOIGO recovery search plmn in manual selection mode */
char* YOIGO_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH[] = {"21407F",
                                                       "21403F",
                                                       INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                       INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                       INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                       INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH};

/* It is only used for temporary storage, changing this array would not affect any UE behavior */
char* ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH_TEMP [] = {INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                           INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                           INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                           INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                           INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                                                           INVALID_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH};

/*****************************************************************************
* FUNCTION
*  nwsel_custom_config_ignore_eqplmn_operator_list
* DESCRIPTION
*  This function is used to configure IGNORE_EQPLMN_OPERATOR by SBP function 
*  when IGNORE_EQPLMN_OPERATOR is empty.
*
* PARAMETERS
*
* RETURNS
*  NONE
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void nwsel_custom_config_ignore_eqplmn_operator_list(void)
{
    kal_uint32 index = 0;

    kal_mem_cpy(IGNORE_EQPLMN_OPERATOR_TEMP, 
                IGNORE_EQPLMN_OPERATOR,
                IGNORE_EQPLMN_OPERATOR_NUM*sizeof(char*));

    kal_mem_cpy(ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH_TEMP, 
                ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH_NUM*sizeof(char*));

    /* If IGNORE_EQPLMN_OPERATOR is not empty, do not change the list by SBP */
    if (strcmp(IGNORE_EQPLMN_OPERATOR[0], IGNORE_EQPLMN_OPERATOR_SET_END) != 0)
    {
        return;
    }
    
    if (nwsel_query_sbp_feature(SBP_MM_IGNORE_YOIGO_EQPLMN,KAL_FALSE) == KAL_TRUE)
    {
        IGNORE_EQPLMN_OPERATOR_TEMP[index] = "21404F";
        index++;
        kal_mem_cpy(ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH_TEMP, 
                    YOIGO_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH,
                    ADD_CUSTOM_PLMN_IN_MANUAL_RECOVERY_SEARCH_NUM*sizeof(char*));
    }

    if (nwsel_query_sbp_feature(SBP_MM_IGNORE_PLAY_EQPLMN,KAL_FALSE) == KAL_TRUE)
    {
        IGNORE_EQPLMN_OPERATOR_TEMP[index] = "26006F";
        index++;
    }
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_config_hpplmn_search_mcc_list
* DESCRIPTION
*  This function is used to configure NWSEL_RPLMN_MCC_LIST/NWSEL_HPPLMN_MCC_LIST by SBP function 
*
* PARAMETERS
*
* RETURNS
*  NONE
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void nwsel_custom_config_hpplmn_search_mcc_list(void)
{
    if (nwsel_query_sbp_feature(SBP_HPPLMN_REGARDLESS_ANY_MCC,KAL_FALSE) == KAL_TRUE)
    {
        NWSEL_RPLMN_MCC_LIST = NWSEL_RPLMN_MCC_LIST_ANY;
        NWSEL_HPPLMN_MCC_LIST = NWSEL_HPPLMN_MCC_LIST_ANY;        
        NWSEL_RPLMN_MCC_NUM = sizeof(NWSEL_RPLMN_MCC_LIST_ANY)/sizeof(kal_uint32);
        NWSEL_HPPLMN_MCC_NUM = sizeof(NWSEL_HPPLMN_MCC_LIST_ANY)/sizeof(kal_uint32);
    }
    else if (nwsel_query_sbp_feature(SBP_ATNT_HPPLMN_SEARCH,KAL_FALSE) == KAL_TRUE)
    {
        NWSEL_RPLMN_MCC_LIST = NWSEL_RPLMN_MCC_LIST_ATNT;
        NWSEL_HPPLMN_MCC_LIST = NWSEL_HPPLMN_MCC_LIST_ATNT;
        NWSEL_RPLMN_MCC_NUM = sizeof(NWSEL_RPLMN_MCC_LIST_ATNT)/sizeof(kal_uint32);
        NWSEL_HPPLMN_MCC_NUM = sizeof(NWSEL_HPPLMN_MCC_LIST_ATNT)/sizeof(kal_uint32);
    }
    else if (nwsel_query_sbp_feature(SBP_MM_INTERNATIONAL_HPPLMN_SEARCH,KAL_FALSE) == KAL_TRUE)
    {
        NWSEL_RPLMN_MCC_LIST = NWSEL_RPLMN_MCC_LIST_INT;
        NWSEL_HPPLMN_MCC_LIST = NWSEL_HPPLMN_MCC_LIST_INT;
        NWSEL_RPLMN_MCC_NUM = sizeof(NWSEL_RPLMN_MCC_LIST_INT)/sizeof(kal_uint32);
        NWSEL_HPPLMN_MCC_NUM = sizeof(NWSEL_HPPLMN_MCC_LIST_INT)/sizeof(kal_uint32);
    }
    else
    {
        NWSEL_RPLMN_MCC_LIST = NWSEL_RPLMN_MCC_LIST_DEF;
        NWSEL_HPPLMN_MCC_LIST = NWSEL_HPPLMN_MCC_LIST_DEF;
        NWSEL_RPLMN_MCC_NUM = sizeof(NWSEL_RPLMN_MCC_LIST_DEF)/sizeof(kal_uint32);
        NWSEL_HPPLMN_MCC_NUM = sizeof(NWSEL_HPPLMN_MCC_LIST_DEF)/sizeof(kal_uint32);
    } 
}

/*************************************************************************
 * customized roaming allow whitelist PLMN definition
 * 
 * To prevent the specified PLMN is banned due to disable roaming
 *   Ex: HPLMN 46001, international roaming is disable but want to allow to roam on 46692, 46689.
 * - CUSTOM_WL_PLMN[]
 *   Ex: CUSTOM_WL_PLMN[] = 
 *           {"46692F","46689F"}         
 *************************************************************************/

/*  If roaming is disable, only specified PLMNs/HPLMN can be registered by UE  */

const char *CUSTOM_WL_PLMN[] = {INVALID_CUSTOM_WL_PLMN};

const kal_uint32 CUSTOM_WL_PLMN_NUM = sizeof(CUSTOM_WL_PLMN)/sizeof(char *);

/*************************************************************************
 * customized non-existing network not allow blacklist definition
 * 
 * To prevent waste time to search non-existing PLMN
 * note: no guarantee that the specified network won't be found, just reduce the possibility to search 
 *   Ex: TDD project search 46001
 * - CUSTOM_BL_PLMN[] = {"46001F"} 
 *    CUSTOM_BL_RAT[] = {NWSEL_UMTS} 
 *    CUSTOM_BL_RAT[] = {NWSEL_UMTS} 
 *   Ex2: do not search china 3G
 * - CUSTOM_BL_PLMN[] = {"460FFF"} 
 *    CUSTOM_BL_RAT[] = {NWSEL_UMTS} 
 *************************************************************************/

/*  If network(PLMN/RAT) is specified, do not waste time on power scan the PLMN/RAT */
#ifdef __DISABLE_CUSTOM_NONEXISTING_NETWORK_MECHANISM__
const char *CUSTOM_BL_PLMN[] = {INVALID_CUSTOM_BL_PLMN};
const nwsel_rat_enum CUSTOM_BL_RAT[] = {NWSEL_RAT_NONE};
#else
/* not apply the optimization for CMCC customization phone. That is, blacklist won't affect RAT decision when OP01 is on */
const char *CUSTOM_BL_PLMN[] = {"46000F",
                                INVALID_CUSTOM_BL_PLMN};

const nwsel_rat_enum CUSTOM_BL_RAT[] = {NWSEL_UMTS,
                                        NWSEL_RAT_NONE};

#endif


const kal_uint32 CUSTOM_BL_PLMN_NUM = sizeof(CUSTOM_BL_PLMN)/sizeof(char *);

/*************************************************************************
 * customized PLMNwACT correction
 * 
 * If there is an entry(ies) use the customized value since operator is unable to re-issue correct one
 * For CUSTOM_CORRECT_HPLMN[i], modify CUSTOM_CORRECT_PLMN[i]+CUSTOM_FROM_RAT[i] into 
 * CUSTOM_CORRECT_PLMN[i] + CUSTOM_CORRECT_RAT[i]
 * 
 *************************************************************************/

const char *CUSTOM_CORRECT_HPLMN[] = {"46011F"};

const char *CUSTOM_CORRECT_PLMN[] = {"45403F"};

const nwsel_rat_enum CUSTOM_FROM_RAT[] = {NWSEL_GSM|NWSEL_UMTS};

const nwsel_rat_enum CUSTOM_CORRECT_RAT[] = {NWSEL_UMTS|NWSEL_TD_FDD_LTE};

const kal_uint32 CUSTOM_CORRECT_PLMN_NUM = sizeof(CUSTOM_CORRECT_HPLMN)/sizeof(char *);


/*************************************************************************
 * customized fast roaming blacklist definition
 * 
 * To prevent some special SIM configuartion (like, verdict sequence 00331 00431), or lab test need to fast workaround
 * 
 *   Ex: 
 * - CUSTOM_BL_PLMN[] = {"46001F"} 
 *    CUSTOM_BL_RAT[] = {NWSEL_UMTS} 
 *************************************************************************/
/* not apply the optimization for CMCC customization phone. That is, blacklist won't affect RAT decision when OP01 is on */
const char *CUSTOM_FR_BL_PLMN[] = {"001fff","002fff","003fff","004fff",
                                   "005fff","006fff","007fff","008fff",
                                   "009fff","010fff","011fff","012fff",
                                   "254fff"};
const nwsel_rat_enum CUSTOM_FR_BL_RAT[] = {
    NWSEL_RAT_ANY,NWSEL_RAT_ANY,NWSEL_RAT_ANY,NWSEL_RAT_ANY,
    NWSEL_RAT_ANY,NWSEL_RAT_ANY,NWSEL_RAT_ANY,NWSEL_RAT_ANY,
    NWSEL_RAT_ANY,NWSEL_RAT_ANY,NWSEL_RAT_ANY,NWSEL_RAT_ANY,
    NWSEL_RAT_ANY};

const kal_uint32 CUSTOM_FR_BL_PLMN_NUM = sizeof(CUSTOM_FR_BL_PLMN)/sizeof(char *);


/*************************************************************************
 * customized white list for custom_is_disable_eutran_after_reject
 * 
 * White list that won't be affected by custom_is_disable_eutran_after_reject.
 * 3UK network behavior to exclude from disable EUTRAN mechanism to boost LTE stay rate
 * 1. LTE B20 support IMS but not support CSFB
 * 2. LTE B3 support CSFB, but not support IMS
 * 3. LTE B20 check UE VDP for E-UTRAN, if support IMS accept otherwise reject #15
 *************************************************************************/

/*  If roaming is disable, only specified PLMNs/HPLMN can be registered by UE  */

const char *CUSTOM_EUTRAN_DISABLE_WL_PLMN[] = {"23420F"};

const kal_uint32 CUSTOM_EUTRAN_DISABLE_WL_PLMN_NUM = sizeof(CUSTOM_EUTRAN_DISABLE_WL_PLMN)/sizeof(char *);

/*************************************************************************
 * RAT search order setting
 * 
 * Two orders can be set according to the current location of the UE, in Home country or in Other countries (UE is 
 * roaming). 
 *   NWSEL_CUSTOM_HOME_MCC[] - define the Home country MCC, can be one or more MCCs
 *   custom_rat_order[2][4] - define the rat_order in home country and in other countries
 *************************************************************************/

/* define the Home country MCC, can be one or more MCCs */
/* if HOME MCC is not specified, use Home MCC RAT order in any countries */
const kal_uint32 NWSEL_CUSTOM_HOME_MCC[] = {460,NWSEL_CUSTOM_HOME_MCC_NOT_DEFINED};

const kal_uint32 NWSEL_CUSTOM_HOME_MCC_NUM = sizeof(NWSEL_CUSTOM_HOME_MCC)/sizeof(kal_uint32);

/* Define the RAT search order in Home country (defined by NWSEL_CUSTOM_HOME_MCC) and in Other countries. 
 * Here are some setting reminders:
 * 1. NWSEL_TD_SCDMA and NWSEL_WCDMA should not both exist in the same search order.
 * 2. If NWSEL_TD_LTE and NWSEL_FDD_LTE exist in the same order, they should be listed successively. i.e. the order 
 *    "NWSEL_TD_LTE, NWSEL_TD-SCDMA, NWSEL_FDD_LTE" is NOT allowed
 * 3. NWSEL_RAT_NONE - Indicate the End Point, means "Do not search other RATs" 
 * 4. NWSEL_RAT_ANY - Indicate the End Point, means "Other RATs search order are not restricted" 
 * 5. If NWSEL_TD_FDD_LTE is listed, NWSEL_TD_LTE and NWSEL_FDD_LTE should not be listed in the same search order. 
 *    Vice versa.

   The following are allowed nwsel_rat_enum values:
     {
        NWSEL_RAT_NONE    -->     Indicate the End Point, means "Do not search other RATs"
        NWSEL_GSM
        NWSEL_UMTS        -->     3G FDD, WCDMA 
        NWSEL_TD_SCDMA    -->     3G TD, TD-SCDMA
        NWSEL_FDD_LTE
        NWSEL_TD_LTE
        NWSEL_TD_FDD_LTE  -->     Indicate TD-LTE and FDD-LTE have same priority
        NWSEL_RAT_ANY     -->     Indicate the End Point, means "Other RATs search order are not specified" 
     }
 */

//#elif defined(__OP01__) && defined(__LTE_RAT__)
const nwsel_rat_enum custom_rat_order_op01[NWSEL_RAT_ORDER_NUM][NWSEL_RAT_ENTRY_NUM] = {
    /* Home MCC RAT search order */
    /* If FDD-LTE cell is found, regard the environment as "Abroad" */
    {NWSEL_TD_FDD_LTE, NWSEL_TD_SCDMA, NWSEL_GSM, NWSEL_RAT_NONE},

    /* Abroad/Roaming MCC RAT search order */
    {NWSEL_TD_FDD_LTE, NWSEL_UMTS, NWSEL_GSM, NWSEL_RAT_NONE}
};
//#else

/* only allow customer to modify the order for non-CMCC customize phone */
const nwsel_rat_enum custom_rat_order_def[NWSEL_RAT_ORDER_NUM][NWSEL_RAT_ENTRY_NUM] = {
    /* default - Search order are not specified. NWSEL wil check the previous RPLMN RAT and other factors to decide 
                 proper RAT order */
    /* Home MCC RAT search order */
    {NWSEL_RAT_ANY, NWSEL_RAT_ANY, NWSEL_RAT_ANY, NWSEL_RAT_ANY},

    /* Abroad/Roaming MCC RAT search order */
    {NWSEL_RAT_ANY, NWSEL_RAT_ANY, NWSEL_RAT_ANY, NWSEL_RAT_ANY}
//#endif
};

const nwsel_rat_enum custom_power_on_search_rat[NWSEL_RAT_ENTRY_NUM] = 
    {NWSEL_TD_FDD_LTE, NWSEL_GSM, NWSEL_UMTS, NWSEL_RAT_NONE};
    
/* use for fast roaming optimization (need to turn on by SBP SBP_FULLBAND_RAT_ORDER_ON_CUSTOM_SETTING), called by detecting as roaming */
const nwsel_rat_enum custom_roaming_fullband_rat[NWSEL_RAT_ENTRY_NUM] = 
    {NWSEL_UMTS,NWSEL_TD_FDD_LTE , NWSEL_GSM, NWSEL_RAT_NONE};

// Prefer UMTS to be searched at the end
const nwsel_rat_enum custom_consider_duplex_mode_fullband_rat[NWSEL_RAT_ENTRY_NUM] = 
    {NWSEL_TD_FDD_LTE, NWSEL_GSM, NWSEL_UMTS, NWSEL_RAT_NONE};
/* Add a new array for quick search order */
const nwsel_rat_enum custom_quick_search_rat[NWSEL_RAT_ENTRY_NUM] = 
    {NWSEL_UMTS, NWSEL_GSM, NWSEL_TD_FDD_LTE, NWSEL_RAT_NONE};

/**************************************************************************************
* Define search rat order after inter-rat redirection failure
* Currently only support OP01 project
***************************************************************************************/
const nwsel_rat_enum* custom_irrdt_failure_rat_order[NWSEL_IRRDT_MAX_TYPE];
const nwsel_rat_enum custom_irrdt_failure_rat_order_op01[NWSEL_IRRDT_MAX_TYPE][NWSEL_RAT_ENTRY_NUM] = {
    /* NWSEL_IRRDT_4G3 */
    {NWSEL_UMTS, NWSEL_GSM, NWSEL_TD_FDD_LTE, NWSEL_RAT_ANY},

    /* NWSEL_IRRDT_4G2 */
    {NWSEL_GSM, NWSEL_UMTS, NWSEL_TD_FDD_LTE, NWSEL_RAT_ANY},

    /* NWSEL_IRRDT_3G4 */
    {NWSEL_TD_FDD_LTE, NWSEL_UMTS, NWSEL_GSM, NWSEL_RAT_ANY},

    /* NWSEL_IRRDT_2G4 *//* OP01 doesn't specify rat order for this IRRDT type*/
    {NWSEL_RAT_ANY, NWSEL_RAT_ANY, NWSEL_RAT_ANY, NWSEL_RAT_ANY}
};

/*************************************************************************
*Time unit definition for IVSR guard timer. Please do not change !!
*************************************************************************/
#define IVSR_TICKS_20_SEC    (KAL_TICKS_5_SEC+KAL_TICKS_5_SEC+KAL_TICKS_5_SEC+KAL_TICKS_5_SEC)
#define IVSR_TICKS_40_SEC    (IVSR_TICKS_20_SEC + IVSR_TICKS_20_SEC)
#define IVSR_TICKS_1_MIN     (KAL_TICKS_1_MIN)

/* IVSR guard timer definitions*/
#ifdef __INCREASE_MAX_IVSR_GUARD_TIMER_NUM__
    const kal_uint8 MAX_IVSR_GUARD_TIMER_NUM = 10;
#else
    const kal_uint8 MAX_IVSR_GUARD_TIMER_NUM = 3;
#endif

/*************************************************************************
* IVSR guard timer interval
*************************************************************************/
const kal_uint32 IVSR_GUARD_TIMER_INTERVAL[] =
{
    IVSR_TICKS_20_SEC, IVSR_TICKS_40_SEC, IVSR_TICKS_1_MIN
};
const kal_uint8 MAX_IVSR_GUARD_TIMER_INTERVAL_NUM = sizeof(IVSR_GUARD_TIMER_INTERVAL)/sizeof(kal_uint32);

/*****************************************************************************
* FUNCTION
*  nwsel_custom_config_custom_irrdt_failure_rat_order
* DESCRIPTION
*  This function is used to configure custom_irrdt_failure_rat_order
*  Currently only works in OP01 project.
*
* PARAMETERS
*
* RETURNS
*  NONE
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void nwsel_custom_config_custom_irrdt_failure_rat_order(void)
{
    kal_uint32 i;

    for (i = 0; i < NWSEL_IRRDT_MAX_TYPE; i++)
    {
        custom_irrdt_failure_rat_order[i] = (nwsel_rat_enum*)&custom_irrdt_failure_rat_order_op01[i];
    }
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_search_next_plmn_when_access_class_barred
* DESCRIPTION
*  This function is used to configure whether search next plmn
*  when not test sim and not test mode
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_search_next_plmn_when_access_class_barred(void)
{
    return (nwsel_query_sbp_feature(SBP_DISABLE_PLMN_SEL_WHEN_ACCESS_BARRED,KAL_FALSE)==KAL_FALSE);
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_disable_previous_rplmn_from_nvram
* DESCRIPTION
*  This function is used to configure whether backup previous rplmn from nvram
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_disable_previous_rplmn_from_nvram(void)
{
    return nwsel_query_sbp_feature(SBP_MM_DISABLE_PREVIOUS_RPLMN_FROM_NVRAM,KAL_FALSE);
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_disable_stored_rplmn_from_nvram
* DESCRIPTION
*  This function is used to configure whether to use stored RPLMN from nvram
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_disable_stored_rplmn_from_nvram(void)
{
    return nwsel_query_sbp_feature(SBP_NWSEL_DISABLE_STORED_RPLMN_FROM_NVRAM,KAL_FALSE);
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_is_hpplmn_1st_attempt_enhance
* DESCRIPTION
*  H3G Hutchison Requirement:
*   First BG scan when UE is registered on a VPLMN shall always be 
*   2 min (HPLMN timer =2 min at first BG scan). This implementation shall be applied for 
*   "Power on", "Out Of Service" and "Manual selection" scenarios.
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_is_hpplmn_1st_attempt_enhance(void)
{
    return nwsel_query_sbp_feature(SBP_MM_HPPLMN_1ST_ATTEMPT_ENHANCE,KAL_FALSE);
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_disable_rplmn_from_gloci
* DESCRIPTION
*   Some operator doesn't expect MS will read the RPLMN information from GPRS LOCI.
*   So need an option to switch on/off this feature.
*
* PARAMETERS
*
* RETURNS
*   KAL_TRUE:
*    - MS will not store the RPLMN information from GPRS LOCI.
*   KAL_FALSE:
*    - MS will store the RPLMN information from GPRS LOCI.
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_disable_rplmn_from_gloci(void)
{
    return nwsel_query_sbp_feature(SBP_DISABLE_RPLMN_FROM_GLOCI,KAL_FALSE);
}
/*****************************************************************************
* FUNCTION
*  nwsel_custom_disable_rplmn_from_gloci
* DESCRIPTION
*   Some operator doesn't expect MS will read the RPLMN information from GPRS LOCI.
*   So need an option to switch on/off this feature.
*
* PARAMETERS
*
* RETURNS
*   KAL_TRUE:
*    - MS will not store the RPLMN information from GPRS LOCI.
*   KAL_FALSE:
*    - MS will store the RPLMN information from GPRS LOCI.
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_disable_rplmn_from_epsloci(void)
{
    return nwsel_query_sbp_feature(SBP_DISABLE_RPLMN_FROM_EPSLOCI,KAL_FALSE);
}

/*************************************************************************
 * customized PS only LTE network definition
 * 
 * LTE CDMA netork reject UE with #18 CS DOMAIN NOT AVAILABLE
 *   Ex: CUSTOM_PS_ONLY_PLMN[] = 
 *           {"46692F","46689F"}         
 *************************************************************************/

/*  If roaming is disable, only specified PLMNs/HPLMN can be registered by UE  */

const char *CUSTOM_PS_ONLY_PLMN[] = {"45006F","46011F", /* Adding RJIL PLMNs */
                                     "405840","405854","405855","405856","405857",
                                     "405858","405859","405860","405861","405862",
                                     "405863","405864","405865","405866","405867",
                                     "405868","405869","405870","405871","405872",
                                     "405873","405874", /* Adding Seatel PLMN 45611 */
                                     "45611F", /* Adding Malaysia YES operator 502152 */
                                     "502152", /* Adding Hungary Digi operator 21603*/
                                     "21603F",
                                     INVALID_CUSTOM_WL_PLMN};

const kal_uint32 CUSTOM_PS_ONLY_PLMN_NUM = sizeof(CUSTOM_PS_ONLY_PLMN)/sizeof(char *);

/*************************************************************************
PLMN's to be added are:
1> Network does not support legacy RAT's(2/3G) and UE reported rat does not 
consist LTE
AND
2> Network does not have any roaming agreement in national roaming area

Optimization of not performing a recovery search only applies if UE is in 
Virtual Idle mode
(i.e if data is ongoing on another SIM).
[Side effect]
May cause a slight delay in recovery of UE, but will not impact data 
performance on the other stack
*************************************************************************/

const char *CUSTOM_PLMN_FOR_BLOCKING_SEARCH_IN_VIDLE[] = {"405840","405854","405855","405856","405857","405858","405859","405860",
									"405861","405862","405863","405864","405865","405866","405867","405868",
									"405869","405870","405871","405872","405873","405874",CUSTOM_PLMN_SET_END};


/*****************************************************************************
* FUNCTION
*  nwsel_init_sbp_config
* DESCRIPTION
*  This function is used to configure NWSEL custom setting dynamically by SBP function.
*  This function is executed at NWSEL init stage before NWSEL receive INIT_REQ from RAC.
*
* PARAMETERS
*  NONE
* RETURNS
*  NONE
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void nwsel_init_sbp_config(void)
{
    nwsel_custom_config_ignore_eqplmn_operator_list();
    nwsel_custom_config_hpplmn_search_mcc_list();
    nwsel_trace_rplmn_hpplmn_mcc_list();
    nwsel_custom_config_custom_eq_plmn_list();
    nwsel_custom_config_custom_irrdt_failure_rat_order();
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_trigger_ivsr_after_sim_invalid
* DESCRIPTION
*  When registering failed and entering "invalid SIM" state, decide to trigger IVSR
*  strategy and leave "invalid SIM" state or not
*
* PARAMETERS
*
* RETURNS
*  kal_bool
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_bool nwsel_custom_trigger_ivsr_after_sim_invalid(kal_bool is_registered_before, kal_bool is_trigger_ivsr_needed, kal_bool is_ivsr_after_guard_timer, kal_bool is_test_sim, mm_cause_enum cause)
{
    if ((query_ps_conf_test_mode() != PS_CONF_TEST_NONE) ||
        (is_test_sim == KAL_TRUE))
    {
        return KAL_FALSE;
    }
    
    if((is_registered_before == KAL_TRUE) &&
        nwsel_query_sbp_feature(SBP_ENABLE_MODEM_IVSR,KAL_FALSE) == KAL_TRUE)
    {
        return KAL_TRUE;
    }
    else if((is_trigger_ivsr_needed == KAL_TRUE) &&
             nwsel_query_sbp_feature(SBP_ALWAYS_TRIGGER_IVSR_AFTER_POWER_ON,KAL_FALSE) == KAL_TRUE)
    {
        return KAL_TRUE;
    }
    else if ((is_ivsr_after_guard_timer == KAL_TRUE) &&
              nwsel_query_sbp_feature(SBP_RETRY_IVSR_AFTER_GUARD_TIMER,KAL_FALSE) == KAL_TRUE)
    {
        return KAL_TRUE;
    }
    
    return KAL_FALSE;
}

/*****************************************************************************
* FUNCTION
*  nwsel_custom_get_hpplmn_search_timer_period
* DESCRIPTION
*  Customer needs customizable HPLMN_SEARCH_TIMER value only if SIM_PROVIDED value is 0
*  Retaining the default as 0, but customer can make necessary changes to the 
*  desired value and NWSEL will consider this value only if SIM_PROVIDED value is 0
*
* PARAMETERS
*  NONE
* RETURNS
*  NWSEL_CUSTOM_HPLMN_SEARCH_PERIOD
* GLOBALS AFFECTED
*  None
*****************************************************************************/
kal_uint32 nwsel_custom_get_hpplmn_search_timer_period(void)
{
    return NWSEL_CUSTOM_HPPLMN_SEARCH_PERIOD;
}

/*************************************************************************
 * Customized PLMN List for disabling searching RPLMN RAT first
 * Make sure SBP_CUSTOM_PREFER_RPLMN_RAT is turned on, and add entries as following
 * PLMN on this list which is RPLMN will search from NVRAM prefer RAT, otherwise, from RPLMN RAT.
 * ex: if you want to disable search RPLMN RAT for china CMCC,
 * then you could add "46000F" in this list
 * i.e. CUSTOM_NWSEL_DISABLE_RPLMN_RAT_LIST[] = {"46000F", CUSTOM_DISABLE_RPLMN_RAT_SET_END}
 * NOTE: please add the plmn(specified by the string) before CUSTOM_DISABLE_RPLMN_RAT_SET_END
 *************************************************************************/
const char *CUSTOM_NWSEL_DISABLE_RPLMN_RAT_LIST[] = {CUSTOM_DISABLE_RPLMN_RAT_SET_END};
const kal_uint32 CUSTOM_NWSEL_DISABLE_RPLMN_RAT_NUM = sizeof(CUSTOM_NWSEL_DISABLE_RPLMN_RAT_LIST)/sizeof(char *);

/*************************************************************************
 * Customized MCC List for disabling searching RPLMN RAT first
 * Make sure SBP_CUSTOM_PREFER_RPLMN_RAT is turned on, and add entries as following
 * MCC on this list which is RPLMN will search from NVRAM prefer RAT, otherwise, from RPLMN RAT.
 * ex: if you want to disable search RPLMN RAT for china PLMN,
 * then you could add 460 in this list
 * i.e. CUSTOM_NWSEL_DISABLE_RPLMN_RAT_MCC_LIST[] = {460, CUSTOM_DISABLE_RPLMN_RAT_MCC_SET_END}
 * NOTE: please add the MCC(specified by 3 digit) before CUSTOM_DISABLE_RPLMN_RAT_MCC_SET_END
 *************************************************************************/
const kal_uint32 CUSTOM_NWSEL_DISABLE_RPLMN_RAT_MCC_LIST[] = {CUSTOM_DISABLE_RPLMN_RAT_MCC_SET_END};
const kal_uint32 CUSTOM_NWSEL_DISABLE_RPLMN_RAT_MCC_NUM = sizeof(CUSTOM_NWSEL_DISABLE_RPLMN_RAT_MCC_LIST)/sizeof(kal_uint32);

const char *NWSEL_CUSTOM_INVALID_PLMN_ID_STR = "FFFFFF";
/*****************************************************************************
* FUNCTION
*   nwsel_custom_query_sbp_feature
*
* DESCRIPTION
*   this function is used to query SBP feature controlled by custom with 
*   network PLMN ID or/and home PLMN ID
*
* PARAMETERS
*   simInterface    -   SIM interface
*   feature         -   SBP feature
*   nw_plmn_id_ptr  -   NW PLMN ID, string format, xxxxxF or xxxxxx
*                       NWSEL_CUSTOM_INVALID_PLMN_ID_STR if not suitable cell
*   hplmn_id_ptr    -   first priority home PLMN ID, string format, xxxxxF or xxxxxx
*                       if EHPLMN is present and not empty, it's from EHPLMN[0]
*                       otherwise it's from IMSI.
*                       NWSEL_CUSTOM_INVALID_PLMN_ID_STR if USIM is not inserted or removed
*
* RETURNS
*   NWSEL_CUSTOM_SBP_RESULT_NOT_CHNAGED:
*       SBP is not changed by custom
*   NWSEL_CUSTOM_SBP_RESULT_ENABLED:
*       SBP is enabled by custom
*   NWSEL_CUSTOM_SBP_RESULT_DISABLED:
*       SBP is disabled by custom
*
* GLOBALS AFFECTED
*   NOTE: not all SBP could be controlled by NW PLMN ID
*         You can try with this function. But finally please confirm with MTK 
*         if the SBP can be controlled by NW PLMN ID.
*
*   When hplmn_id is from IMSI, it is the same DSBP, the priority here is 
*   higher than DSBP.
*
*   Some functions which customize SBP in this file could be merged in
*   this function or you can keep the customization in the original functions.
*   But the priority in this function is higher than the original functions.
*   e.g.
*   nwsel_custom_is_display_roaming_hplmn_in_eplmn()
*   nwsel_custom_disable_previous_rplmn_from_nvram()
*   ..., etc
*
*****************************************************************************/
nwsel_custom_sbp_result_enum nwsel_custom_query_sbp_feature
(
    kal_uint8               simInterface,
    sbp_md_feature_enum     feature,
    kal_uint8               *nw_plmn_id_ptr,
    kal_uint8               *hplmn_id_ptr
)
{
    nwsel_custom_sbp_result_enum result = NWSEL_CUSTOM_SBP_RESULT_NOT_CHNAGED;

    // input check
    if (nw_plmn_id_ptr == NULL || hplmn_id_ptr == NULL)
    {
        return NWSEL_CUSTOM_SBP_RESULT_NOT_CHNAGED;
    }
    
    /*
     *  to control SBP feature with explicit purpose only, otherwise plase remain NOT_CHANGED
     */
#if UNIT_TEST // the following is a sample code and for internal UT, please don't modify it
    if (feature == SBP_DISABLE_DISPLAY_ROAMING_HPLMN_IN_EPLMN)
    {
        if (kal_mem_cmp(nw_plmn_id_ptr, "12345", strlen("12345")) == 0)
        {
            if (kal_mem_cmp(hplmn_id_ptr, "12345", strlen("12345")) == 0)
            {
                result = NWSEL_CUSTOM_SBP_RESULT_DISABLED;
            }
        }
    }
#else // else of UNIT_TEST
    if (feature == SBP_DISABLE_DISPLAY_ROAMING_HPLMN_IN_EPLMN)
    {
        /* in India, charging under roaming is more expensive
           it's better to display roaming for inter-circles to let user be aware of this condition
           customer can turn on this SBP if you have other concern . */
        // turn off this SBP to display roaming in India when EHPLMN is in EQPLMN list for 404/405 xxx   
        if (hplmn_id_ptr[0] == '4' && hplmn_id_ptr[1] == '0' && (hplmn_id_ptr[2] == '4' || hplmn_id_ptr[2] == '5'))
        {
            // except for Jio
            if (hplmn_id_ptr[0] == '4' && hplmn_id_ptr[1] == '0' && hplmn_id_ptr[2] == '5' &&
                // 405 840
                ((hplmn_id_ptr[3] == '8' && hplmn_id_ptr[4] == '4' && hplmn_id_ptr[5] == '0') ||
                // 405 854~ 405 874
                  (hplmn_id_ptr[3] == '8' && hplmn_id_ptr[4] == '5' && (hplmn_id_ptr[5] >= '4' && hplmn_id_ptr[5] <= '9')) ||
                  (hplmn_id_ptr[3] == '8' && hplmn_id_ptr[4] == '6' && (hplmn_id_ptr[5] >= '0' && hplmn_id_ptr[5] <= '9')) ||
                  (hplmn_id_ptr[3] == '8' && hplmn_id_ptr[4] == '7' && (hplmn_id_ptr[5] >= '0' && hplmn_id_ptr[5] <= '4')) ||
                  (hplmn_id_ptr[3] == '8' && hplmn_id_ptr[4] == '7')))
            {
                result = NWSEL_CUSTOM_SBP_RESULT_NOT_CHNAGED;
            }
            else
            {
                result = NWSEL_CUSTOM_SBP_RESULT_DISABLED;
            }
        }
    }
#endif // end of UNIT_TEST
    
    return result;
    
}

/* Periodic clear FPLMN timer length */
const kal_uint32 PERIODIC_CLEAR_FPLMN_TIMER_LENGTH = (KAL_TICKS_1_MIN * 60 * 24);
const kal_uint32 SPRINT_PERIODIC_CLEAR_FPLMN_TIMER_LENGTH = (KAL_TICKS_1_MIN * 60 * 24);

const kal_uint8 NWSEL_ECC_SEARCH_DURING_SUSPEND_SEARCH_RETRY_COUNTER_MAX = 1;



