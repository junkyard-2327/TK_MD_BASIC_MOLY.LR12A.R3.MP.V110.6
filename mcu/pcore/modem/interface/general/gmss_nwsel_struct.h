/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  gmss_nwsel_struct.h
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for struct definition between NWSEL and GMSS.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 * 				HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/
#ifndef _GMSS_NWSEL_STRUCT_H
#define _GMSS_NWSEL_STRUCT_H

#include "kal_general_types.h"
#include "l3_inc_enums_public.h"
#include "l3_inc_enums.h"
#include "mcd_l3_inc_struct.h"
#include "ps_public_enum.h"
#include "l3_inc_local.h"
#include "mm_mmi_enums.h"

#ifdef __LTE_RAT__
#include "nvram_data_items.h"
#include "nvram_editor_data_item.h"
#endif

#ifdef __IMS_SUPPORT__
#include "ims_common_def.h"
#include "ims_interface_md.h"
#endif /* __IMS_SUPPORT__ */

#include "rsvas_enum.h"
#include "gmss_public.h"
#include "rac_gmss_struct.h"
#include "nwsel_eval_struct.h"
#include "gmss_cval_struct.h"

#include "nvram_editor_data_item.h"
#include "sim_ps_struct.h"
#include "sim_public_enum_public.h"
#include "mmss_def.h"
#include "nvram_struct.h"
#include "rac2l4c_struct.h"
#include "l3_inc_enums.h"
#include "l4c2rac_struct.h"
#include "rac2l4c_struct.h"

/* GMSS -> NWSEL */
typedef rac_gmss_init_req_struct gmss_nwsel_init_req_struct;
typedef rac_gmss_custom_plmn_list_update_req_struct gmss_nwsel_custom_plmn_list_update_req_struct;
typedef rac_gmss_get_custom_plmn_list_req_struct gmss_nwsel_get_custom_plmn_list_req_struct;
typedef rac_gmss_get_custom_plmn_list_cnf_struct gmss_nwsel_get_custom_plmn_list_cnf_struct;
typedef rac_gmss_uemode_param_update_req_struct gmss_nwsel_uemode_param_update_req_struct;
typedef rac_gmss_volte_status_update_req_struct gmss_nwsel_volte_status_update_req_struct;
typedef rac_gmss_call_status_req_struct gmss_nwsel_call_status_ind_struct;

typedef rac_gmss_set_plmn_barring_timer_req_struct gmss_nwsel_set_plmn_barring_timer_req_struct;
typedef rac_gmss_set_plmn_barring_timer_cnf_struct gmss_nwsel_set_plmn_barring_timer_cnf_struct;
typedef rac_gmss_get_plmn_barring_timer_req_struct gmss_nwsel_get_plmn_barring_timer_req_struct;
typedef rac_gmss_get_plmn_barring_timer_cnf_struct gmss_nwsel_get_plmn_barring_timer_cnf_struct;
typedef rac_gmss_ims_timer_status_update_req_struct gmss_nwsel_ims_timer_status_update_req_struct;
typedef rac_gmss_abort_enwsel_search_req_struct gmss_nwsel_abort_enwsel_search_req_struct;
typedef rac_gmss_ims_call_end_status_ind_struct gmss_nwsel_ims_call_end_status_ind_struct;
typedef rac_gmss_set_ims_roaming_config_req_struct gmss_nwsel_set_ims_roaming_config_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    plmn_selection_mode_enum plmn_sel_mode;
} gmss_nwsel_sel_mode_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    domain_id_enum attach_type;   /* CS-only, PS-only or both CS/PS*/
    kal_uint8 att_id;        /* Johnny: 3G RAC, for attach_req and detach_req using */
    mm_user_search_type_enum search_type;   //mm_user_search_type_enum
#ifdef __SGLTE__
    kal_bool mmdc_ps_attach;
    attach_cause_enum attach_cause;
#endif
} gmss_nwsel_attach_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    domain_id_enum detach_type; /* CS-only, PS-only or both CS/PS */
    kal_bool power_off;   /* mobile shut down or not */
    kal_uint8 att_id;      /* Johnny: 3G RAC, for attach_req and detach_req using */
    l4c_rac_detach_cause_enum detach_cause;
} gmss_nwsel_detach_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    plmn_reselection_enum plmn_search_mode;       /* plmn_reselection_enum */
    plmn_id_rat_struct selected_plmn; /* Selected PLMN */
    kal_bool is_manual_csg_sel;
    kal_uint32 csg_id;
    rat_enum prefer_rat;   //  0:default ,  1:GSM ,   2:UMTS
    kal_bool from_l4c;
    kal_uint32 factory_mode_arfcn; //0xFFFF means invalid arfcn, /* 20081110 mtk00714, for fast camp on test machine */
} gmss_nwsel_rac_plmn_search_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    plmn_id_rat_struct plmn_id_rat;
} gmss_nwsel_rac_csg_list_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_enum rat_mode;              /* RATCM_RAT_ENUM*/
    rat_enum reported_rat;
    irat_system_type_enum c2k_mode;
    kal_bool is_rf_on;
} gmss_nwsel_set_rat_mode_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    rfoff_cause_enum rfoff_cause;
} gmss_nwsel_rfoff_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_supporting_roaming;
    kal_bool disable_international_roaming_support;
    kal_bool disable_national_roaming_support;
    kal_bool disable_hhplmn_search_support;
} gmss_nwsel_set_roaming_mode_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_enum  prefer_rat;
}gmss_nwsel_set_prefer_rat_req_struct;

/* NWSEL -> GMSS */

typedef nwsel_eval_c2k_csfb_start_ind_struct gmss_nwsel_c2k_csfb_start_ind_struct;
typedef nwsel_eval_c2k_csfb_est_ind_struct gmss_nwsel_c2k_csfb_est_ind_struct;
typedef nwsel_eval_c2k_csfb_stop_ind_struct gmss_nwsel_c2k_csfb_stop_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    proc_status_enum status;          /* proc_status_enum */
    mm_cause_enum cause;           /* mm_cause_enum */
    kal_bool is_on_hplmn;
    cell_info_and_rat_struct cell_info;
} gmss_nwsel_rac_plmn_search_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    proc_status_enum status;         /* proc_status_enum */
    mm_cause_enum  cause;          /* mm_cause_enum */
    kal_uint8 num_of_hplmn;
    rac_plmn_list_struct plmn_list;
    list_ind_source_enum source;
    prio_class_enum gmss_class_list[RAC_MAX_NUM_LISTED_PLMNS];
    kal_bool is_C2K_sib_scheduled;
    freq_scan_output_struct freq_scan_output;
} gmss_nwsel_rac_plmn_list_cnf_struct;

typedef gmss_nwsel_rac_plmn_list_cnf_struct gmss_nwsel_plmn_list_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 susp_id;
    susp_resu_source_enum target;
} gmss_nwsel_suspend_status_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    proc_status_enum status;
    mm_cause_enum cause;
    rac_csg_list_struct csg_list;
} gmss_nwsel_rac_csg_list_cnf_struct;

typedef struct {
    kal_uint8 ref_count;
    kal_uint16 msg_len;
    proc_status_enum status;         /* proc_status_enum */
    mm_cause_enum cause;          /* mm_cause_enum */
} gmss_nwsel_set_rat_mode_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_not_suspend; /* indicate if is_searching = TRUE is due to Gemini suspend */
    kal_bool is_update_is_searching; /* if TRUE, RAC can check is_searching flag */
    kal_bool is_searching;
    kal_bool is_camp_on_cell; /* if is_searching = FALSE && is_camp_on_cell = FALSE, then RAC update to L4C; 
                                 else, ignore the is_searching flag.  */
    kal_bool is_on_hplmn;
    kal_bool is_update_active_rat;
    rat_enum active_rat;
//#ifdef __KOR_CUSTOMIZATION__
    plmn_id_struct rplmn;     /* Get RPLMN */
//#endif
} gmss_nwsel_plmn_status_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    nwsel_ims_service_enum service_type;
    kal_bool is_t311_expire;  /* RRC connection release due to RRC T311 timer expire */
} gmss_nwsel_ims_service_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    irat_type_enum irat_type;
    rat_type_enum source_rat;
    rat_type_enum target_rat;
    ho_from_lte_type_enum ir_ho_type;
} gmss_nwsel_rat_change_start_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    irat_type_enum irat_type;
    irat_result_enum irat_result;
    rat_type_enum source_rat;
    rat_type_enum target_rat;
} gmss_nwsel_rat_change_finish_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool enter_cause18_plmn;
} gmss_nwsel_cs_domain_availability_ind_struct;

#ifdef __SGLTE__
typedef struct 
{
    LOCAL_PARA_HDR
    mmdc_mode_enum mode; 
} gmss_nwsel_mmdc_mode_update_req_struct;

typedef struct 
{
    LOCAL_PARA_HDR
    rat_enum  cell_rat;
    mmdc_camp_on_status_enum  cell_status;
    kal_bool  is_immediately_switch;
    mmdc_psd_switch_cause_enum cause;
    kal_bool  is_2g_cell_support_ps;      
} gmss_nwsel_mmdc_camp_on_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    mmdc_recovery_search_enum trigger_type;
} gmss_nwsel_mmdc_recovery_search_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    plmn_search_abort_cause_enum cause;
} gmss_nwsel_plmn_search_abort_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    plmn_search_abort_proc_status_enum status;          /* proc_status_enum */
} gmss_nwsel_plmn_search_abort_cnf_struct;

typedef struct
{
    LOCAL_PARA_HDR
    rat_enum cell_rat;
} gmss_nwsel_mmdc_plmn_loss_ind_struct;
#endif /* __SGLTE__ */

typedef struct {
    LOCAL_PARA_HDR
    susp_resu_action_enum action;
    susp_resu_result_enum result;
    susp_resu_source_enum target;
} gmss_nwsel_susp_resu_update_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    susp_resu_mode_enum  mode;
    susp_resu_action_enum action;
    kal_uint8            susp_id;
    susp_resu_source_enum source;
} gmss_nwsel_susp_resu_update_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 timer_interval[MAX_RECOVERY_TIMER_NUM];
} gmss_nwsel_set_recovery_search_timer_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 timer_interval[MAX_RECOVERY_TIMER_NUM];
} gmss_nwsel_get_recovery_search_timer_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool result;
} gmss_nwsel_set_recovery_search_timer_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    plmn_id_struct plmn;
    rat_enum rat;
    kal_uint8 ara_start[2];
    kal_uint8 ara_end[2];
}gmss_nwsel_aral_update_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    voice_domain_preference_enum utran_voice_domain_preference;
} gmss_nwsel_set_utran_voice_domain_preference_req_struct;

typedef rac_gmss_data_service_status_update_req_struct gmss_nwsel_data_service_status_update_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 trx_id;

    /* The MMSS search type. 
    */
    mmss_search_type_enum   mmss_search_type;

    /* The search RAT, only valid for MMSS_SEARCH_NORMAL. 
    */
    rat_enum rat;

    /* The search prio_class, only valid for MMSS_SEARCH_NORMAL.
    */
    prio_class_enum gmss_class;

    /* The search duplex type.
    */
    lte_duplex_type_enum duplex_type; 

    /* The search target's MCC. NWSEL will ignore PLMNs not in this MCC.
    ** Only mcc1, mcc2, mcc3 fields are valid.
    ** If the value are all 0x0F, it means no MCC restriction.
    **  Note: This field only valid for MMSS_SEARCH_NORMAL.
    */
    plmn_id_struct mcc;

    /* scan type for fast roaming.
    */
    scan_type_enum          scan_type;
    
    /* ims emergency cell required controlled by GMSS
    */
    kal_bool is_ims_emergency_required;

    /* The MMSS search list(ie. MRU, RAL).
    */
    mmss_3gpp_list_struct   mmss_list;

    /* Search type, e.g stored ,quick or normal.
    */
    gmss_search_type_enum gmss_search_type;
    
    kal_bool is_srlte;
    
    // is first search after power-on
    kal_bool is_power_on;

} gmss_nwsel_plmn_search_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 trx_id;
    proc_status_enum proc_status;
    rat_enum rat;
    prio_class_enum gmss_class;
    mm_cause_enum proc_cause;
    mm_cause_enum nw_mm_cause;
    esm_cause_enum esm_cause;
} gmss_nwsel_plmn_search_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_enum rat;
    lte_duplex_type_enum duplex_type;
    plmn_id_struct mcc; /* only mcc1, mcc2, mcc3 are valid, for NWSEL to ignore PLMNs not in this MCC */
    prio_class_enum quick_list_class; /* Home or PREF: quick list; others: normal list*/
    scan_type_enum          scan_type;
    kal_bool is_sniff_like_list;
} gmss_nwsel_plmn_list_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_bool is_user_plmn_list_ongoing;
} gmss_nwsel_plmn_list_status_update_req_struct;

typedef rac_gmss_plmn_list_req_struct gmss_nwsel_rac_plmn_list_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    plmn_id_struct mcc; /* only mcc1, mcc2, mcc3 are valid, for NWSEL to ignore PLMNs not in this MCC */
    prio_class_enum quick_list_class; /* Home or PREF: quick list; others: normal list*/
    gmss_rat_enum c2k_ps_rat; /* 1xRTT or HRPD */
} gmss_nwsel_c2k_normal_service_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    proc_status_enum proc_status;
    prio_class_enum gmss_class;     // Only count plmn with suitable cell.
    mm_cause_enum cause;
    rac_plmn_list_struct plmn_list; // All available plmn including forbidden and may_suitable_cell_exist=FALSE.
    prio_class_enum gmss_class_list[RAC_MAX_NUM_LISTED_PLMNS];     //mapping to plmn_list.plmn_id_rat[RAC_MAX_NUM_LISTED_PLMNS]
} gmss_nwsel_plmn_list_cnf_struct;

#if 0   /* no local_para */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#ifdef __GEMINI__
typedef struct {
    LOCAL_PARA_HDR
    as_suspend_mode_reason_enum cause;
} gmss_nwsel_suspend_ind_struct;

#ifdef __GEMINI_MONITOR_PAGE_DURING_TRANSFER__
typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_virtual_idle_mode;
} gmss_nwsel_resume_ind_struct;
#endif /* __GEMINI_MONITOR_PAGE_DURING_TRANSFER__ */

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_virtual_idle_mode;
} gmss_nwsel_virtual_mode_ind_struct;
#endif /* __GEMINI__ */

typedef struct {
    LOCAL_PARA_HDR
    mm_cause_enum cause;        /* FORBIDDEN_PLMN for limited service; NO_COVERAGE for no coverage */
    plmn_id_rat_struct plmn_id;
    kal_bool immediate_duplex_mode_change;
} gmss_nwsel_out_of_service_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    prio_class_enum gmss_class;
    rat_enum rat;
} gmss_nwsel_class_rat_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    nwsel_event_type_enum event;
} gmss_nwsel_event_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_controlled_by_gmss;
} gmss_nwsel_gmss_status_update_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_ir_search;
    irat_type_enum irat_type;
} gmss_nwsel_l2c_transfer_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    irat_type_enum irat_type;       
    c2k_irat_attach_result_enum result;
} gmss_nwsel_c2k_irat_complete_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    c2k_irat_attach_result_enum  attach_result;
    kal_bool                     is_attach_req_sent;
    emm_cause_enum               emm_cause;
    esm_cause_enum               esm_cause;
} gmss_nwsel_c2k_irat_attach_result_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    rat_enum rat;
} gmss_nwsel_signal_appear_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    nvram_gmss_data_struct gmss_data;
    //Use access_id = 0 to ignore NVRAM_WRITE_CNF
    //    access_id = 0x10~0x1f to wait NVRAM_WRITE_CNF of NVRAM_EF_NWSEL_DATA_LID
    kal_uint8 access_id;
} gmss_nwsel_nvram_write_req_struct;

typedef nvram_write_cnf_struct gmss_nwsel_nvram_write_cnf_struct;

typedef struct
{
    LOCAL_PARA_HDR
    prio_class_enum prio_class;
    rat_enum rat;               /* used to notify nwsel mspl rat when suspend/resume */
} gmss_nwsel_prio_class_update_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 ef_imsi[9];
    kal_bool is_valid_ef_loci;
    kal_uint8 ef_loci[11];
    kal_bool is_valid_ef_gloci;
    kal_uint8 ef_gloci[14];
    kal_bool is_valid_ef_epsloci;
    kal_uint8 ef_epsloci[LEN_OF_EPSLOCI];
    kal_uint8 ef_hplmn_time;
    /* Forbidden PLMN */
    kal_bool is_valid_ef_fplmn;
    kal_uint16 num_of_fplmn;
    kal_uint8 *ef_fplmn_ptr;
    /* PLMN selector*/
    kal_uint16 no_plmnsel_data;
    kal_uint8 *plmnsel_data;    /* Stored in SMU, and SMU will free it when it's updated */
    /* user PLMN */
    kal_uint16 no_uplmn_data;
    kal_uint8 *uplmn_data;      /* Stored in SMU, and SMU will free it when it's updated */
    /* operator PLMN */
    kal_uint16 no_oplmn_data;
    kal_uint8 *oplmn_data;      /* Stored in SMU, and SMU will free it when it's updated */
    /* HPLMN */
    kal_uint16 no_hplmn_data;
    kal_uint8 *hplmn_data;      /* Stored in SMU, and SMU will free it when it's updated */
    /* Acting HPLMN */
    kal_bool is_valid_ef_acting_hplmn;
    kal_uint8 ef_acting_hplmn[3]; 
    kal_bool is_usim;
    /* Equivalent Home PLMN */
    kal_bool is_valid_ef_ehplmn; 
    kal_uint8 num_of_ehplmn;
    kal_uint8 ef_ehplmn[MAX_EHPLMN_EF_LEN];
    /* EHPLMN Presentation Indication*/
    kal_bool is_valid_ef_ehplmnpi;
    kal_uint8 ef_ehplmnpi;
    /* Last RPLMN Selection Indication*/
    kal_bool is_valid_ef_lrplmnsi;
    kal_uint8 ef_lrplmnsi;
    kal_uint8 mnc_length;
    kal_bool is_valid_cdma_imsi_m;
    kal_uint8 cdma_imsi_m[10];
    /* MTC nas configure */
    kal_uint16 no_nasconfig_data;   /** Zero means invalid. */
    kal_uint8 *nasconfig_data;     
    kal_uint8 trans_id;          /* Used by DSBP_RECONFIG's users. Use 1~255 in order for each SIM task. */ 
    kal_bool is_rmode_changed;
}gmss_nwsel_sim_ready_req_struct;

typedef sim_error_ind_struct gmss_nwsel_sim_error_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    act_sim_enum  active_sim;
} gmss_nwsel_active_sim_info_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool set_eas_active; /* when L2C failed, need to set LTE as active RAT again */
    kal_bool force_success;  /* force success even SIM2 is in call */
} gmss_nwsel_set_lte_active_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    irat_result_enum irat_result;      // only IR_RESULT_SUCCESS and IR_RESULT_REJECT are valid
} gmss_nwsel_set_lte_active_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 trx_id;
    kal_uint8 rat_num;
    rat_enum rat[MAX_MCC_SEARCH_RAT_NUM];
    gmss_search_type_enum gmss_search_type;
    kal_bool is_power_on;    // is first search after power-on
} gmss_nwsel_mcc_search_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 trx_id;
    proc_status_enum proc_status;
    kal_uint8 plmn_count;
    plmn_id_rat_struct plmn_id_rat[RAC_MAX_NUM_LISTED_PLMNS];
} gmss_nwsel_mcc_search_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    plmn_id_struct plmn_id;
} gmss_nwsel_disable_eutran_req_struct;

typedef l4crac_nw_reg_status_ind_struct gmss_nwsel_reg_status_ind_struct;

typedef struct {
    LOCAL_PARA_HDR 
    kal_bool data_enabled_setting;
    kal_bool data_roaming_setting;
} gmss_nwsel_roaming_data_config_req_struct;

typedef struct {
    LOCAL_PARA_HDR

    kal_bool              is_sim_ready;
    kal_uint8             trx_id;

    // HOME+EHOME PLMN
    // If num_of_ehplmn > 4(MAX_NUM_HPLMN), fill MAX_NUM_HPLMN at most
    // num_of_ehplmn will be the number in this message
    // is_remaining_ehplmn indicates the last ehplmn or not
    kal_bool              is_remaining_ehplmn;
    kal_uint16            num_of_ehplmn; 
    plmn_id_rat_struct    ehplmn[PLMN_INFO_MAX_NUM_HPLMN];

    // PREFER PLMN
    // If num_of_uplmn > 32(NWSEL_MAX_NUM_PLMNS), fill NWSEL_MAX_NUM_PLMNS PLMN at most.
    // num_of_uplmn will be the number in this message
    // is_remaining_uplmn indicates the last uplmn or not
    kal_bool              is_remaining_uplmn;
    kal_uint16            num_of_uplmn; 
    plmn_id_rat_struct    uplmn[NWSEL_MAX_NUM_PLMNS];  

    // If num_of_oplmn > 32(NWSEL_MAX_NUM_PLMNS), fill NWSEL_MAX_NUM_PLMNS PLMN at most.
    // num_of_oplmn will be the number in this message
    // is_remaining_oplmn indicates the last oplmn or not
    kal_bool              is_remaining_oplmn;
    kal_uint16            num_of_oplmn;
    plmn_id_rat_struct    oplmn[NWSEL_MAX_NUM_PLMNS];
} gmss_nwsel_plmn_info_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    umts_duplex_mode_type   source_umts_duplex_mode;
    umts_duplex_mode_type   target_umts_duplex_mode;
    lte_duplex_mode_type    source_lte_duplex_mode;
    lte_duplex_mode_type    target_lte_duplex_mode;
    mode_switch_cause_enum  cause;
    plmn_id_rat_struct      plmn_id_rat; // only valid when mode_switch_cause == MODE_SWITCH_PLMN_CHANGE
                                         // if rat is C2K, only MCC part is valid
} gmss_nwsel_duplex_mode_change_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    mode_switch_cause_enum  cause;
} gmss_nwsel_global_mode_change_start_req_struct;

typedef struct
{
    LOCAL_PARA_HDR 
    kal_bool voice_over_ims_ongoing; 
} gmss_nwsel_ims_call_info_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_enum               rat;
    plmn_id_struct         plmn_id;
} gmss_nwsel_set_aux_plmn_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    set_aux_plmn_result_enum  result;
} gmss_nwsel_set_aux_plmn_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_enum               rat;   
    plmn_id_struct         plmn_id;
    kal_uint16             arfcn;
    kal_uint8              requested_band;
} gmss_nwsel_set_mru_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    set_mru_result_enum result;  
} gmss_nwsel_set_mru_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_attach_needed;
} gmss_nwsel_rat_change_success_notify_req_struct;

/* NOTE: this primitive need to report in LWCG mode and even GWL only mode */
typedef struct {
    LOCAL_PARA_HDR
    mmss_gwl_rec_type        new_rec;
        /**< the latest camping record  */

    kal_bool                 is_registered;
        /**< indicate if the record is registered or not  */
} gmss_nwsel_camping_info_ind_struct;

// new primitive for AS IRAT stage 1 success
typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_attach_needed;
} gmss_nwsel_irat_c2l_success_notify_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    plmn_based_timer_enum timer_type;
    timer_status_enum timer_status;
    plmn_id_struct target_plmn;
    plmn_restrict_additional_information_enum event;
} gmss_nwsel_plmn_restriction_change_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8  trx_id;
    kal_uint16 last_idx_of_ehplmn;
    kal_uint16 last_idx_of_oplmn;
    kal_uint16 last_idx_of_uplmn;
} gmss_nwsel_plmn_info_rsp_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_enum rat;
} gmss_nwsel_set_first_camp_on_prefer_rat_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_bool                        deactivate_for_irat;
} gmss_nwsel_deactivate_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_bool  bEvdoEnterConnection;  /* TRUE, means EVDO has been in PS connection state; else, EVDO has been in idle state. */
} gmss_nwsel_evdo_ps_connection_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_bool  b1xRttEnterConnection;  /* TRUE, means 1xRTT has been in PS connection state; else, 1xRTT has been in idle state. */
} gmss_nwsel_1xrtt_ps_connection_status_ind_struct;

typedef struct 
{
    LOCAL_PARA_HDR
    hvolte_mode_enum    source_hvolte_mode;            /** indicate original hvolte mode */ // enum defined in ims_common_def.h
    hvolte_mode_enum    target_hvolte_mode;            /** indicate source hvolte mode */ // enum defined in ims_common_def.h
    kal_bool            is_silent_redial_and_call_ongoing;
} gmss_nwsel_hvolte_mode_change_req_struct;

#ifdef __NWSEL_QUICK_SEARCH_FOR_ROAMING__
typedef l4crac_high_prio_search_timer_config_req_struct gmss_nwsel_high_prio_search_timer_config_req_struct;
#endif

typedef struct {
    LOCAL_PARA_HDR
    emc_bar_type_enum     emc_bar_type;                  /*cell bar emergency call, or cell already reported by L4 */ 
    rat_enum              rat;                           /* only valid when emc_bar_type !=  EMC_BAR_TYPE_NONE */
    plmn_id_struct        plmn_id;                       /* only valid when emc_bar_type !=  EMC_BAR_TYPE_NONE */
    kal_uint16            band;                          /* only valid when emc_bar_type !=  EMC_BAR_TYPE_NONE */
} gmss_nwsel_emc_bar_network_req_struct;

//#ifdef __KOR_CUSTOMIZATION__
typedef struct {
    LOCAL_PARA_HDR
    plmn_id_struct rplmn;    /* Get RPLMN */
} gmss_nwsel_rplmn_ind_struct;
//#endif

typedef l4crac_fplmn_action_req_struct gmss_nwsel_fplmn_action_req_struct;

typedef l4crac_nw_reg_rej_ind_struct gmss_nwsel_nw_reg_rej_ind_struct;

typedef l4crac_plmn_found_ind_struct gmss_nwsel_plmn_found_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    recover_cause_enum     cause;
} gmss_nwsel_rac_invalid_sim_recover_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_type_enum source_rat;
    rat_type_enum target_rat;
} gmss_nwsel_gmss_irat_start_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_type_enum source_rat;
    rat_type_enum target_rat;
} gmss_nwsel_gmss_irat_finish_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_ims_support;
} gmss_nwsel_ims_vops_support_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR 
    ims_special_event_enum          ims_event;
    kal_uint16                      sip_cause;
} gmss_nwsel_ims_reg_status_update_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    rat_enum disable_rat;
} gmss_nwsel_rat_disable_config_req_struct;

typedef rac_gmss_data_allow_req_struct gmss_nwsel_data_allow_req_struct;

typedef gmss_cval_send_dan_sms_ind_struct gmss_nwsel_send_dan_sms_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_bool is_invalid;
} gmss_nwsel_illegal_me_ind_struct;

#if defined(__LTE_RAT__) && (defined(__GSM_RAT__) || defined(__UMTS_RAT__)) 
typedef nwsel_eval_power_on_protection_req_struct gmss_nwsel_power_on_protection_req_struct;
#endif

#endif
