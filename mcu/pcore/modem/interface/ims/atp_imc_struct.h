/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 *==============================================================================
 * 				HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/

#ifndef _ATP_IMC_STRUCT_H
#define _ATP_IMC_STRUCT_H

#include "l3_inc_local.h"
#include "l3_inc_enums.h"
#include "ps_public_enum.h"
#include "sim_public_enum.h"
#include "ims_common_def.h"
#include "ims_interface_md.h"

typedef enum 
{
    IMS_IRAT_STATUS_IDLE = 0,
    IMS_IRAT_STATUS_FROM_4_TO_2,
    IMS_IRAT_STATUS_FROM_4_TO_3,
    IMS_IRAT_STATUS_FROM_2_TO_4,
    IMS_IRAT_STATUS_FROM_3_TO_4,
    IMS_IRAT_STATUS_FROM_4_TO_23,
    IMS_IRAT_STATUS_FROM_23_TO_4
} ims_irat_status_enum;

typedef enum 
{
    IMS_CS_CALL_START = 0,
    IMS_CS_CALL_END,
    IMS_CS_CALL_OTHERS,
} ims_cs_call_status_enum;

typedef enum 
{
    VOICE_DOMAIN_STATUS_START = 0,
    VOICE_DOMAIN_STATUS_STOP
}voice_domain_status_enum;

typedef enum 
{
    IMS_1X_CALL_END = 0,
    IMS_1X_CALL_START,
    IMS_1X_CALL_OTHERS,
} ims_1x_call_status_enum;

/*************************/
/* IMS Registration enum */
/*************************/
typedef enum {
    IMS_VOPS_NOT_SUPPORTED = 0,
    IMS_VOPS_SUPPORTED
} vops_enum;

typedef enum {
    IMS_TYPE_UNKNOWN = 0,
    IMS_TYPE_H_PLMN,
    IMS_TYPE_V_PLMN
} plmn_type_enum;

// mirror from rmmi_reg_state_enum and nas_reg_status_enum @/mcu/modem/interface/ims/vdm_atp_struct.h
typedef enum 
{
   NAS_PS_REG_STATUS_NOT_REGISTERED = 0,
   NAS_PS_REG_STATUS_REGISTERED_HOME,
   NAS_PS_REG_STATUS_NOT_REGISTERED_SEARCHING,
   NAS_PS_REG_STATUS_REG_DENIED,   
   NAS_PS_REG_STATUS_OUT_OF_COVERAGE,
   NAS_PS_REG_STATUS_REGISTERED_ROAMING,
   NAS_PS_REG_STATUS_SMS_ONLY_HOME,
   NAS_PS_REG_STATUS_SMS_ONLY_ROAMING,
   NAS_PS_REG_STATUS_EMERGENCY_ONLY,
   NAS_PS_REG_STATUS_CSFB_NOT_PREFERRED_HOME,
   NAS_PS_REG_STATUS_CSFB_NOT_PREFERRED_ROAMING
} nas_ps_reg_status_enum;

typedef enum 
{
    WIFI_STATE_OFF = 0,
    WIFI_STATE_ON
}wifi_state_enum;

typedef enum 
{
    WIFI_STATE_CAUSE_GENERAL = 0,
    WIFI_STATE_CAUSE_UI_DISABLE,
    WIFI_STATE_CAUSE_MAX
}wifi_state_cause_enum;

typedef enum 
{
    WIFI_STATE_TARGET_RAN_UNKNOWN = 0,
	WIFI_STATE_TARGET_RAN_3GPP    = 1,
    WIFI_STATE_TARGET_RAN_WIFI    = 2,
    WIFI_STATE_TARGET_RAN_NONE    = 254,
    WIFI_STATE_TARGET_RAN_MAX     = 255
}wifi_state_target_ran_enum;

typedef enum 
{
    IMS_DEREG_CAUSE_BY_NONE = 0,
    IMS_DEREG_CAUSE_BY_DATA_DEATTACH,
    IMS_DEREG_CAUSE_BY_SS_CONFIG,
    IMS_DEREG_CAUSE_BY_IMS_RECONFIG,
    IMS_DEREG_CAUSE_BY_RDS_CONFIG,
    IMS_DEREG_CAUSE_BY_IMSM,
    IMS_DEREG_CAUSE_BY_IMSM_REFRESH,
    IMC_DEREG_CAUSE_BY_MAX
}ims_dereg_cause_by_enum;

typedef enum
{
    IMS_RF_OFF_TYPE_UNSPEC = 0,
    IMS_RF_OFF_TYPE_EFUN = 1,
    IMS_RF_OFF_TYPE_CFUN = 2
}ims_rf_off_type_enum;

typedef enum 
{
    ECBM_STATE_STOP  = 0,
    ECBM_STATE_START = 1
}ecbm_state_enum;

typedef enum 
{
    ECBM_CAUSE_TIMER_EXPIRED = 0,
    ECBM_CAUSE_ANOTHER_CALL  = 1,
    ECBM_CAUSE_URC_TO_AP     = 2, //IMC ignore when state is STOP
}ecbm_cause_enum;

#if defined (__GEMINI__)
typedef enum {
    IMS_SIM_PS_NORMAL = 0,
    IMS_SIM_PS_SUSPENDED
} ims_sim_ps_state_enum;
#endif

typedef enum {
    ATP_EGMC_OP_QUERY = 0,
    ATP_EGMC_OP_SET,
}  atp_egmc_op_enum;
/*
* This enum only use for unblocking AT+ECCTRL to indicate AP should wait for network's response.
* This enum values should be aligned with ims_cc_result_enum, using unused value of ims_cc_result_enum.
*/
typedef enum{
    WAITING_FOR_NW_RESPONSE = -128,
}CALL_CONTROL_PROVISIONAL_RESULT;

typedef enum{
    ATP_IMC_DRP_FLUSH_NVRAM = 0,
    ATP_IMC_DRP_DUMP_TO_NVRAM,
}atp_imc_drp_enum;

typedef struct {  
    LOCAL_PARA_HDR 
    ims_result_code_enum result;
    ims_err_id_enum      err_id;
} atp_imc_common_at_rsp_struct;
typedef atp_imc_common_at_rsp_struct atp_imc_common_at_cnf_struct;
/*******************************/
/* IMS Registration interface  */
/*******************************/
/*
 * Description
 *  - the primitive is used for PS to notify IMC that the operation modes for collecting
 *  - six conditions which mentioned in TS24.229 Annex L3.1.2.
 * Direction
 *	- PS -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
    ue_mode_enum ue_mode_op;
} atp_imc_ue_mode_update_req_struct;

/*
 * Description
 *  - the primitive is used for PS to notify IMC that UE is attached to NW or not, and IMSVoPS indicator
 *  - six conditions which mentioned in TS24.229 Annex L3.1.2.
 * Direction
 *	- PS -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
#if 0
/* under construction !*/
#endif
    vops_enum ims_vops;
} atp_imc_imsvops_notification_req_struct;

/*
 * Description
 *  - the primitive is used for PS to notify IMC rat_type, cell_id, PLMN_type
 * Direction
 *	- PS -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_rat_type_enum rat_type;
    kal_uint32 cell_id;
    cell_service_enum cell_service;
    plmn_id_struct plmn_id;
    plmn_type_enum plmn_type;
    kal_uint8 la_code[2];
    kal_uint8 ta_code[2];
    kal_bool limited_service_emc_support;
    domain_id_enum domain;
    kal_bool is_empty_cell;
} atp_imc_cell_info_update_req_struct;

/*
 * Description
 *  - the primitive is used for IMC identifing core network is support Emergency Bearer Service or not
 * Direction
 *	- PS -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_emb_s1_support;
} atp_imc_emb_s1_supp_req_struct;

/*
 * Description
 *  - the primitive is used for PS to notify IMC to do
 *  -  1. IMS de-registration
 *  -  2. Release PDN/signaling bearer and media bearer
 * Direction
 *	- PS -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_dereg_cause_enum reason;
    ims_rf_off_type_enum  rf_off_type;    
    rfoff_cause_enum rf_off_cause;
} atp_imc_power_off_req_struct;

/**
 * Description
 *  - the primitive is used for NAS to notify IMC of the SIM Invalid event
 *  - PS -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
    plmn_id_struct  plmn_id;
    kal_bool        is_cs_invalid;
    kal_bool        is_ps_invalid;
    kal_uint32      cause;
} atp_imc_sim_invalid_req_struct;

/*
 * Description
 *  - the primitive is used for NAS to notify IMC gemini sim suspended state.
 * Direction
 *  - PS -> IMC
 */
#if defined (__GEMINI__)
typedef struct {
    LOCAL_PARA_HDR
    ims_sim_ps_state_enum ims_sim_ps_state;
} atp_imc_sim_ps_state_ind_struct;
#endif

/*
 * Description
 *  - the primitive is used for IMC to notify PS that IMS registration start.
 * Direction
 *  - IMC -> PS
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_reg_type_enum  reg_type;  //IMS_REG_TYPE_NORMAL=0, IMS_REG_TYPE_EMERGENCY=1 
} atp_imc_ims_reg_start_ind_struct;

/*
 * Description
 *  - the primitive is used for IMC to notify PS that IMS deregistration start.
 * Direction
 *  - IMC -> PS
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_reg_type_enum  dereg_type;  //IMS_REG_TYPE_NORMAL=0, IMS_REG_TYPE_EMERGENCY=1 
} atp_imc_ims_dereg_start_ind_struct;

/*
 * Description
 *  - the primitive is used for IMC to notify PS send exit ECBM to AP when PDN is deactivated.
 * Direction
 *  - IMC -> PS
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool reserve;    
} atp_imc_ims_exit_start_ind_struct;

/*
 * Description
 *  - the primitive is used for IMC to notify PS current IMS ENABLE state.
 * Direction
 *	- IMC -> PS
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool  is_enabled;
} atp_imc_ims_enable_ind_struct;

/*
 * Description
 *  - the primitive is used for IMC to notify +EIMS:0/1
 * Direction
 *  - IMC -> PS
 */
typedef struct {
	LOCAL_PARA_HDR
    kal_bool is_enable;
} atp_imc_eims_urc_ind_struct;

/*
 * Description
 *  - the primitive is acknowledge of "IMC_REG_POWER_OFF_IND"
 * Direction
 *	- IMC -> PS
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_dereg_cause_enum reason;
    ims_rf_off_type_enum  rf_off_type;    
} atp_imc_power_off_cnf_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_ECFG_SET_REQ
 *       AT> AT+ECFGSET=<cfg_name>,<cfg_value>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8    name[64];      // TODO (by indy), should add define symbol in "ims_common_def.h"
    kal_uint8    value[128];    // TODO (by indy), should add define symbol in "ims_common_def.h"
} atp_imc_ecfg_set_req_struct;


/*
 * @brief 
 * @note MSG_ID_ATP_IMC_ECFG_SET_CNF
 *       AT< OK or +CME ERROR:<err>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool            result; // KAL_TRUE-success; KAL_FALSE-fail
    ims_err_id_enum     cause;  // return "IMS_ERR_UNKNOWN" for all so far
                                // before define IMS domain proprietary cause
} atp_imc_ecfg_set_cnf_struct;


/*
 * @brief 
 * @note MSG_ID_ATP_IMC_ECFG_GET_REQ
 *       AT> AT+ECFGSET=<cfg_name>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8    name[64];      // TODO (by indy), should add define symbol in "ims_common_def.h"
} atp_imc_ecfg_get_req_struct;


/*
 * @brief 
 * @note MSG_ID_ATP_IMC_ECFG_GET_CNF
 *       AT< +ECFGGET:<cfg_name>,<cfg_value>
 *       AT< OK or +CME ERROR:<err>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool            result;     // KAL_TRUE-success; KAL_FALSE-fail
    ims_err_id_enum     cause;      // return "IMS_ERR_UNKNOWN" for all so far
                                    // before define IMS domain proprietary cause
    kal_uint8           name[64];   // TODO (by indy), should add define symbol in "ims_common_def.h"
    kal_uint8           value[128]; // TODO (by indy), should add define symbol in "ims_common_def.h"
} atp_imc_ecfg_get_cnf_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_ECFG_RESET_REQ
 *       AT> AT+ECFGRESET=<cfg_name>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8    name[64];
} atp_imc_ecfg_reset_req_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_ECFG_RESET_CNF
 *       AT< OK or +CME ERROR:<err>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool            result; // KAL_TRUE-success; KAL_FALSE-fail
    ims_err_id_enum     cause;  // return "IMS_ERR_UNKNOWN" for all so far
                                // before define IMS domain proprietary cause
} atp_imc_ecfg_reset_cnf_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_EPVS_SET_REQ
 *       AT> AT+EPVSSET=<cfg_name>,<cfg_value>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8    name[64];
    kal_uint8    value[128];
} atp_imc_epvs_set_req_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_EPVS_SET_CNF
 *       AT< OK or +CME ERROR:<err>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool            result;
    ims_err_id_enum     cause;
} atp_imc_epvs_set_cnf_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_EPVS_GET_REQ
 *       AT> AT+EPVSGET=<cfg_name>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8    name[64];
} atp_imc_epvs_get_req_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_EPVS_GET_CNF
 *       AT< +EPVSGET:<cfg_name>,<cfg_value>
 *       AT< OK or +CME ERROR:<err>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool            result;
    ims_err_id_enum     cause;
    kal_uint8           name[64];
    kal_uint8           value[128];
} atp_imc_epvs_get_cnf_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_QUERY_URI_TYPE_REQ
 *           AT+CDU=0
 */
typedef struct {
    LOCAL_PARA_HDR
} atp_imc_query_uri_type_req_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_QUERY_URI_TYPE_CNF
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 uri_type; // ims_uri_type_enum;
} atp_imc_query_uri_type_cnf_struct;

/*
 * @brief 
 * @note MSG_ID_ATP_IMC_SET_EVS_SUPPORT_REQ
 *           AT>AT+EIMSEVS=0|1
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_enable;
} atp_imc_set_evs_support_req_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_SET_EVS_SUPPORT_CNF
 *           AT< OK
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool    is_success;
    kal_uint32  cause;    // unused
} atp_imc_set_evs_support_cnf_struct;

/*
 * Description
 *  - the primitive is used for ATP indicating IMC that the PS NAS REG state
 */
typedef struct {
    LOCAL_PARA_HDR
    nas_ps_reg_status_enum nas_ps_reg_status;
} atp_imc_nas_ps_reg_status_req_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_TIMER_TEST_REQ
 */

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8     number;
} atp_imc_timer_test_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    wifi_state_enum state;
    wifi_state_cause_enum cause;
    wifi_state_target_ran_enum target_ran;
}atp_imc_wifista_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 reserved;
}atp_imc_wifista_cnf_struct;

/*
 * @note MSG_ID_ATP_IMC_INTER_RAT_STATUS_IND
 *      +EIRAT: <irat_status>, <irat_result>
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_irat_status_enum irat_status;
    kal_bool irat_result;
} atp_imc_inter_rat_status_ind_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_AUTO_FAST_RETURN_IND
 *      +EAFR=<afr_result>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool result;
} atp_imc_auto_fast_return_ind_struct;
 
/*
 * @brief
 * @note MSG_ID_ATP_IMC_CS_CALL_STATUS_IND
 *      +ECPI:<call_id>, <msg_type>, <is_ibt>, <is_tch>, <dir>, <call_mode>, <number>, <type>, "<pau>"[,<disc_cause>]
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_cs_call_status_enum cs_call_status;
} atp_imc_cs_call_status_ind_struct;

/*
 * @brief UE receive mt cs paging
 * note MSG_ID_ATP_IMC_MT_CS_PAGING_IND
 *  +CIEV: 13
 */
typedef struct {
    LOCAL_PARA_HDR
} atp_imc_mt_cs_paging_ind_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_VOICE_DOMAIN_STATUS_IND
 *      AT+EVVS=<voice_status>
 */
typedef struct {
    LOCAL_PARA_HDR
    voice_domain_status_enum voice_domain_status;
} atp_imc_voice_domain_status_ind_struct;

/*
 * @brief Turn on/off Radio link monitor
 * @note MSG_ID_ATP_SET_IMC_RLM_REQ
 */
typedef struct {
	LOCAL_PARA_HDR
	kal_uint8     enable;
} atp_imc_set_rlm_req_struct;

/*
 * @brief IMS diable by AP
 * @note MSG_ID_ATP_IMC_IMS_DEREG_REQ/CNF
 *       AT+EIMSDEREG:<cause>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 dereg_cause; //ims_dereg_cause_by_enum
} atp_imc_ims_dereg_req_struct,
  atp_imc_ims_dereg_cnf_struct;

typedef struct 
{  
    LOCAL_PARA_HDR 
    kal_uint8   dial_num[MAX_CC_ATD_NUM_LEN];
} atp_imc_fdn_ecc_check_req_struct;

typedef struct 
{  
    LOCAL_PARA_HDR
    kal_bool    is_allowed;
    kal_bool    is_emergency;
    kal_uint16  emergency_service_category;
} atp_imc_fdn_ecc_check_cnf_struct;

/*
 * @brief IMS diable by AP
 * @note MSG_ID_ATP_IMC_IMS_INIT_IND
 *       AT+EIMSINVER:<AP>,<MD>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 ap_verno; //from imsa_connect_req
    kal_uint32 md_verno; //IMCB_IMC_HEADER_FILE_VERNO
} atp_imc_ims_init_ind_struct;
  
/*
 * @brief
 * @note MSG_ID_ATP_IMC_C2K_SERVICE_STATE_REQ
 *      +EC2KREG:<domain>, <state>, <service_type>
 */
typedef struct {
    LOCAL_PARA_HDR
    domain_id_enum domain;
    c2k_cell_service_enum state;
    c2k_rat_type_enum service_type;
} atp_imc_c2k_service_state_req_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_C2K_CELL_INFO_UPDATE_REQ
 *      +EC2KINFO:<access_type>, <sid>, <nid>, <pzid>, <base_id>, <sectot_id>, <subnet_length>, <carrier_id>
 */
typedef struct {
    LOCAL_PARA_HDR
    c2k_rat_type_enum access_type;
    kal_uint16 sid;
    kal_uint16 nid;
    kal_uint8 pzid;
    kal_uint16 base_id;
    kal_uint32 sectot_id[4];
    kal_uint8 subnet_length;
    kal_uint8 carrier_id[7];
} atp_imc_c2k_cell_info_update_req_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_CAMPED_CELL_ID_UPDATE_REQ
 *      +ECMPCID:<rat>,<ci>,<plmn_id>,<lac>,<tac>
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_rat_type_enum rat_type;
    kal_uint32 cell_id;
    plmn_id_struct plmn_id;
    kal_uint8 la_code[2];
    kal_uint8 ta_code[2];
} atp_imc_camped_cell_id_update_req_struct;

/*
 * @brief WFC profile from AP
 * @note MSG_ID_ATP_IMC_WFC_PROFILE_REQ/CNF
 *       AT+EWFCP=<wfc_profile>
 */
typedef struct {
    LOCAL_PARA_HDR
    wfc_profile_enum wfc_profile;
} atp_imc_wfc_profile_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_success;
    kal_uint32 cause;   // un-used
} atp_imc_wfc_profile_cnf_struct;

/*
 * @brief RCS feature tag from AP
 * @note MSG_ID_ATP_IMC_RCS_FEATURE_REQ/CNF
 *       AT+EIMSRCS=<rcs_state><rcs_feature>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8  rcs_state;
    kal_uint32 rcs_feature;
} atp_imc_rcs_feature_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_success;
    kal_uint32 cause;   // un-used
} atp_imc_rcs_feature_cnf_struct;

/*
 * @brief user-defined SIP headers from AP
 * @note MSG_ID_ATP_IMC_SIP_HEADER_REQ/CNF
 *       AT+ESIPHEADER=<header count>, <header name>, <value>, <header name>, <value>, ...
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 value[256];
} atp_imc_sip_header_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_success;
    kal_uint32 cause;   // un-used
} atp_imc_sip_header_cnf_struct;

/*
 * Description
 *  - the primitive is indicator of "AT+ERAT"
 * Direction
 *	- ATP -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8  rat_mode;
    kal_uint8  prefer_rat;
    kal_uint16 ref_num;
} atp_imc_switch_prefer_rat_req_struct;
/*
 * Description
 *  - the primitive is acknowledge of "MSG_ID_ATP_IMC_SWITCH_PREFER_RAT_REQ"
 * Direction
 *	- IMC -> ATP
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint16 ref_num;
} atp_imc_switch_prefer_rat_cnf_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_SS_ECT_REQ
 *           AT>AT+ECT=<ect_type>,<target_number>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 ect_type;
    kal_uint8 pad[3];
    kal_uint8 pau[IMC_MAX_ASSERTED_URI];
    kal_uint8 device_id[IMC_MAX_UUID_LEN];
} atp_imc_ss_ect_req_struct;


/*
 * @brief
 * @note MSG_ID_ATP_IMC_SS_ECT_CNF
 *           AT< OK | ...
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_cc_result_enum result;
    ims_cc_cause_enum  cause;
} atp_imc_ss_ect_cnf_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_SET_TEXT_CAPABILITY_REQ/CNF
 *       AT+CTMCALL=<enable>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 enable;
} atp_imc_set_text_capability_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_success;
    kal_uint32 cause;   // un-used
} atp_imc_set_text_capability_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_success;
    kal_uint32 cause;   // un-used
} atp_imc_tty_capability_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 tty_mode; // TTY off:0, TTY Full:1, TTY HCO:2 (hearing carryover), TTY VCO:3 (voice carryover)
}atp_imc_ctmcall_ind_struct;
typedef atp_imc_common_at_rsp_struct atp_imc_ctmcall_rsp_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_RTT_CAPABILITY_REQ/CNF
 *       AT+EIMSRTT=<op>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 operation;
} atp_imc_rtt_capability_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_success;
    kal_uint32 cause;   // un-used
} atp_imc_rtt_capability_cnf_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_RTT_OP_REQ/CNF
 *       AT+RTTCALL = <call id>, <op>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 call_id;
    kal_uint32 op;
} atp_imc_cc_rtt_op_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 acct_id;
    kal_uint32 call_id;
    kal_uint32 result;
} atp_imc_cc_rtt_op_cnf_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_C2K_ECBM_STATE_REQ
 *      +CIEV:<102>,<state>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 ecbm_state;      //ecbm_state_enum
    kal_uint8 ecbm_stop_cause; //ecbm_stop_cause_enum
} atp_imc_c2k_ecbm_state_ind_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_1X_CALL_STATUS_IND
 *      +EC2KCI:<call_status>
 */
typedef struct{
    LOCAL_PARA_HDR
    ims_1x_call_status_enum c2k_1x_call_status;
} atp_imc_c2k_1x_call_status_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 atcmd_id;
    kal_uint8 cmdline[IMC_ATCMD_MAX_CMDLINE_LEN];
}atp_imc_atcmd_relay_ind_struct,
 atp_imc_atcmd_relay_req_struct;

typedef struct {  
    LOCAL_PARA_HDR 
    kal_bool is_success;
    kal_uint32 cause;   // un-used
} atp_imc_atcmd_relay_cnf_struct;

/*
 * Description
 *  - the primitive is request of "MSG_ID_ATP_IMC_MIMS_CAPABILITY_REQ"
 * Direction
 *	- ATP -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 reserved;
} atp_imc_mims_capability_req_struct;

/*
 * Description
 *  - the primitive is response of "MSG_ID_ATP_IMC_MIMS_CAPABILITY_CNF"
 * Direction
 *	- IMC -> ATP
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_success;
    kal_uint8 mims_num;
    kal_uint32 cause;
} atp_imc_mims_capability_cnf_struct;

/*
 * Description
 *  - the primitive is used for IMC to notify PS current IMS Roaming support or not.
 * Direction
 *	- IMC -> ATP
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool  is_enabled;
} atp_imc_ims_roaming_ind_struct;

/*
 * Description
 *  - NWSEL is searching the available NW or not.
 * Direction
 *	- ATP -> IMC
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool  is_searching;
} atp_imc_nw_search_status_ind_struct;

/*
 * Description
 *  - the primitive is used for IMC to notify PS IMS special event.
 * Direction
 *	- IMC -> ATP
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_special_event_enum    special_event;
    imcb_imc_sip_cause_enum   sip_cause;
} atp_imc_ims_event_ind_struct;

#define IMC_AT_CMD_TO_MD_NAME_LEN 32
#define IMC_AT_CMD_TO_MD_VALUE_LEN 512
/*
 * Description
 *  - the primitive is response of "MSG_ID_ATP_IMC_AT_CMD_TO_MD_IND"
 * Direction
 *	- IMC -> ATP
 */
typedef struct {
    LOCAL_PARA_HDR
    atp_egmc_op_enum op;
    kal_uint8 name[IMC_AT_CMD_TO_MD_NAME_LEN];
    kal_uint8 value[IMC_AT_CMD_TO_MD_VALUE_LEN];
} atp_imc_at_cmd_to_md_ind_struct;

/*
 * Description
 *  - the primitive is used for IMC to notify PS that STK call over IMS success.
 * Direction
 *  - IMC -> PS
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint16  terminal_response;  //80 for AT+STKCALL=0, 81 for AT+STKCALL=4
} atp_imc_ims_stkcall_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    atp_imc_drp_enum op;
} atp_imc_dump_runtime_para_req_struct;
/*
 * @brief response of AT+ECCTRL
 * @note MSG_ID_IMSP_CALL_CONTROL_IND
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_cc_result_enum result;
    ims_cc_cause_enum  cause;
    kal_int32  operation;    //imcb_imc_ss_operation_enum map to ims_ecctrl_enum
} atp_imc_call_control_ind_struct;

/*
 * @brief
 * @note MSG_ID_ATP_IMC_CALL_CONTROL_V2_REQ
 *           AT>AT+ECCTRL=<call_id>,<call_state>,<is_unblocking>
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 call_id;
    ims_ecctrl_enum call_state;
    kal_uint8 is_unblocking;
} atp_imc_call_control_v2_req_struct;


/*
 * @brief
 * @note MSG_ID_ATP_IMC_NORMAL_REG_CSCM_REQ
 *           AT>AT+CSCM=<service_type>,<action>
 */
typedef struct {
    LOCAL_PARA_HDR
    ims_scm_info_type_enum service_type;
    ims_scm_info_action_enum action;
} atp_imc_normal_reg_cscm_req_struct;


/*
 * @brief
 * @note MSG_ID_ATP_IMC_NORMAL_REG_CSCM_CNF
 *           AT< OK | ...
 */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool result;
} atp_imc_normal_reg_cscm_cnf_struct;



#endif
