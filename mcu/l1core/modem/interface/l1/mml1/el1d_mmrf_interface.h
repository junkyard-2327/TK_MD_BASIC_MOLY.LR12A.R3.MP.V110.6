/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   el1d_mmrf_interface.h
 *
 * Project:
 * --------
 *   TK6291
 *
 * Description:
 * ------------
 *   EL1D interface to Multi-Mode Multi-RAT RF Central Control
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *----------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *----------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef  _EL1D_MMRF_INTERFACE_H_
#define  _EL1D_MMRF_INTERFACE_H_

/*===============================================================================*/

#include "kal_general_types.h"
#include "el1d_rf_public.h"
#include "mml1_rf_interface.h"
#include "el1d_rf_cal_poc_data.h"

#include "mml1_rf_cal_interface.h"
#include "mml1_rf_calpoc_rf_if.h"
#include "el1d_rf_custom_data.h"

//#include "mml1_rf_calpocif.h"


/*===============================================================================*/

/**********************************************************************************
* define
**********************************************************************************/
/*META Debug Tool*/
#define   LTE_ANALYZED_BY_RFTOOL_ENABLE       (MMRFC_ANALYZED_BY_RFTOOL_ENABLE)

#define IS_HRM_SUPPORT                    1

/** RF Route Table */
//#define EL1D_RX_IRR_DC_ROUTE_NUM_MAX      MMRFC_RX_IRR_COMP_ROUTE_MAX  //Set the same maximum number for RXIRR and RXDC
//#define EL1D_RX_IIP2_ROUTE_NUM_MAX        MMRFC_RX_IIP2_COMP_ROUTE_MAX
//Move the definition to El1d_rf_cal_poc_data.h

/** MIPI CW **/
#define MAX_MIPI_PAON_CW_NUMBER_PER_BAND  (48)//12*2->24,Margin 24
#define MAX_MIPI_PAOFF_CW_NUMBER_PER_BAND (8)//4*2->8
#define MAX_MIPI_RXOFF_CW_NUMBER_PER_BAND (16)//6*2->12, Margin 4
#if IS_EL1D_RF_MT6177L
/** Judge if input band is split-band or not */
#define IS_SPLIT_BAND(band)               ( ((band == MMPOC_XL1_BAND_NUM_BAND_40) || \
                                             (band == MMPOC_XL1_BAND_NUM_BAND_41) || \
                                             (band == MMPOC_XL1_BAND_NUM_BAND_42) || \
                                             (band == MMPOC_XL1_BAND_NUM_BAND_43) || \
                                             (band == MMPOC_XL1_BAND_NUM_BAND_44) || \
                                             (band == MMPOC_XL1_BAND_NUM_BAND_65)) ? KAL_TRUE : KAL_FALSE )
#elif IS_EL1D_RF_MT6177M
/** Judge if input band is split-band or not */
#define IS_SPLIT_BAND(band)               ( ((band == MMPOC_XL1_BAND_NUM_BAND_40) || \
                                             (band == MMPOC_XL1_BAND_NUM_BAND_41)) ? KAL_TRUE : KAL_FALSE )

#endif

/* Definition for LTE Re-CAL mechanism(debug use) */
#define EL1D_RFC_RECAL_ENABLE (0)

#if EL1D_RFC_RECAL_ENABLE
#define EL1D_RFC_RECAL_ITER (2)
#else
#define EL1D_RFC_RECAL_ITER (1)
#endif

/** Reference ABB LPF Pole Frequency of Table 2-2 in TX PG */
#define EL1D_RFC_TX_LPF_RSEL_1P6875MHZ  (1)
#define EL1D_RFC_TX_LPF_RSEL_3P375MHZ   (3)
#define EL1D_RFC_TX_LPF_RSEL_6P75MHZ    (4)
#define EL1D_RFC_TX_LPF_RSEL_8P4MHZ     (4)
#define EL1D_RFC_TX_LPF_RSEL_13P5MHZ    (4)
#define EL1D_RFC_TX_LPF_RSEL_27MHZ      (4)

#define EL1D_RFC_TX_RCF_RSEL_40_OHM     (13)
#define EL1D_RFC_TX_RCF_RSEL_50_OHM     (7)
#define EL1D_RFC_TX_RCF_RSEL_57_OHM     (6)
#define EL1D_RFC_TX_RCF_RSEL_80_OHM     (4)
#define EL1D_RFC_TX_RCF_RSEL_100_OHM    (3)
#define EL1D_RFC_TX_RCF_RSEL_200_OHM    (1)
#define EL1D_RFC_TX_RCF_RSEL_400_OHM    (0)

/** LTE LPF/RCF CSEL */
#if IS_EL1D_RF_MT6177L
#define EL1D_RFC_TX_RCF_CSEL_40_OHM     (5) ///<CSEL adjustment for RSEL =  40 Ohm
#define EL1D_RFC_TX_RCF_CSEL_50_OHM     (4) ///<CSEL adjustment for RSEL =  50 Ohm
#define EL1D_RFC_TX_RCF_CSEL_57_OHM     (4) ///<CSEL adjustment for RSEL =  57 Ohm
#define EL1D_RFC_TX_RCF_CSEL_80_OHM     (3) ///<CSEL adjustment for RSEL =  80 Ohm
#define EL1D_RFC_TX_RCF_CSEL_100_OHM    (2) ///<CSEL adjustment for RSEL = 100 Ohm
#define EL1D_RFC_TX_RCF_CSEL_200_OHM    (0) ///<CSEL adjustment for RSEL = 200 Ohm
#define EL1D_RFC_TX_RCF_CSEL_400_OHM    (0) ///<CSEL adjustment for RSEL = 400 Ohm
#define EL1D_RFC_TX_RCF_CSEL_MAX        (0x1F)
#define EL1D_RFC_TX_RCF_NOMINAL_VALUE   (16)   
#elif IS_EL1D_RF_MT6177M
#define EL1D_RFC_TX_RCF_CSEL_50_OHM     (12)///<CSEL adjustment for RSEL =  50 Ohm
#define EL1D_RFC_TX_RCF_CSEL_80_OHM     (7) ///<CSEL adjustment for RSEL =  80 Ohm
#define EL1D_RFC_TX_RCF_CSEL_100_OHM    (5) ///<CSEL adjustment for RSEL = 100 Ohm
#define EL1D_RFC_TX_RCF_CSEL_MAX        (0x1F)
#define EL1D_RFC_TX_RCF_NOMINAL_VALUE   (17)  
#else
   #error "No Valid RF Chip was defined"
#endif

/** LTE RFC WorkAround Related */
#if IS_EL1D_RF_MT6177L
#define IS_CAL_ORDER_CHANGE_WA_ENABLE    (1) //Bianco needs this WA (all-band DET+TX followed by all-band RX self-cal) for DET_DC recal unconvergent issue.
#define IS_BY_GAIN_DROOPING_WA_ENABLE    (1) //Bianco needs this special handling of CW821,822 manual mode setting in TX_FDAD for by gain drooping issue (mixer OFF solution is final chosen).
#define IS_BYPASS_TX_LEAK_CAL_RESULT     (1) //Only Bianco has TX Leakage feature, and due to lack of verification time for B28 FE Ctrl problem, we always set its cal result as default value (equivalent to bypass TX leakage cal for those FE split bands, like B28,44).
#define IS_DETDC_IN_TXDC_CAL_WA_ENABLE   (1) //Bianco needs this WA due to OPPO B38 TX_DC issue (solution is to sneakly trigger DET_DC Cal in TX_DC Cal in order to improve TX_DC accuracy).
#elif IS_EL1D_RF_MT6177M
#define IS_CAL_ORDER_CHANGE_WA_ENABLE    (1) //Actually, there is no difference between enable and disable this WA in Zion.
#define IS_BY_GAIN_DROOPING_WA_ENABLE    (0) //Zion doesn't need this WA.
#define IS_BYPASS_TX_LEAK_CAL_RESULT     (1) //Still bypass TX leakage cal in Zion even though Zion doesn't support TX leakage cal.
#define IS_DETDC_IN_TXDC_CAL_WA_ENABLE   (0) //Zion so for doesn't  need this WA.
#else
   #error "No Valid RF Chip was defined"
#endif


/************************************************************************************
* enum
************************************************************************************/
/** TXDFE */
typedef enum
{
   FDAD_TAPS_5,
   FDAD_TAPS_7,
   FDAD_TAPS_9,
   FDAD_TAPS_11,
   FDAD_TAPS_13,
   FDAD_TAPS_UNDEF,

} ETXDFE_FDAD_TAP_E;

typedef enum
{
   ASYM_TAPS_3,
   ASYM_TAPS_5,
   ASYM_TAPS_7,
   ASYM_TAPS_9,
   ASYM_TAPS_UNDEF,

} ETXDFE_ASYM_TAP_E;


typedef enum
{
   TONE_1ST,
   TONE_2ND,
   TONE_NUM,

} ETXDFE_TTG_INDEX_E;

typedef enum
{
   COS_ONLY,
   SIN_ONLY,
   COS_N_P_SIN,
   COS_N_N_SIN,
   TTG_MODE_NUM,

} ETXDFE_TTG_MODE_E;

typedef enum
{
   ET_MODE=0,
   DPD_MODE=1,
   APT_MODE=2,
} TXDFE_SW_MODE_E;

typedef enum
{
   PGA_SETA_SLICE8,
   PGA_SETA_SLICE7,
   PGA_SETA_SLICE4,
   PGA_SETA_SLICE2,
   PGA_SETA_SLICE1,
   PGA_SETB_SLICE2,
   PGA_SETB_SLICE1,
   PGA_SETAUX,
} TXDFE_SW_GAIN_INFO_E;

typedef enum
{
   PA_H_MODE=0,
   PA_M_MOLE=1,
   PA_L_MODE=2,
} TXDFE_SW_PA_MODE_E;

typedef enum
{
   LTE_1P4M,
   LTE_3M,
   LTE_5M,
   LTE_10M,
   LTE_15M,
   LTE_20M,
   LTE_PRACH_FMT0,  // 4'd6~9: LTE-PRACH FMT 0~3
   LTE_PRACH_FMT1,
   LTE_PRACH_FMT2,
   LTE_PRACH_FMT3,
   LTE_PRACH_FMT4,
   W_FDD_SC,
   W_FDD_DC,
   W_TDD,
} TXDFE_SW_RAT_E;

typedef enum
{
   SR_13M  = 2,
   SR_26M  = 3,
   SR_52M  = 4,
   SR_104M = 5,
   SR_208M = 6
} TXDFE_SW_RAT_IDX_E;//for txdfe_rf sw mode,sw sampling rate

typedef enum
{
   TONE_1ST_P0,
   TONE_1ST_P1,
   TONE_2ND_P0,
   TONE_2ND_P1,
   DPD_RAMP,
}TXDFE_SW_TTG_SETTING_SEL_E;

typedef enum
{
   SCALE_1_OVER_128,
   SCALE_1_OVER_64,
   SCALE_1_OVER_32,
   SCALE_1_OVER_16,
   SCALE_1_OVER_8,
   SCALE_1_OVER_4,
   SCALE_1_OVER_2,
   FULL_SCALE,
}TXDFE_SW_SINE_AMP_E;

typedef enum
{
   DPD_AM_ON,
   DPD_AM_OFF,
   DPD_PM_ON,
   DPD_PM_OFF,
}TXDFE_WTL_DPD_CON_E;

typedef enum
{
   CIM3_CANCEL_ON,
   CIM3_CANCEL_OFF,
}TXDFE_CIM3_CANCEL_EN_E;

typedef enum
{
   TX_ASYMM_COMP_ON,
   TX_ASYMM_COMP_OFF,
}TXDFE_ASYMM_COMP_EN_E;

typedef enum
{
   TX_FDAD_COMP_ON,
   TX_FDAD_COMP_OFF,
}TXDFE_FDAD_COMP_EN_E;

typedef enum
{
   ANTI_DROOP_ON,
   ANTI_DROOP_OFF,
}TXDFE_ANTI_DROOP_EN_E;

typedef enum
{
   NO_ADJ,        // no adjust
   THREE_DB,      // -3dB
   VALUE_ADJ,     // BB gain adjust value
}TXDFE_BB_GAIN_ADJ_MODE_E;

typedef enum
{
   DAC_104M,
   DAC_208M,
   DAC_416M,
   DAC_NUM,

} ETXDFE_DAC_RATE_E;

typedef enum
{
   GAIN_BKF_ON  = 0x1,
   GAIN_BKF_OFF = 0x0,

} ETXDFE_GAIN_BKF_EN_E;

/***************************************************************************//**
 * @brief      TXDFE selection Enum
 * @details
 * @date       2015.05.28 (latest modified date)
 ******************************************************************************/
typedef enum
{
   TXDFE_INVALID,
   TXDFE_0,
   TXDFE_1,
}RF_TXDFE_SEL_E;

typedef enum
{
   TXDFE_RFPATH_P0,
   TXDFE_RFPATH_P1,
   TXDFE_RFPATH_INVALID,
}RFPATH_TXDFE_SEL_E;

typedef enum
{
   TXDFE_BBPATH_P0,
   TXDFE_BBPATH_P1,
   TXDFE_BBPATH_INVALID,
}BBPATH_TXDFE_SEL_E;

typedef enum
{
   TXDFE_FDAPATH_P0,
   TXDFE_FDAPATH_P1,
   TXDFE_FDAPATH_INVALID,
}FDAPATH_TXDFE_SEL_E;

typedef enum
{
   TTG_GAIN_FROM_L1,
   TTG_GAIN_FROM_TPC,
}RFPATH_TTG_GAIN_SWTICH_E;

/************************************************************************************
* typedef
************************************************************************************/
/** Structure Prototypes can be seen by other files**/
/** TXDFE */
typedef struct
{
   /** TTG phase*/
   kal_int32 phi;

   /** TTG gain*/
   kal_uint32 gain;

   /** TTG phase0 mode*/
   ETXDFE_TTG_MODE_E p0_mode;

   /** TTG phase1 mode*/
   ETXDFE_TTG_MODE_E p1_mode;

   /** 1st TTG tone DC value: i part*/
   kal_int32  dc_i;

   /** 1st TTG tone DC value: q part*/
   kal_int32  dc_q;

} ETXDFE_TTG_CTRL_T;

typedef struct
{
   /** SW TPC con1  mode */
   TXDFE_SW_MODE_E mode;

   /** SW TPC con1 gain information */
   TXDFE_SW_GAIN_INFO_E gain;

   /** SW TPC con1 gain information */
   TXDFE_SW_PA_MODE_E pa_mode;

   /** SW TPC con1 DPD lut select*/
   kal_uint16 dpd_lut_sel;

   /** SW TPC con1 ETDPD_norm*/
   kal_uint16 etdpd_norm;

   /** SW TPC con1 BB gain*/
   kal_uint16 bb_gain;

   /*CBW index:TXDFE_SW_RAT_E*/
   TXDFE_SW_RAT_E cbw_idx;

} ETXDFE_SW_MODE_CFG_T;

typedef struct
{
   /** CON5 sine tone frequency = sampling rate / 64 * TXDFE_SW_SINE_FREQ_SEL*/
   kal_uint8 sine_freq_sel;

   /** CON5 sine tone amplitude selection*/
   TXDFE_SW_SINE_AMP_E sine_amp;

   /** CON5 SW SINE GEN mode enable*/
   kal_uint8 sine_gen_en;
} ETXDFE_SW_MODE_SIN_GEN_T;

//Legacy part
typedef struct
{
   kal_uint32 comp_tab[LTE_TX_DC_COMP_FC_MODE_NUM][LTE_TX_DC_COMP_PGA_SLICE_SET_NUM];

} ETXDFE_TX_DC_COMP_TAB_IO_T;

typedef struct
{
   kal_uint32 comp_tab[LTE_TX_IQ_COMP_FC_MODE_NUM][LTE_TX_IQ_COMP_PGA_SLICE_SET_NUM];

} ETXDFE_TX_IQ_COMP_TAB_IO_T;

typedef struct
{
   kal_int16 cof[LTE_FREQ_DEP_COMP_COEFF_NUM+2];

} ETXDFE_FREQ_DEP_COMP_COEFF_T;

typedef struct
{
   ETXDFE_FREQ_DEP_COMP_COEFF_T coeff_tab[LTE_FREQ_DEP_COMP_FC_MODE_NUM][LTE_FREQ_DEP_COMP_PGA_SLICE_SET_NUM];

} ETXDFE_FREQ_DEP_COMP_COEFF_TAB_T;


typedef struct
{
   kal_uint32 cof[LTE_FREQ_DEP_COMP_COEFF_REG_NUM];

} ETXDFE_FREQ_DEP_COMP_COEFF_OUT_T;

typedef struct
{
   ETXDFE_FREQ_DEP_COMP_COEFF_OUT_T coeff_tab[LTE_FREQ_DEP_COMP_FC_MODE_NUM][LTE_FREQ_DEP_COMP_PGA_SLICE_SET_NUM];

} ETXDFE_FREQ_DEP_COMP_COEFF_TAB_IO_T;

typedef struct
{
   kal_uint32 cof[LTE_ASYMM_COMP_COEFF_REG_NUM];

} ETXDFE_ASYMM_COMP_COEFF_OUT_T;

typedef struct
{
   ETXDFE_ASYMM_COMP_COEFF_OUT_T coeff_tab[LTE_ASYMM_COMP_PGA_SLICE_SET_NUM];

} ETXDFE_ASYMM_COMP_COEFF_TAB_IO_T;

typedef struct
{
   TXDFE_BB_GAIN_ADJ_MODE_E mode;
   kal_int16 value;
}TXDFE_BB_GAIN_ADJ_CON_T;

typedef struct TXDFE_GAIN_BKF_CON
{
   ETXDFE_GAIN_BKF_EN_E is_On;
   kal_uint32 bkf_value_m0; //ET
   kal_uint32 bkf_value_m1; //DPD mode
   kal_uint32 bkf_value_m2; //APT mode
} ETXDFE_GAIN_BKF_CON_T;



typedef struct
{
   kal_uint8 V_TX_BAL_CAPA;
   kal_uint8 V_TX_BAL_CAPB;
}CAP_TUNNING_SETTING_T;

typedef struct
{
  MMRFC_RX_DC_RESULT_T rx_dc[MMRFC_RXDC_TIA_GAIN_STEPS][MMRFC_RXDC_PGA_GAIN_STEPS];
} EL1D_RFC_RX_DC_HPM_RESULT_T;

/*===============================================================================*/
/*                     RF Calibration Result Structure                           */
/*     The structure is grouped from post-processing result. Some redundent      */
/*     items may need to be removed and excluded in shared memory or NVRAM.      */
/*===============================================================================*/

typedef struct
{
   /* RX IRR */
   MMRFC_RX_IRR_RESULT_T       rx_irr_hpm[EL1D_RX_IRR_COMP_ROUTE_MAX][MMRFC_LTE_RX_CBW_NUM][MMRFC_ANT_NUM]; //RX IRR for HPM
   MMRFC_RX_IRR_RESULT_T       rx_irr_lpm[EL1D_RX_IRR_COMP_ROUTE_MAX][MMRFC_LTE_RX_CBW_NUM][MMRFC_ANT_NUM]; //RX IRR for LPM
   MMRFC_RX_IRR_RESULT_T       rx_irr_hpm_lif[EL1D_RX_IRR_COMP_ROUTE_MAX][MMRFC_LTE_RX_CBW_NUM][MMRFC_ANT_NUM]; //RX IRR for HPM LIF , HPM max gain

   /* RX DC */
   EL1D_RFC_RX_DC_HPM_RESULT_T    rx_dc_hpm[EL1D_RX_DC_COMP_ROUTE_MAX][MMRFC_ANT_NUM];     //RF DC for HPM
   EL1D_RFC_RX_DC_HPM_RESULT_T    rx_dig_dc_hpm[EL1D_RX_DC_COMP_ROUTE_MAX][MMRFC_ANT_NUM]; //Digital DC for HPM
   MMRFC_RX_DC_RESULT_T           rx_dc_lpm[EL1D_RX_DC_COMP_ROUTE_MAX][MMRFC_ANT_NUM];     //RF DC for LPM
   MMRFC_RX_DC_RESULT_T           rx_dig_dc_lpm[EL1D_RX_DC_COMP_ROUTE_MAX][MMRFC_ANT_NUM]; //Digital DC for LPM

   /* RX IIP2 */
   //CW473 for path 1, CW482 for path 2
   //i_idx_opt->V_RX1_IIP2_IRESULTS[6:0], q_idx_opt->V_RX1_IIP2_QRESULTS[6:0]
   MMRFC_IIP2_RESULT_T         rx_iip2[EL1D_RX_IIP2_COMP_ROUTE_MAX];

   /* DET */
   /* Only FDIQ is dependent with CBW, other redundent items need to be removed in NVRAM/share memory structure */
   kal_uint32                  det_coarse_dcoc_cw807; //CW807, V_TXCDCOC1[19:0]
   kal_uint32                  det_coarse_dcoc_cw808; //CW808, V_TXCDCOC2[19:0]

   /* Please refer to DET_TIA_COMP_INDEX_LUT/DET_CBW_COMP_INDEX_LUT for mapping from DET gain index/CBW to comp. structure */
   MMRFC_DET_IQDNL_RESULT_T    det_iqdnl_fwd[MMRFC_DET_FE_GAIN_STEPS][MMRFC_LTE_DET_CBW_NON_CCA_NUM]; //1.4MHz and 3MHz share the same config -> restore result per CBW(20150206)
   MMRFC_DET_DC_RESULT_T       det_dc_fwd[MMRFC_DET_GAIN_STEPS_DET_CAL]; //17 DET gain step

   /* Please refer to DET_TIA_COMP_INDEX_LUT/DET_CBW_COMP_INDEX_LUT for mapping from DET gain index/CBW to comp. structure */
   MMRFC_DET_IQDNL_RESULT_T    det_iqdnl_fwd_cca[MMRFC_DET_GAIN_STEPS_DET_CAL]; //only for DET 40MHz
   MMRFC_DET_IQDNL_RESULT_T    det_iqdnl_rev_cca[MMRFC_DET_GAIN_STEPS_DET_CAL]; //only for DET 40MHz

   /* Please refer to DET_TIA_COMP_INDEX_LUT/DET_CBW_COMP_INDEX_LUT for mapping from DET gain index/CBW to comp. structure */
   MMRFC_DET_IQDNL_RESULT_T    det_iqdnl_rev[MMRFC_DET_FE_GAIN_STEPS][MMRFC_LTE_DET_CBW_NON_CCA_NUM]; //1.4MHz and 3MHz share the same config -> restore result per CBW(20150206)
   MMRFC_DET_DC_RESULT_T       det_dc_rev[MMRFC_DET_GAIN_STEPS_DET_CAL]; //17 DET gain step

   MMRFC_DET_EQLPF_CFG_T       det_pcb[MMRFC_DET_FE_GAIN_STEPS][MMRFC_LTE_DET_CBW_NON_CCA_NUM];

   MMRFC_DET_EQLPF_CFG_T       det_pcb_cca[MMRFC_DET_GAIN_STEPS];

   /* TX LO Cal */
   kal_uint32                  tx_lo;                 //CW714, {2'b00,V_TXLOCAP[6:0],V_TXLOIND,V_TXLOINBIAS[4:0],V_TXLOINBIAS[4:0]}
   kal_uint8                   tx_lo_ind;             //CW714[10]
   kal_uint8                   tx_lo_capcal_peak_cap; //CW714[17:11]
   kal_uint8                   tx_lo_in_bias_hpm;     //CW714[4:0]
   kal_uint8                   tx_lo_in_bias_lpm;     //CW714[9:5]
   kal_int32                   stx_delta_duty_cycle;  //for calculating CW568 V_DCC_DELTA_NC[10:0] with different Nmmd

   /* TX RC */
   kal_int16                   tx_rc_lpf[MMRFC_LTE_TX_CBW_NUM]; //CW787, V_TXLPFCSEL[7:0], only 5 CBW for LPF but it will map to 6 LTE RF CBW for easy access
   kal_int16                   tx_rc_rcf;                       //CW793, V_TXRCFCSEL[6:0]

   /* TX IQDC */
   /* TXIQ: G0, G9, G10, G12a, G14a, G12b, G14b, G22  */
   /* TXDC: G0, G9, G10, G12a, G14a, G12b, G14b, G22  */
   /* freq_dep_phase_tx is temp output for FDIQ cal   */
   /* Please refer to TX_COMP_INDEX_PGA_A_LUT/TX_COMP_INDEX_PGA_B_LUT for mapping from TX gain index to comp. structure */
   MMRFC_TX_IQDC_RESULT_T      tx_iqdc_lin[MMRFC_TX_PGA_SLICE_NUM+1];                   //+1 for PGA-AUX
   MMRFC_TX_IQDC_RESULT_T      tx_iqdc_dpd[MMRFC_TX_PGA_SLICE_NUM+1];                   //+1 for PGA-AUX
   MMRFC_TX_FD_FILT_RESULT_T   tx_fdiq[MMRFC_LTE_TX_CBW_NUM][MMRFC_TX_PGA_SLICE_NUM+1]; //+1 for PGA-AUX

   /* TX DNL */
   kal_int16                   tx_dnl_lin_pga_a[MMRFC_TX_DNL_PGA_A_SEQ_NUM]; //20 gain diff
   kal_int16                   tx_dnl_lin_pga_b[MMRFC_TX_DNL_PGA_B_SEQ_NUM]; //15 gain diff

   /* TX GA */
   MMRFC_TX_GA_RESULT_T        tx_ga_w_ET[MMRFC_TX_PGA_TYPE_NUM][MMRFC_LTE_TX_CBW_NUM];  //3 PGA type, 6CBW
   MMRFC_TX_GA_RESULT_T        tx_ga_wo_ET[MMRFC_TX_PGA_TYPE_NUM][MMRFC_LTE_TX_CBW_NUM]; //3 PGA type, 6CBW


   /* TX PGA Gain Step */
   kal_int16                   pga_gain_step[MMRFC_TX_PGA_GAIN_STEP_SUBBAND_NUM][MMRFC_TX_PGA_GAIN_STEP_NUM];

   /* TX PGA Cap Tuning */
   CAP_TUNNING_SETTING_T  cap_tuning_pga_a; //CW795, V_TX_BAL_CAPA_AACT[5:0],V_TX_BAL_CAPB_AACT[5:0]
   CAP_TUNNING_SETTING_T  cap_tuning_pga_b; //CW796, V_TX_BAL_CAPA_BACT[5:0],V_TX_BAL_CAPB_BACT[5:0]


} MMRFC_LTE_RESULT_PER_BAND_T;

typedef struct
{
   MMRFC_LTE_RESULT_PER_BAND_T lte_result[MMRFC_XL1_MAX_SUPPORT_BAND_NUM];

   //TODO: May split RX/DET/TX calibration results for saving memory size
   MMRFC_LTE_RESULT_PER_BAND_T lte_result_b40[MMRFC_TX_PGA_CAP_TUNING_SUBBAND_NUM];
   MMRFC_LTE_RESULT_PER_BAND_T lte_result_b41[MMRFC_TX_PGA_CAP_TUNING_SUBBAND_NUM];

} MMRFC_LTE_RESULT_T;

/** RF Route Table */
typedef struct
{
   LTE_Band   band;
   kal_uint8  route_num;
   LTE_Route  route_idx[EL1D_RX_DC_IRR_COMP_ROUTE_MAX];
   LTE_Route  rf_route_index_table[EL1D_RX_DC_IRR_COMP_ROUTE_MAX];
}EL1D_RX_DC_IRR_CFG_INDEX_TBL_T;

typedef struct
{
   kal_bool   is_virtual_ncca;
   kal_uint8  virtual_ncca_index;
}EL1D_RX_IIP2_VIRTAUL_NCCA_INFO_T;

typedef struct
{
   LTE_Band   band;
   kal_uint8  route_num;
   LTE_Route  rx_route_idx[EL1D_RX_IIP2_COMP_ROUTE_MAX];
   LTE_Route  tx_route_idx[EL1D_RX_IIP2_COMP_ROUTE_MAX];
   kal_uint16 rx_iip2_usage_comp_idx[EL1D_RX_IIP2_COMP_ROUTE_MAX];
   EL1D_RX_IIP2_VIRTAUL_NCCA_INFO_T rx_iip2_virtual_ncca_info[EL1D_RX_IIP2_COMP_ROUTE_MAX];
}EL1D_RX_IIP2_CFG_INDEX_TBL_T;

typedef struct
{
   LTE_Band band;
   LTE_Route rx_route_idx;
   LTE_Route tx_route_idx;
}EL1D_RX_TX_LEAKAGE_CFG_INDEX_TBL_T;

typedef struct{
   LTE_Band   band;
   kal_uint8  srx;
   kal_uint8  vco;
   kal_uint8  div;
}TX_LEAKAGE_SRX_CONFIG_T;


typedef struct
{
   LTE_RF_POC_RX_DC_RESULT_T dc_ant0;
   LTE_RF_POC_RX_DC_RESULT_T dc_ant1;
}EL1D_RX_DCOC_COMP_DATA_T;

/** RF TX Route Table*/
typedef struct
{
   LTE_Band   band;
   kal_uint8  route_num;
   LTE_Route  tx_route_idx[EL1D_TX_COMP_ROUTE_MAX];
}EL1D_TX_CFG_INDEX_TBL_T;

typedef struct
{
   kal_uint8             route_num;
   kal_bool              is_rx_tdd_band;
   MMRFC_RX_CAL_CFG_T    cfg[MMRFC_RX_IRR_COMP_ROUTE_MAX];
}EL1D_RX_CAL_IRR_DC_CFG_T;

typedef struct
{
   kal_uint8          route_num;
   kal_uint16         rx_iip2_usage_comp_idx[MMRFC_RX_IIP2_COMP_ROUTE_MAX];
   kal_bool           is_rx_tdd_band;
   MMRFC_RX_CAL_CFG_T rx_cfg[MMRFC_RX_IIP2_COMP_ROUTE_MAX];
   MMRFC_TX_CAL_CFG_T tx_cfg[MMRFC_RX_IIP2_COMP_ROUTE_MAX];
}EL1D_RX_CAL_IIP2_CFG_T;

typedef struct
{
   kal_uint8          route_num;
   kal_bool           is_rx_tdd_band;
   kal_bool           is_not_supported;
   MMRFC_RX_CAL_CFG_T rx_cfg;
   MMRFC_TX_CAL_CFG_T tx_cfg;
}MMRFC_RX_CAL_TX_LEAKAGE_CFG_T;
/********MIPI struct***********/

typedef struct
{
   kal_uint16  mipi_data_start;
   kal_uint16  mipi_data_number;
}EL1D_RF_CAL_MIPI_DATA_T;

typedef struct
{
   kal_bool             is_tx_rck;
   MMRFC_XL1_BAND_NUM_E band;     //Valid if is_tx_rck = 0
   kal_bool             is_cca;   //Valid if is_tx_rck = 0
   kal_bool             is_hrm;   //Valid if is_tx_rck = 0
   kal_bool             is_8mhz;  //Valid if is_tx_rck = 1
}EL1D_RF_CAL_RCF_INFO_DATA_T;

#if MMRFC_ANALYSE_TX_LO_ENABLE
typedef struct
{
   kal_uint32 check_status;
   kal_uint32 peak_cap;
   kal_uint32 in_bias;
   kal_uint32 ind_sw;
}EL1D_RFC_DEBUG_INFO_TX_LO_T;
#endif


/************************************************************************************
*  Global Variables extern (Interface)
************************************************************************************/
extern kal_uint32*          lrfcalPocBufferTable              [/*MMPOC_BUFFER_TYPE_NUM_OF*/];
extern kal_uint32           lrfcalPocBufferSizeTable          [/*MMPOC_BUFFER_TYPE_NUM_OF*/];
extern MML1_RF_BSIMM_PORT_T lrfcalPocBufferDataPortSelTable   [/*MMPOC_BUFFER_TYPE_NUM_OF*/];
extern MML1_MIPI_REG_RW_T   lrfcalPocBufferDataMipiCwTypeTable[/*MMPOC_BUFFER_TYPE_NUM_OF*/];
//extern kal_uint8            LTE_MIPI_PA_ON_DATA_SIZE          [LTE_TARGET_MAX_SUPPORT_BAND_NUM];
extern EL1D_RF_CAL_MIPI_DATA_T LTE_MIPI_PA_ON_DATA            [LTE_TARGET_MAX_SUPPORT_BAND_NUM];
extern EL1D_RF_CAL_MIPI_DATA_T LTE_MIPI_PA_OFF_DATA           [LTE_TARGET_MAX_SUPPORT_BAND_NUM];

/** RF Route Table */
extern kal_uint16 EL1D_RX_IRR_DC_CONFIG_TBL_SIZE;
extern kal_uint16 EL1D_RX_IIP2_CONFIG_TBL_SIZE;
extern EL1D_RX_DC_IRR_CFG_INDEX_TBL_T  EL1D_RX_DC_IRR_CONFIG_TBL[LTE_TARGET_MAX_SUPPORT_BAND_NUM];
extern EL1D_RX_IIP2_CFG_INDEX_TBL_T    EL1D_RX_IIP2_CONFIG_TBL[LTE_TARGET_MAX_SUPPORT_BAND_NUM];
extern kal_uint32*          lrfcalband40PocBufferTable[2];
extern kal_uint32*          lrfcalband41PocBufferTable[2];

#if defined(__FPGA__)
extern kal_uint32 el1d_det_cal_comp;
extern kal_uint32 el1d_fdiq_cal_comp;
extern kal_uint32 el1d_fiiq_cal_comp;
extern kal_uint32 el1d_ga_cal_comp;
extern kal_uint32 el1d_dnl_cal_comp;
extern kal_uint32 el1d_fpga_test_case;
#endif

#if (defined(__FPGA__) || defined(__LTE_L1SIM__))
extern MMRFC_ANT_BITMAP_E ant_sel_for_lte_xl1sim;
extern kal_bool           iip2_cal_en_for_lte_xl1sim;
#endif

/** DET Part */
extern const MMRFC_DET_TIA_COMP_INDEX_E DET_TIA_COMP_INDEX_LUT[MMRFC_DET_GAIN_STEPS_DET_CAL];
extern const MMRFC_DET_BW_SETTING_E     DET_PGA_BW_SETTING_LUT[MMRFC_LTE_TX_CBW_NUM];

#if IS_DETDC_IN_TXDC_CAL_WA_ENABLE
extern kal_bool              is_tx_dc_cal_wa_use;
extern MMRFC_DET_DC_RESULT_T det_dc_calgo_result_wa_use;
#endif

#if MMRFC_ANALYSE_TX_LO_ENABLE
extern EL1D_RFC_DEBUG_INFO_TX_LO_T debug_info_tx_lo;
#endif


/************************************************************************************
* Global Functions Prototype (Interface)
************************************************************************************/
/** TXDFE */
void EL1D_TXDFE_Set_Ttg_Config( ETXDFE_TTG_INDEX_E tone_idx, const ETXDFE_TTG_CTRL_T *p );
void EL1D_TXDFE_Update_FDAD_Coeff( ETXDFE_FDAD_COMP_COEFF_TAB_T *p_freq_dep, RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );
void EL1D_TXDFE_Update_Asymm_Comp_Coeff( ETXDFE_ASYMM_COMP_COEFF_TAB_T *p_asymm_comp, RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );
void EL1D_TXDFE_Update_Tx_Dc_Comp( ETXDFE_TX_DC_COMP_TAB_T *p_dc, RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );
void EL1D_TXDFE_Update_Tx_Iq_Comp( ETXDFE_TX_IQ_COMP_TAB_T *p_iq, RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );

void EL1D_TXDFE_Sw_Mode_Win_On( TXDFE_SW_TTG_SETTING_SEL_E ttg_setting_sel, RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );
//void EL1D_TXDFE_Sw_Mode_Win_Off( RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );
void EL1D_TXDFE_Sw_Mode_Config_On( ETXDFE_SW_MODE_CFG_T *p_sw_mode, RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );
void EL1D_TXDFE_Sw_Mode_Config_Off( RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );

void EL1D_TXDFE_FDAD_Comp_On_Off( TXDFE_FDAD_COMP_EN_E en, const ETXDFE_FDAD_TAP_E fdad_tap,  RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );
void EL1D_TXDFE_Asymm_Comp_On_Off( TXDFE_ASYMM_COMP_EN_E en, const ETXDFE_ASYM_TAP_E asymm_comp_tap,  RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );

void EL1D_TXDFE_Set_Txdfe_Delay( kal_uint16 LM1_value, kal_uint16 LM2_value, const RF_TXDFE_SEL_E txdfe_instance, kal_uint8 group_sel );

void EL1D_TXDFE_Rf_Hw_Init( const RFPATH_TXDFE_SEL_E txdfe_rfpath_sel );

/** EL1D RF database update @ lrfdatabase.c */
void EL1D_MMRF_L1CoreSHMDataInit(void);
void EL1D_MMRF_L1coreSHMUpdate2Local(void);


/** EL1D RF Calibration @ lrfcal.c */
void EL1D_MMRF_PowerOnCalibration(void);         //Triggered only by META

void EL1D_MMRF_PowerOnCalibration_Stage2(void);//Triggered only by META

kal_uint16 EL1D_RF_Cal_Poc_NVRAM_Lid_Total_Num_InUse(void );
kal_uint16 EL1D_RF_Cal_Poc_NVRAM_Lid_Total_Num_InUse_Stage2(void);
kal_uint16 EL1D_RF_Get_Rf_Self_Cal_Result_Size(kal_uint16 rid_index);
kal_uint16 EL1D_RF_Get_Rf_Self_Cal_Result(kal_uint16 rid_index, kal_uint16 rid_size, kal_uint8 *dst);
kal_uint16 EL1D_RF_Set_Rf_Self_Cal_Result(kal_uint16 rid_index, kal_uint16 rid_size, kal_uint8 *src);
kal_uint16 EL1D_RF_Get_Rf_Self_Cal_String( kal_uint16 lid_index, kal_char *string_dst );
void EL1D_RF_BootUp_RFC_Run(void);
kal_bool EL1D_RF_BootUp_RFC_Check(void);

/** MMRF */
void EL1D_MMRF_RXDFE_Win_Ctrl_Main(MMRFC_RX_CAL_TYPE_E rx_cal_type, MMRFC_PATH_BITMAP_E path_sel, kal_uint8 strobe_setting_only, kal_uint32 fc_set_bmp);
void EL1D_MMRF_RXDFE_Win_Ctrl_Main_Normal(MMRFC_RX_CAL_TYPE_E rx_cal_type, MMRFC_PATH_BITMAP_E path_sel, kal_uint8 trig_idx, kal_uint8 strobe_setting_only , kal_uint32 fc_set_bmp, kal_int32 on_time, kal_int32 off_time);
void EL1D_MMRF_RXDFE_Fc_Ctrl_Main(MMRFC_RX_CAL_TYPE_E rx_cal_type, MMRFC_PATH_BITMAP_E path_sel, MMRFC_XL1_BAND_NUM_E poc_band, kal_uint16 agg_bw, kal_uint32 fc_set_bmp, MMRFC_ANT_BITMAP_E ant_bmp);
void EL1D_MMRF_RXDFE_Win_Off(MMRFC_RX_CAL_TYPE_E rx_cal_type, MMRFC_PATH_BITMAP_E path_sel, kal_uint8 is_adc_off, kal_uint32 fc_set_bmp);
kal_uint32 EL1D_MMRF_RXDFE_Fc_Set_Bmp_Get(void);
kal_uint32 EL1D_MMRF_UpdateRuntimeHandler( kal_uint32 nvram_lid, kal_uint32 record_idx, kal_uint8 *data, kal_uint16 nvram_size );

/** RF RX Route Table */
void EL1D_RFC_GetRxIrrDcConfigTable(LTE_Band band, EL1D_RX_CAL_IRR_DC_CFG_T* irr_dc_cfg, kal_uint8 is_irr_cal);
void EL1D_RFC_GetRxIip2ConfigTable(MMRFC_XL1_BAND_NUM_E band, EL1D_RX_CAL_IIP2_CFG_T* iip2_cfg);

/** RF TX Route Table*/
void EL1D_RF_MMPOC_GetTxCfg( MMRFC_XL1_BAND_NUM_E mmrfc_band,  MMRFC_TX_ROUTE_CFG_T *tx_route_cfg);

#if IS_EL1D_RF_MT6177M
kal_uint16 EL1D_RF_MMPOC_Query_B44_Center_Freq(kal_bool is_hrm);
kal_uint16 EL1D_RFC_Rx_Query_B44_Freq( MMRFC_RX_CAL_CFG_T* rx_cfg_p);
#endif

/*RF Rx QDL decision*/
kal_bool EL1D_RFC_RX_QDL_Decision(kal_uint8 vco, kal_uint8 div);

/** API for getting POC results for POC*/
//void EL1D_RF_GetRxDcResult(kal_uint8 band_idx, kal_uint8 dc_comp_idx, kal_uint8 tia_gain_idx, kal_uint8 if_gain_idx, MMRFC_POWER_MODE_E power_mode, MMRFC_RX_DC_RESULT_T* cal_result);
//void EL1D_RF_GetTxDcResult(MMRFC_XL1_BAND_NUM_E band, kal_uint8 band_idx, ETXDFE_TX_DC_COMP_TAB_T* cal_result);
//void EL1D_RF_GetTxFiiqResult(MMRFC_XL1_BAND_NUM_E band, kal_uint8 band_idx, ETXDFE_TX_IQ_COMP_TAB_T* cal_result);
//void EL1D_RF_GetTxFdiqResult(MMRFC_XL1_BAND_NUM_E band, kal_uint8 band_idx, kal_uint8 cbw_idx, ETXDFE_FREQ_DEP_COMP_COEFF_TAB_T* cal_result);
//void EL1D_RF_GetTxGaResult(MMRFC_XL1_BAND_NUM_E band, kal_uint8 band_idx, kal_uint8 subband_idx, kal_uint8 pga_type, kal_uint8 cbw_idx, ETXDFE_ASYMM_COMP_COEFF_TAB_T* cal_result);
//void EL1D_RF_GetTxLoResult(MMRFC_XL1_BAND_NUM_E band, kal_uint8 band_idx, kal_uint8 *tx_lo_ind, kal_uint8 *tx_lo_capcal_peak_cap, kal_uint8 *tx_lo_in_bias_hpm, kal_uint8 *tx_lo_in_bias_lpm);

//RF DC CW API
void EL1D_RFC_RxDcocCW(MMRFC_PATH_BITMAP_E path_sel, EL1D_RX_DCOC_COMP_DATA_T* dcoc_comp, MML1_RF_BSIMM_PORT_T port_sel);

/** API for configuring STX DCC Cal CW */
kal_bool IS_EL1D_MMRF_STX_DCC_Band_Support(MMRFC_XL1_BAND_NUM_E band);
void EL1D_MMRF_STX_DCC_DELTA_NC_CONFIG(kal_int32 dcc_delta_nc, kal_uint8 dcc_est_en, kal_uint32* bsiData);
void EL1D_MMRF_STX_DCC_CONFIG(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, kal_int32 dcc_delta_nc, kal_uint8 dcc_est_en, kal_uint32* nmmd, kal_uint32* bsiData);
void EL1D_MMRF_GET_TDC_RATIO(MMRFC_XL1_BAND_NUM_E band, kal_uint32* tdc_ratio);
void EL1D_MMRF_GET_DCC_DELTA_TDC_OUT(MMRFC_XL1_BAND_NUM_E band, kal_int32* dcc_delta_tdc_out);

/** API to set TX CWs from SLEEP to BURST MODE for RX IIP2 CAL*/
void EL1D_RF_CAL_Set_TX_CW_Rx_IIP2_CAL(MMRFC_TX_CAL_CFG_T *tx_cfg);
void EL1D_RF_CAL_Set_TX_PGA_Gain_CW_Rx_IIP2_CAL(MMRFC_TX_CAL_CFG_T *tx_cfg, MML1_RF_BSIMM_PORT_T port_sel);

/** API to get TX DET ANT*/
kal_bool EL1D_RF_DET_Path_Query(MMRFC_XL1_BAND_NUM_E band, MMRF_DET_IO_E tx_det_io);

/** API for CDDC*/
void EL1D_4G_Calibration_Data_File_Check_Valid(kal_uint16 *tablePtr);

/* DET compensation (in calibration mode) */
void EL1D_RFC_DET_FIIQ_COMP(kal_uint32 route_idx,
                            MMRFC_DETDFE_TIA_GAIN_IDX_E fe_gain,
                            MMRFC_TX_RAT_CBW_CFG_E cbw_case_idx,
                            MMRFC_DET_FIIQ_COMP_T* p);
void EL1D_RFC_DET_DC_COMP(MMRFC_DET_G_IDX det_gain_step,
                          MMRFC_DET_DC_COMP_T* p);
void EL1D_RFC_DET_FDPCB_COMP(kal_uint32 route_idx,
                             MMRFC_DETDFE_TIA_GAIN_IDX_E fe_gain,
                             MMRFC_TX_RAT_CBW_CFG_E cbw_case_idx,
                             kal_bool is_default,
                             MMRFC_DET_EQLPF_CFG_T* p);

/* TX compensation (in calibration mode) */
void EL1D_RF_TX_PARAM_COMP(RF_COMP_INDEX_E comp_idx,
                           kal_uint32 tx_route_idx,
                           kal_uint32 rfc_rt_idx,
                           MMRFC_TX_RAT_CBW_CFG_E cbw_cfg,
                           MMRFC_XL1_BAND_NUM_E band,
                           LTE_TX_SPLIT_BAND_SUBBAND_INDEX_E subband_idx);

void EL1D_RF_GetTxBwConfig(MMRFC_TX_CAL_ITEM_CFG_E txk_item, MMRFC_TX_RAT_CBW_CFG_E* start_cbw, MMRFC_TX_RAT_CBW_CFG_E* end_cbw, kal_uint8 is_ls_est);

/* CONFIG_BUFFER Series */
void EL1D_MMRF_RFCAL_TX_PA_ON_LOWGAIN_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p,
                                                                            kal_uint8* length,
                                                                            MMRFC_TXPA_ON_LOWGAIN_BUFFER_T* buffer,
                                                                            MML1_RF_BSIMM_PORT_T* port_sel);
void EL1D_MMRF_RFCAL_TX_PA_OFF_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p,
                                                                 kal_uint8* length,
                                                                 MMRFC_TXPA_OFF_BUFFER_T* buffer,
                                                                 MML1_RF_BSIMM_PORT_T* port_sel);
void EL1D_MMRF_RFCAL_TX_ON_BPI_CTRL_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, 
                                                                            kal_uint8* length,
                                                                            MMRFC_TX_ON_BPI_CTRL_BUFFER_T* buffer, 
                                                                            MML1_RF_BSIMM_PORT_T* port_sel,
                                                                            kal_uint8 is_txcca);
void EL1D_MMRF_RFCAL_TX_OFF_BPI_CTRL_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p,
                                                                 kal_uint8* length,
                                                                 MMRFC_TX_OFF_BPI_CTRL_BUFFER_T* buffer,
                                                                 MML1_RF_BSIMM_PORT_T* port_sel);
void EL1D_MMRF_RFCAL_RX_OFF_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p,
                                                                 kal_uint8* length,
                                                                 MMRFC_RX_OFF_BUFFER_T* buffer,
                                                                 MML1_RF_BSIMM_PORT_T* port_sel);
void EL1D_MMRF_RFCAL_STX_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, MML1_RF_BSIMM_PORT_T port_sel);
void EL1D_MMRF_RFCAL_SRX_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, MML1_RF_BSIMM_PORT_T port_sel);
void EL1D_MMRF_RFCAL_TX_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, MML1_RF_BSIMM_PORT_T port_sel);
void EL1D_MMRF_RFCAL_LIN_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, MML1_RF_BSIMM_PORT_T port_sel);
void EL1D_MMRF_RFCAL_DPD_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, MML1_RF_BSIMM_PORT_T port_sel);

void EL1D_RF_CAL_Set_Rx_Path_Ctrl_CW(MMRFC_RX_CW_PARAM_T* rx_cw_param, MMRFC_RX_CAL_CFG_T* rx_cfg);
void EL1D_RF_CAL_Set_Rx_Mixer_Gate_Bias_CW(MMRFC_RX_CW_PARAM_T* rx_cw_param, MMRFC_RX_CAL_CFG_T* rx_cfg);
void EL1D_RF_CAL_Set_Rx_LO_Ctrl_CW(MMRFC_RX_CW_PARAM_T* rx_cw_param,  MMRFC_RX_CAL_CFG_T* rx_cfg);
void EL1D_RF_CAL_Set_Srx_Config_CW(MMRFC_RX_CW_PARAM_T* rx_cw_param, MMRFC_RX_CAL_CFG_T* rx_cfg);
void EL1D_RF_CAL_Set_Srx_Config_CW_For_Tx_Leakage(MMRFC_RX_CW_PARAM_T* rx_cw_param, MMRFC_RX_CAL_CFG_T* rx_cfg);

kal_bool EL1D_BAND_ENUM_Check(void);
kal_bool EL1D_SUPPORT_BAND_Check(void);


/*MT6293 RFC RXDFE API*/
void EL1D_RFC_RXDFE_Meas_Trigger(MMRFC_RX_CAL_TYPE_E rx_cal_type, kal_uint16 meas_atime);
void EL1D_RFC_RXDFE_Config(MMRFC_RX_CAL_TYPE_E rx_cal_type, kal_uint32 agg_bw, MMRFC_PATH_BITMAP_E path_sel);
void EL1D_RFC_RXDFE_Win_On_Ctrl(MMRFC_RX_CAL_TYPE_E rx_cal_type);
void EL1D_RFC_RXDFE_Win_Off_Ctrl(MMRFC_RX_CAL_TYPE_E rx_cal_type);
void EL1D_RFC_RF_RXDFE_Comp_Imm(RF_COMP_INDEX_E comp_idx, MMRFC_PATH_BITMAP_E path_sel, MML1_RF_BSIMM_PORT_T rfic, MMRFC_RX_GAIN_T rx_gain_info, kal_uint16 rx_rf_route_idx);

/* API for IIP2 sepcial handling*/
void EL1D_RFC_IIP2_SPECIAL_HANDLING( MMRFC_XL1_BAND_NUM_E band, MMRFC_TX_CAL_CFG_T *iip2_tx_cfg_p );

/** API for TAS*/
kal_bool EL1D_RF_TAS_Support(void);
void EL1C_RF_Force_TAS(kal_bool force_tas_enable, kal_uint8 tas_idx);

void EL1D_RFC_RXIRR_Gain_Config(MMRFC_RXIRR_CAL_MODE_E irr_mode_idx, kal_uint32 rx_gain_idx, RXIF_GAIN_E* pga_gain_p, RX_LNA_GAIN_E* lna_gain_p, RX_TIA_GAIN_E* tia_gain_p);
void EL1D_RFC_RXDC_Gain_Config(MMRFC_POWER_MODE_E dc_mode_idx, kal_uint32 rx_gain_idx, RXIF_GAIN_E* pga_gain_p, RX_LNA_GAIN_E* lna_gain_p, RX_TIA_GAIN_E* tia_gain_p);
void EL1D_RFC_RXIIP2_Gain_Config(RXIF_GAIN_E* pga_gain_p, RX_LNA_GAIN_E* lna_gain_p, RX_TIA_GAIN_E* tia_gain_p);
void EL1D_RFC_RxGainCW(MMRFC_RX_CW_PARAM_T* rx_cw_param, MMRFC_RXIRR_CAL_MODE_E irr_mode_idx, kal_uint32 rx_gain_idx,
                                    MMRFC_PATH_BITMAP_E path_sel, MML1_RF_BSIMM_PORT_T rfic);

/** API for TDD/FDD band distiguishing @ lrfcal.c*/
kal_bool EL1D_MMRF_IS_TDD_BAND( MMRFC_XL1_BAND_NUM_E band );

/** TXLO related */
kal_uint32 EL1D_RFC_SET_CW714( MMRFC_XL1_BAND_NUM_E band, kal_uint32 freq_chan/*100KHz*/, kal_uint32 freq_tx_band_center/*100KHz*/
                             ,MMRFC_TX_LO_ELEMENT_T* tx_lo_cal_result_p, kal_bool is_hrm_enable);

/** RFC Result WB Functions */
void EL1D_RF_CAL_DETCDCOC_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                            kal_uint32 det_coarse_dcoc_cw807, 
                                            kal_uint32 det_coarse_dcoc_cw808);
void EL1D_RF_CAL_DETDC_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                         MMRFC_DET_G_IDX gain_idx,
                                         kal_uint32 recal,
                                         MMRFC_DET_DC_RESULT_T* tx_det_dc_calgo_result,
                                         kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_DETFIIQ_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                           MMRFC_DET_G_IDX det_gain_idx,
                                           MMRFC_TX_RAT_CBW_CFG_E cbw_case_idx,
                                           kal_uint32 recal,
                                           MMRFC_DET_IQDNL_RESULT_T* tx_det_iqdnl_calgo_result,
                                           kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_DETDNL_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                          MMRFC_DET_G_IDX det_gain_idx,
                                          kal_uint32 recal,
                                          MMRFC_DET_IQDNL_RESULT_T* tx_det_iqdnl_calgo_result,
                                          kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_DETFDPCB_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                            MMRFC_DET_TIA_COMP_INDEX_E fe_gain_idx,
                                            MMRFC_TX_RAT_CBW_CFG_E cbw_case_idx,
                                            kal_uint32 recal,
                                            MMRFC_DET_EQLPF_CFG_T* tx_det_pcb_calgo_result,
                                            kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_TXLO_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                        kal_uint32 rfc_rt_idx,
                                        MMRFC_XL1_BAND_NUM_E band,
                                        LTE_TX_SPLIT_BAND_SUBBAND_INDEX_E subband_idx,
                                        kal_uint8  ind_sw, 
                                        kal_uint8  capcal_peak_cap, 
                                        kal_uint8  in_bias_lpm, 
                                        kal_uint8  in_bias_hpm);
void EL1D_RF_CAL_STX_DCC_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                           kal_int32  delta_duty_cycle1);
void EL1D_RF_CAL_TXRC_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                        MMRFC_LPF_RCF_CAL_TYPE_E lpf_rcf_select,
                                        kal_int16 tx_rc_calgo_result,
                                        kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_TXFDAD_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                          MMRFC_TX_RAT_CBW_CFG_E cbw_case_idx,
                                          kal_uint32 tx_pga_slice,
                                          kal_uint32 recal,
                                          MMRFC_TX_FD_FILT_RESULT_T* tx_fdiq_calgo_result,
                                          kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_TXDC_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                        MMRFC_TX_RAT_CBW_CFG_E cbw_case_idx,
                                        kal_uint32 pwr_mode,
                                        kal_uint32 tx_pga_slice,
                                        kal_uint32 recal,
                                        MMRFC_TX_IQDC_RESULT_T* tx_iqdc_calgo_result,
                                        kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_TXFIIQ_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                          MMRFC_TX_RAT_CBW_CFG_E cbw_case_idx,
                                          kal_uint32 pwr_mode,
                                          kal_uint32 tx_pga_slice,
                                          kal_uint32 recal,
                                          MMRFC_TX_IQDC_RESULT_T* tx_iqdc_calgo_result,
                                          kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_TXGA_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                        kal_uint32 rfc_rt_idx,
                                        MMRFC_XL1_BAND_NUM_E band,
                                        LTE_TX_SPLIT_BAND_SUBBAND_INDEX_E subband_idx,
                                        MMRFC_TX_RAT_CBW_CFG_E cbw_case_idx,
                                        kal_uint32 pga_type,
                                        kal_uint32 recal,
                                        MMRFC_TX_GA_RESULT_T* tx_ga_calgo_result,
                                        kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_TXCAP_RESULT_WRITE_BACK(kal_uint32 route_idx,
                                         kal_uint32 rfc_rt_idx,
                                         MMRFC_XL1_BAND_NUM_E band,
                                         LTE_TX_SPLIT_BAND_SUBBAND_INDEX_E subband_idx,
                                         kal_uint8  pga_ab,
                                         kal_bool   is_pre_cap_tuning,
                                         kal_uint8  CAP_OPT_A,
                                         kal_uint8  CAP_OPT_B,
                                         kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RF_CAL_TXDNL_RESULT_WRITE_BACK(kal_bool is_tx_dnl_valid,
                                         kal_uint32 route_idx,
                                         ETPC_TX_DNL_COMP_T* dnl_cal_result,
                                         kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RFC_RXDC_RESULT_WRITE_BACK(MMRFC_POWER_MODE_E dc_mode_idx,
                                     kal_uint8 tia_gain_idx,
                                     kal_uint8 if_gain_idx,
                                     kal_uint16 dc_route_idx,
                                     kal_uint8 ant_idx,
                                     MMRFC_RX_DC_RESULT_T* rf_dc,
                                     MMRFC_RX_DC_RESULT_T* dig_dc,
                                     kal_uint8 re_cal_index,
                                     kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RFC_RXIRR_RESULT_WRITE_BACK(MMRFC_RXIRR_CAL_MODE_E irr_mode_idx,
                                      kal_uint16 irr_route_idx,
                                      MMRFC_RX_RAT_CBW_CFG_E rx_cbw,
                                      kal_uint8 ant_idx,
                                      MMRFC_RX_IRR_RESULT_T* rx_irr_data,
                                      kal_uint8 re_cal_index,
                                      kal_uint16 internal_ms_elapsed_time_check_flag);
void EL1D_RFC_RXIIP2_RESULT_WRITE_BACK(kal_uint16 iip2_route_idx,
                                       MMRFC_IIP2_RESULT_T* rxp_iip2,
                                       MMRFC_IIP2_RESULT_T* rxd_iip2,
                                       kal_uint16 internal_ms_elapsed_time_check_flag);

/* RCF_CSEL_ADJUSTMENT for TX_RCK result write back */
kal_uint16 EL1D_RFC_RCF_CSEL_ADJUSTMENT(kal_uint32 rfd_rt_idx, kal_bool is_cca, kal_uint16 rcf_csel);

/* Calculate DET PGA cap code from lpf Nsel*/
kal_int32 EL1D_RFC_DET_PGA_CALCULATE(kal_uint32 rcf_csel);

/* Fetch TXRCF_E for CW793 CW Gen */
TXRCF_E EL1D_RFC_RCF_BW_SETTING(EL1D_RF_CAL_RCF_INFO_DATA_T *rcf_info);

/* Fetch pre-cap-tuning or cap-tuning cal result for calibration run-time PGA cap CW setting */
void EL1D_RFC_GET_PGA_CAP_TUNING_RESULT(kal_bool is_pre_cap_tuning,
                                        kal_uint32 route_idx,
                                        kal_uint32 rfc_rt_idx,
                                        MMRFC_XL1_BAND_NUM_E band,
                                        LTE_TX_SPLIT_BAND_SUBBAND_INDEX_E subband_idx,
                                        ETXRF_TX_CAP_TUNING_COMP_T* cap_tuning_val);

const LTE_RF_POC_TX_LO_RELEVANT_COMP_CAL_DATA_T* EL1D_Get_TX_LO_Relevant_CW_Table_By_Band(MMRFC_XL1_BAND_NUM_E band, kal_bool is_hrm);
void EL1D_RF_POC_RX_ON_BPI_CTRL(kal_uint32 rx_route, kal_uint8* length, MMRFC_RX_ON_BPI_CTRL_BUFFER_T* buffer);
void EL1D_RF_POC_RX_OFF_BPI_CTRL(kal_uint32 rx_route, kal_uint8* length, MMRFC_RX_OFF_BPI_CTRL_BUFFER_T* buffer);
void EL1D_RFC_RX_TX_LEAKAGE_MEAS_Gain_Config(RXIF_GAIN_E* pga_gain_p, RX_LNA_GAIN_E* lna_gain_p, RX_TIA_GAIN_E* tia_gain_p);
void EL1D_RFC_Get_High_Low_Freq_By_Band(LTE_Band band,  kal_bool is_ul, kal_uint16 *low_freq, kal_uint16 *high_freq);
void EL1D_RF_POC_Tx_Power_Config(LTE_Band band, LTE_Route route, kal_uint16 tx_freq, kal_int16 pa_out, kal_uint32* pa_lvl, kal_uint8* dc2dc_lvl, kal_uint32* tx_pga_mode, kal_uint32* tx_pga_gain, kal_uint32* dfe_gain);
void EL1D_MMRF_RFCAL_TX_PA_ETM_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, 
                                                                            kal_uint32 pa_lvl,
                                                                            kal_uint16 ul_freq,
                                                                            kal_bool etm_on,
                                                                            kal_uint8* length,
                                                                            MMRFC_TXPA_ETM_CONFIG_BUFFER_T* buffer);
void EL1D_MMRF_RFCAL_TX_PA_ON_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, 
                                                                            kal_uint16 ul_freq,
                                                                            kal_uint32 pa_lvl,
                                                                            kal_uint8* length,
                                                                            MMRFC_TXPA_ON_LOWGAIN_BUFFER_T* buffer);
void EL1D_MMRF_RFCAL_TX_ON_BPI_CTRL_CONFIG_BUFFER_LVL(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p, 
                                                                            kal_uint8* length,
                                                                            kal_uint32 pa_lvl,
                                                                            MMRFC_TX_ON_BPI_CTRL_BUFFER_T* buffer, 
                                                                            kal_uint8 is_txcca);
void EL1D_MMRF_RFCAL_TX_LEAK_PA_OFF_CONFIG_BUFFER(MMRFC_XL1_BAND_SUPPORT_CAPABILITY_T* band_cap_p,
                                                                 kal_uint16 ul_freq,
                                                                 kal_uint8* length,
                                                                 MMRFC_TXPA_OFF_BUFFER_T* buffer);
void EL1D_RFC_GetRxTxLeakageConfigTable( LTE_Band band, MMRFC_RX_CAL_TX_LEAKAGE_CFG_T* tx_leakage_cfg);
void EL1D_RF_CAL_Set_TX_CW_Rx_Tx_Leakage_Meas_CAL(MMRFC_TX_CAL_CFG_T *tx_cfg);
void EL1D_RFC_RX_TX_LEAKAGE_RESULT_WRITE_BACK(kal_uint16 irr_route_idx, kal_uint32 *max_leakage_pwr, kal_uint16 internal_ms_elapsed_time_check_flag);
/* For META debug tool */
#if LTE_ANALYZED_BY_RFTOOL_ENABLE
kal_uint32 El1D_RFC_GetDetRouteInfo(kal_int32* ca_band, kal_int32 meas_band_idx, MMRFC_TX_CAL_ITEM_CFG_E cal_item);
kal_uint32 El1D_RFC_GetTxRouteInfo(kal_int32* ca_band, kal_int32 meas_band_idx, MMRFC_TX_CAL_ITEM_CFG_E cal_item);
kal_uint32 El1D_RFC_GetRxRouteInfo(kal_int32* ca_band, kal_int32 meas_band_idx, MMRFC_TX_CAL_ITEM_CFG_E cal_item);
#endif

/* API for DAT feature @lrfgeneral.c*/
kal_bool EL1D_RF_AP_Sensor_Relative_Feature_IS_Need_L1C_GAP(MMRF_AP_SENSOR_RELATIVE_OP_CODE_E OP_code, kal_int16 scenario);
#if IS_EL1D_RF_MT6177L
kal_uint32 EL1D_RFC_GET_LPF_F3DB_CSEL(kal_uint32 tx_self_comp_idx, MMRFC_TX_RAT_CBW_CFG_E cbw_idx);
#endif
LTE_RF_CAL_DATA_T* EL1D_RFC_DB_Get_RF_CAL_DATA_Addr( void );

//LTE TAS Config API for META
kal_uint16 EL1D_IsQueryingTasStateInfoSupported(void);
kal_uint16 EL1D_QueryTasVersion(void);
kal_uint16 EL1D_GetTasStateConfigBandNum(void);
void EL1D_GetTasStateConfig(kal_uint16 buf_length, kal_uint16* band_list, kal_uint16* state_limit, kal_uint16* tas_state);

extern void EL1TST_RF_Force_TAS(kal_bool force_tas_enable, kal_uint8 tas_idx);

#endif /* End of #ifndef _EL1D_MMRF_INTERFACE_H_ */
