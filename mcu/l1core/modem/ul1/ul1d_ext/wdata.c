/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * wdata.c
 *
 * Project:
 * --------
 * MT6268
 *
 * Description:
 * ------------
 * Variables/Arrays for customer to make their own configurations.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *----------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *----------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/*===============================================================================*/
#include "kal_general_types.h"

#include "ul1d_rf_public.h"
#include "ul1d_rf_common.h"
#include "ul1d_rf_cid.h"
#include "ul1cal.h"
#include "mml1_dpd_def.h"
/*===============================================================================*/

#if defined(__MTK_TARGET__)

#define __ATTRIBUTE_SECTION__(_s) __attribute__ ((section(#_s)))
#define __ATTRIBUTE_ALIGNED__(_a) __attribute__ ((aligned((_a))))
#define __ATTRIBUTE_ZI__          __attribute__ ((zero_init))

#else

#define __ATTRIBUTE_SECTION__(_s)
#define __ATTRIBUTE_ALIGNED__(_a) 
#define __ATTRIBUTE_ZI__  

#endif 

#define __SECTION_INTSRAM_RODATA__   //Removed due to AutoTCM __ATTRIBUTE_SECTION__(INTSRAM_RODATA)
/* #define __SECTION_INTSRAM_ROCODE__   //Removed due to AutoTCM __ATTRIBUTE_SECTION__(INTSRAM_ROCODE) */ /* remove after tk6291 */
#define __SECTION_INTSRAM_ZI__       //Removed due to AutoTCM __ATTRIBUTE_SECTION__(INTSRAM_ZI)
#define __SECTION_INTSRAM_RW__       //Removed due to AutoTCM __ATTRIBUTE_SECTION__(INTSRAM_RW)

#define __SECTION_NONCACHEDZI__      __ATTRIBUTE_SECTION__(NONCACHEDZI) __ATTRIBUTE_ZI__
#define __SECTION_NONCACHEDRW__      __ATTRIBUTE_SECTION__(NONCACHEDRW) 

#define __SECTION_DYNAMICCACHEABLEZI_C__   __ATTRIBUTE_SECTION__(DYNAMICCACHEABLEZI_C) __ATTRIBUTE_ZI__


#define MAX_DIST(m,n) (((m)>(n))?(m):(n))
#define MIN_DIST(m,n) (((m)<(n))?(m):(n))

//BPI timing default invalid zero definition for l1core. MUST to be defined in ul1d_custom_rf.h in pcore
#ifndef TC_PR1
#define  TC_PR1     0
#endif
#ifndef TC_PR2
#define  TC_PR2     0
#endif
#ifndef TC_PR3
#define  TC_PR3     0
#endif
#ifndef TC_PT1
#define  TC_PT1     0
#endif
#ifndef TC_PT2
#define  TC_PT2     0
#endif
#ifndef TC_PT3
#define  TC_PT3     0
#endif

kal_uint16 max_offset   =  0; /*MAX_OFFSET*/
__SECTION_INTSRAM_RW__
kal_uint16 vm_offset    =  0; /*(MAX_OFFSET - VM_OFFSET)*/
kal_uint16 vbias_offset =  0; /*(MAX_OFFSET - VBIAS_OFFSET)*/
kal_uint16 dc2dc_offset =  0; /*(MAX_OFFSET - DC2DC_OFFSET)*/
kal_uint16 vga_offset   =  0; /*(MAX_OFFSET - VGA_OFFSET)*/


/*Notes: due to use SR(T)1,PR(T)1,SR(T)3,PR(T)3 for max and min distance calculating, which is
         used for the RF timer setting, so must make sure the SR1,PR1 must larger than other
         event timing, and PT1,ST1 is smaller than other event timing, even in ul1d_custom_rf.h
         you can set like SR2>SR1 */
#define MAX_RX_START_OFFSET MAX_DIST(TC_SR1, TC_PR1)
#define MAX_TX_START_OFFSET MAX_DIST(TC_ST1, TC_PT1)
#define MAX_RX_END_OFFSET MAX_DIST(TC_SR3, TC_PR3A)
#define MAX_TX_END_OFFSET MAX_DIST(TC_ST3, TC_PT3A)
#define MIN_RX_END_OFFSET MIN_DIST(TC_SR3, TC_PR3)
#define MIN_TX_END_OFFSET MIN_DIST(TC_ST3, TC_PT3)

#define MAX_MODE_START_OFFSET MAX_DIST(TC_SR2B, TC_ST2C)

kal_int16 max_rx_start_offset = MAX_RX_START_OFFSET;
kal_int16 max_tx_start_offset = MAX_TX_START_OFFSET;

kal_int16 max_txcal_start_offset = TC_ST_CAL;

kal_int16 max_rx_end_offset = MAX_RX_END_OFFSET;
kal_int16 max_tx_end_offset = MAX_TX_END_OFFSET;

kal_int16 min_rx_end_offset = MIN_RX_END_OFFSET;

kal_int16 min_tx_end_offset = MIN_TX_END_OFFSET;

kal_uint8 max_rx_end_reg_idx;
kal_int16 min_rx_off_evt_cancel_margin;

//Add for R8 to support RXD and Dual cell
kal_int16 max_rx_dc_reconfig_offset = TC_DC_SR1;
kal_int16 max_rxd_start_offset = MAX_DIST(TC_RXD_SR1, TC_PR1_2); 
kal_int16 min_rxd_end_offset = MIN_DIST(TC_RXD_SR3, TC_PR3_2);
//kal_int16 max_rxd_start_offset = MAX_DIST(TC_RXD_SR1, TC_PR1); 
//kal_int16 min_rxd_end_offset = MIN_DIST(TC_RXD_SR3, TC_PR3)

#if IS_3G_MIPI_SUPPORT
kal_uint16 ul1_mipi_offset  =  0; /*(MAX_OFFSET - MIPI_OFFSET)*/
kal_bool is_3g_mipi_enable = KAL_TRUE;
#endif

kal_bool is_3g_pga_ab_k_enable = KAL_TRUE;

kal_uint8  pa_section = 3;

kal_int16  UMTS_RX_START_TQ_TABLE[6] =
{
   /* TQ_SLOT_BEGIN(i) + */ -TC_SR1,
   /* TQ_SLOT_BEGIN(i) + */ -TC_SR2,
   /* TQ_SLOT_BEGIN(i) + */ -TC_SR2B,
   /* TQ_SLOT_BEGIN(i) + */ -TC_PR1,
   /* TQ_SLOT_BEGIN(i) + */ -TC_PR2,
   /* TQ_SLOT_BEGIN(i) + */ -TC_PR2B
};


kal_int16  UMTS_RX_END_TQ_TABLE[3] =
{
   /* TQ_SLOT_BEGIN(i) + */ TC_SR3,
   /* TQ_SLOT_BEGIN(i) + */ TC_PR3,
   /* TQ_SLOT_BEGIN(i) + */ TC_PR3A
};


kal_int16  UMTS_TX_START_TQ_TABLE[7] =
{
   /* TQ_SLOT_BEGIN(i) + */ -TC_ST1,
   /* TQ_SLOT_BEGIN(i) + */ -TC_ST2,
   /* TQ_SLOT_BEGIN(i) + */ -TC_ST2B,
   /* TQ_SLOT_BEGIN(i) + */ -TC_ST2C,
   /* TQ_SLOT_BEGIN(i) + */ -TC_PT1,
   /* TQ_SLOT_BEGIN(i) + */ -TC_PT2,
   /* TQ_SLOT_BEGIN(i) + */ -TC_PT2B
};

kal_int16  UMTS_TX_END_TQ_TABLE[3] =
{
   /* TQ_SLOT_BEGIN(i) + */ TC_ST3,
   /* TQ_SLOT_BEGIN(i) + */ TC_PT3,
   /* TQ_SLOT_BEGIN(i) + */ TC_PT3A
};

//Add following table to support RXD and Dual Cell
kal_int16  UMTS_RX_OFF2ON_TQ_TABLE[3] =
{
   -TC_DC_SR1,
   -TC_DC_SR2,
   -TC_DC_SR2B,
};

#if IS_RF_RXD_SUPPORT
kal_int16  UMTS_RXD_START_TQ_TABLE[7] =
{
   -TC_RXD_SR1,
   -TC_PR1,
   -TC_PR2,
   -TC_PR2B,
   -TC_PR1_2,
   -TC_PR2_2,
   -TC_PR2B_2
};

kal_int16  UMTS_RXD_END_TQ_TABLE[5] =
{
   TC_RXD_SR3,
   TC_PR3,
   TC_PR3A,
   TC_PR3_2,
   TC_PR3A_2
};
#endif

//Notes: UMTS_PDATA_TABLE is used to determine which pin is for Rx and which pin is for Tx
//       so can't put other data except BPI here
BPI_data_type  UMTS_PDATA_TABLE[][2][5] =
{     /* FrequencyBand0  */
   {  {  PDATA_BAND1_PR1, PDATA_BAND1_PR2, PDATA_BAND1_PR2B, PDATA_BAND1_PR3, PDATA_BAND1_PR3A  } ,   /* RX */
      {  PDATA_BAND1_PT1, PDATA_BAND1_PT2, PDATA_BAND1_PT2B, PDATA_BAND1_PT3, PDATA_BAND1_PT3A  } ,   /* TX */
   }, /* FrequencyBand1  */
   {  {  PDATA_BAND1_PR1, PDATA_BAND1_PR2, PDATA_BAND1_PR2B, PDATA_BAND1_PR3, PDATA_BAND1_PR3A  } ,   /* RX */
      {  PDATA_BAND1_PT1, PDATA_BAND1_PT2, PDATA_BAND1_PT2B, PDATA_BAND1_PT3, PDATA_BAND1_PT3A  } ,   /* TX */
   }, /* FrequencyBand2  */
   {  {  PDATA_BAND2_PR1, PDATA_BAND2_PR2, PDATA_BAND2_PR2B, PDATA_BAND2_PR3, PDATA_BAND2_PR3A  } ,   /* RX */
      {  PDATA_BAND2_PT1, PDATA_BAND2_PT2, PDATA_BAND2_PT2B, PDATA_BAND2_PT3, PDATA_BAND2_PT3A  } ,   /* TX */
   }, /* FrequencyBand4 */
   {  {  PDATA_BAND4_PR1, PDATA_BAND4_PR2, PDATA_BAND4_PR2B, PDATA_BAND4_PR3, PDATA_BAND4_PR3A  } ,   /* RX */
      {  PDATA_BAND4_PT1, PDATA_BAND4_PT2, PDATA_BAND4_PT2B, PDATA_BAND4_PT3, PDATA_BAND4_PT3A  } ,   /* TX */
   }, /* FrequencyBand5  */
   {  {  PDATA_BAND5_PR1, PDATA_BAND5_PR2, PDATA_BAND5_PR2B, PDATA_BAND5_PR3, PDATA_BAND5_PR3A  } ,   /* RX */
      {  PDATA_BAND5_PT1, PDATA_BAND5_PT2, PDATA_BAND5_PT2B, PDATA_BAND5_PT3, PDATA_BAND5_PT3A  } ,   /* TX */
   }, /* FrequencyBand8  */                                                                                
   {  {  PDATA_BAND8_PR1, PDATA_BAND8_PR2, PDATA_BAND8_PR2B, PDATA_BAND8_PR3, PDATA_BAND8_PR3A  } ,   /* RX */
      {  PDATA_BAND8_PT1, PDATA_BAND8_PT2, PDATA_BAND8_PT2B, PDATA_BAND8_PT3, PDATA_BAND8_PT3A  } ,   /* TX */
   }
};

BPI_data_type  UMTS_PDATA_TABLE_H[][2][5] =
{     /* FrequencyBand0  */
   {  {  0, 0, 0, 0, 0  } ,   /* RX */
      {  0, 0, 0, 0, 0  } ,   /* TX */
   }, /* FrequencyBand1  */
   {  {  0, 0, 0, 0, 0  } ,   /* RX */
      {  0, 0, 0, 0, 0  } ,   /* TX */
   }, /* FrequencyBand2  */
   {  {  0, 0, 0, 0, 0  } ,   /* RX */
      {  0, 0, 0, 0, 0  } ,   /* TX */
   }, /* FrequencyBand4 */
   {  {  0, 0, 0, 0, 0  } ,   /* RX */
      {  0, 0, 0, 0, 0  } ,   /* TX */
   }, /* FrequencyBand5  */
   {  {  0, 0, 0, 0, 0  } ,   /* RX */
      {  0, 0, 0, 0, 0  } ,   /* TX */
   }, /* FrequencyBand8  */                                                                                
   {  {  0, 0, 0, 0, 0  } ,   /* RX */
      {  0, 0, 0, 0, 0  } ,   /* TX */
   }
};


//Notes: UMTS_PDATA2_TABLE is used to determine which pin is for RXD
//       so can't put other data except BPI here

BPI_data_type  UMTS_PDATA2_RX_TABLE[][5] =
{  /* FrequencyBand0  */
   {  PDATA2_BAND1_PR1, PDATA2_BAND1_PR2, PDATA2_BAND1_PR2B, PDATA2_BAND1_PR3, PDATA2_BAND1_PR3A  } ,   /* RX */
   /* FrequencyBand1  */
   {  PDATA2_BAND1_PR1, PDATA2_BAND1_PR2, PDATA2_BAND1_PR2B, PDATA2_BAND1_PR3, PDATA2_BAND1_PR3A  } ,   /* RX */
   /* FrequencyBand2  */
   {  PDATA2_BAND2_PR1, PDATA2_BAND2_PR2, PDATA2_BAND2_PR2B, PDATA2_BAND2_PR3, PDATA2_BAND2_PR3A  } ,   /* RX */
   /* FrequencyBand4 */
   {  PDATA2_BAND4_PR1, PDATA2_BAND4_PR2, PDATA2_BAND4_PR2B, PDATA2_BAND4_PR3, PDATA2_BAND4_PR3A  } ,   /* RX */
   /* FrequencyBand5  */
   {  PDATA2_BAND5_PR1, PDATA2_BAND5_PR2, PDATA2_BAND5_PR2B, PDATA2_BAND5_PR3, PDATA2_BAND5_PR3A  } ,   /* RX */
   /* FrequencyBand8  */                                                                                
   {  PDATA2_BAND8_PR1, PDATA2_BAND8_PR2, PDATA2_BAND8_PR2B, PDATA2_BAND8_PR3, PDATA2_BAND8_PR3A  } ,   /* RX */
};

BPI_data_type  UMTS_PDATA2_RX_TABLE_H[][5] =
{  /* FrequencyBand0  */
   {  0, 0, 0, 0, 0  } ,   /* RX */
   /* FrequencyBand1  */
   {  0, 0, 0, 0, 0  } ,   /* RX */
   /* FrequencyBand2  */
   {  0, 0, 0, 0, 0  } ,   /* RX */
   /* FrequencyBand4 */
   {  0, 0, 0, 0, 0  } ,   /* RX */
   /* FrequencyBand5  */
   {  0, 0, 0, 0, 0  } ,   /* RX */
   /* FrequencyBand8  */                                                                                
   {  0, 0, 0, 0, 0  } ,   /* RX */
};

#if (IS_3G_TAS_ANTENNA_IDX_ON_TEST_SIM)
UMTS_TAS_ANT_IDX_T UMTS_TAS_ANT_IDX_by_band;
#endif

kal_uint8 DC2DC[3/*pa_mode*/] = 
{
   DC2DC_H,
   DC2DC_M,
   DC2DC_L
};

kal_uint8 VM_data[3/*pa_mode*/] = 
{
   VM_H,
   VM_M,
   VM_L
};


/* mtk02653: For checking the notch tuning scenario (cases) */
/* and also checking whether wrong customer setting exists. */
UL1_RF_RX_IO_E band1_ch_sel =  BAND1_CHANNEL_SEL;
UL1_RF_RX_IO_E band2_ch_sel =  BAND2_CHANNEL_SEL;
UL1_RF_RX_IO_E band3_ch_sel =  BAND3_CHANNEL_SEL;
UL1_RF_RX_IO_E band4_ch_sel =  BAND4_CHANNEL_SEL;

UL1_RF_RX_IO_E band5_ch_sel =  BAND5_CHANNEL_SEL;
UL1_RF_RX_IO_E band6_ch_sel =  BAND6_CHANNEL_SEL;
UL1_RF_RX_IO_E band8_ch_sel =  BAND8_CHANNEL_SEL;
UL1_RF_RX_IO_E band9_ch_sel =  BAND9_CHANNEL_SEL;
UL1_RF_RX_IO_E band10_ch_sel = BAND10_CHANNEL_SEL;
UL1_RF_RX_IO_E band11_ch_sel = BAND10_CHANNEL_SEL;
UL1_RF_RX_IO_E band19_ch_sel = BAND19_CHANNEL_SEL;

#if IS_RF_RXD_SUPPORT
UL1_RF_RXD_IO_E band1_ch2_sel =  BAND1_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band2_ch2_sel =  BAND2_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band3_ch2_sel =  BAND3_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band4_ch2_sel =  BAND4_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band5_ch2_sel =  BAND5_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band6_ch2_sel =  BAND6_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band8_ch2_sel =  BAND8_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band9_ch2_sel =  BAND9_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band10_ch2_sel = BAND10_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band11_ch2_sel = BAND11_CHANNEL2_SEL;
UL1_RF_RXD_IO_E band19_ch2_sel = BAND19_CHANNEL2_SEL;
#endif

kal_bool pmu_pasetting = KAL_TRUE;
kal_bool ultra_low_cost= KAL_FALSE;
kal_bool TM_enable = TEAMPERATURE_MEAS_EN;
kal_bool VPA_mode_setting = KAL_FALSE;

#if defined (__UMTS_R8__) 
/** [20130429 LY] replace 0xFFFFFFFF by custom setting to avoid false alarm of cal. data download */
//Should be quered by Band, customize in rf_custim.h to indicate support of RXD
kal_uint32 rxd_support_mask = 0x0;

kal_uint32 rx_diversity_always_on = KAL_FALSE;
kal_uint32 pa_dirft_bitmap        = 0x0;
#endif
kal_bool is_band5_and_band6_indicator = KAL_FALSE;

#if IS_3G_B5_AND_B19_INDICATOR_SUPPORT
kal_bool is_band5_and_band19_indicator = KAL_FALSE;
kal_bool is_disable_band5_indicator = KAL_FALSE;
#endif

kal_uint8 ul1d_BandInfo[5] ={ UMTSBand1,
                              UMTSBand2,
                              UMTSBand4,
                              UMTSBand5,
                              UMTSBand8};

kal_uint32 ul1d_CaBandInfo[UMTS_RF_CA_FE_NUM_MAX] = {0};
UMTS_FE_ROUTE_TABLE_T  UMTS_FE_ROUTE_TBL[UMTS_RF_FRONT_END_NUM_MAX] = 
{
   {0, 0, {{0}}}
};

UMTS_RX_ROUTE_TABLE_T        UMTS_RX_ROUTE_TBL[UMTS_ROUTE_TBL_SIZE_MAX] = 
{
   {0, {{0}}, {0}, 0, 0, 0, 0}
};

UMTS_TX_ROUTE_TABLE_T        UMTS_TX_ROUTE_TBL[UMTS_ROUTE_TBL_SIZE_MAX] =
{
   {0, {{0}}, {0}, 0, 0}
};

UMTS_RX_COMP_ROUTE_TABLE_T   UMTS_RX_COMP_ROUTE_TBL[UMTS_ROUTE_TBL_SIZE_MAX] = {0};
UMTS_TX_COMP_ROUTE_TABLE_T   UMTS_TX_COMP_ROUTE_TBL[UMTS_ROUTE_TBL_SIZE_MAX] = {0};

UMTS_USAGE_DES_T             UMTS_USAGE_TBL[UMTS_USAGE_TBL_SIZE_MAX] = 
{
   {{0}, {0}, 0, {0}}
};

UL1_RF_TX_IO_E band_output_sel[20]={TX_NULL_BAND,
                                    BAND1_OUTPUT_SEL,
                                    BAND2_OUTPUT_SEL,
                                    BAND3_OUTPUT_SEL,
                                    BAND4_OUTPUT_SEL,
                                    BAND5_OUTPUT_SEL,
                                    BAND6_OUTPUT_SEL,
                                    TX_NULL_BAND,
                                    BAND8_OUTPUT_SEL,
                                    BAND9_OUTPUT_SEL,
                                    BAND10_OUTPUT_SEL,
                                    BAND11_OUTPUT_SEL,
                                    TX_NULL_BAND,
                                    TX_NULL_BAND,
                                    TX_NULL_BAND,
                                    TX_NULL_BAND,
                                    TX_NULL_BAND,
                                    TX_NULL_BAND,
                                    TX_NULL_BAND,
                                    BAND19_OUTPUT_SEL};

UL1_RF_TX_DET_IO_E band_output_det_sel[20]={TX_NULL_BAND,
                                            BAND1_OUTPUT_DET_SEL,
                                            BAND2_OUTPUT_DET_SEL,
                                            BAND3_OUTPUT_DET_SEL,
                                            BAND4_OUTPUT_DET_SEL,
                                            BAND5_OUTPUT_DET_SEL,
                                            BAND6_OUTPUT_DET_SEL,
                                            TX_NULL_BAND,
                                            BAND8_OUTPUT_DET_SEL,
                                            BAND9_OUTPUT_DET_SEL,
                                            BAND10_OUTPUT_DET_SEL,
                                            BAND11_OUTPUT_DET_SEL,
                                            TX_NULL_BAND,
                                            TX_NULL_BAND,
                                            TX_NULL_BAND,
                                            TX_NULL_BAND,
                                            TX_NULL_BAND,
                                            TX_NULL_BAND,
                                            TX_NULL_BAND,
                                            BAND19_OUTPUT_DET_SEL};

kal_bool is_rf_setting_by_nvram = KAL_TRUE;
kal_bool is_rfic_bsi_port_swap = KAL_FALSE;

/* mtk02653: */
/* Pre-processing compiler option concerning to supported RF band mode  */
/* to see if there is any wrong customer configurations.                */

#if IS_PCORE_HANDLE
/*------------- Single Software Load for Multiple Components Compatible -------------*/
kal_uint8 ul1custom_debug_enable = UL1CUSTOM_DEBUG_ENABLE;
kal_uint8 ul1custom_gpio_set_nums = UL1CUSTOM_GPIO_SET_NUMS;
kal_uint8 ul1custom_adc_set_nums = UL1CUSTOM_ADC_SET_NUMS;
kal_uint8 ul1custom_nvram_barcode_set_nums = UL1CUSTOM_NVRAM_BARCODE_SET_NUMS;
kal_uint8 ul1custom_gpio_nums_in_calc = UL1CUSTOM_GPIO_NUMS_IN_CALC;
kal_uint8 ul1custom_ADC_nums_in_calc = UL1CUSTOM_ADC_NUMS_IN_CALC;
kal_uint8 ul1custom_nvram_barcode_nums_in_calc = UL1CUSTOM_NVRAM_BARCODE_NUMS_IN_CALC;
kal_uint8 ul1custom_first_index = UL1CUSTOM_FIRST_INDEX;
kal_uint8 ul1custom_second_index = UL1CUSTOM_SECOND_INDEX;
kal_uint8 ul1custom_third_index = UL1CUSTOM_THIRD_INDEX;
kal_uint8 ul1custom_first_index_base = UL1CUSTOM_FIRST_INDEX_BASE;
kal_uint8 ul1custom_gpio_num_of_detect_pins_in_use = UL1CUSTOM_GPIO_NUM_OF_DETECT_PINS_IN_USE;
kal_uint8 ul1custom_adc_level_total = UL1CUSTOM_ADC_LEVEL_TOTAL;
kal_uint8 ul1custom_barcode_read_digit_num = UL1CUSTOM_BARCODE_READ_DIGIT_NUM;
kal_uint8 ul1custom_barcode_digit_value_1 = UL1CUSTOM_BARCODE_DIGIT_VALUE_1;
kal_uint8 ul1custom_barcode_digit_value_2 = UL1CUSTOM_BARCODE_DIGIT_VALUE_2;
kal_uint8 ul1custom_barcode_digit_value_3 = UL1CUSTOM_BARCODE_DIGIT_VALUE_3;
kal_uint8 ul1custom_max_rf_support_band_num = UL1CUSTOM_MAX_RF_SUPPORT_BAND_NUM;
kal_uint8 ul1custom_adc_calibrate_enable = UL1CUSTOM_ADC_CALIBARTE_ENABLE;
kal_uint8 ul1custom_adc_bits = UL1CUSTOM_ADC_BITS;
kal_uint16 ul1custom_adc_meas_count_2_order = UL1CUSTOM_ADC_MEAS_COUNT_2_ORDER;
kal_uint16 ul1custom_total_set_nums = UL1CUSTOM_TOTAL_SET_NUMS;
kal_uint32 ul1custom_adc_max_input_voltage = UL1CUSTOM_ADC_MAX_INPUT_VOLTAGE;
/*------------- Single Software Load for Multiple Components Compatible -------------*/
#else
/*------------- Single Software Load for Multiple Components Compatible -------------*/
kal_uint8 ul1custom_debug_enable = 0;
kal_uint8 ul1custom_gpio_set_nums = 0;
kal_uint8 ul1custom_adc_set_nums = 0;
kal_uint8 ul1custom_nvram_barcode_set_nums = 0;
kal_uint8 ul1custom_gpio_nums_in_calc = 0;
kal_uint8 ul1custom_ADC_nums_in_calc = 0;
kal_uint8 ul1custom_nvram_barcode_nums_in_calc = 0;
kal_uint8 ul1custom_first_index = 0;
kal_uint8 ul1custom_second_index = 0;
kal_uint8 ul1custom_third_index = 0;
kal_uint8 ul1custom_first_index_base = 0;
kal_uint8 ul1custom_gpio_num_of_detect_pins_in_use = 0;
kal_uint8 ul1custom_adc_level_total = 0;
kal_uint8 ul1custom_barcode_read_digit_num = 0;
kal_uint8 ul1custom_barcode_digit_value_1 = 0;
kal_uint8 ul1custom_barcode_digit_value_2 = 0;
kal_uint8 ul1custom_barcode_digit_value_3 = 0;
kal_uint8 ul1custom_max_rf_support_band_num = 0;
kal_uint8 ul1custom_adc_calibrate_enable = 0;
kal_uint8 ul1custom_adc_bits = 0;
kal_uint16 ul1custom_adc_meas_count_2_order = 0;
kal_uint16 ul1custom_total_set_nums = 0;
kal_uint32 ul1custom_adc_max_input_voltage = 0;
/*------------- Single Software Load for Multiple Components Compatible -------------*/
#endif

kal_int32 pd_threshold = ((-5)<<5); // Power detection threshold

#ifdef MT6589
#ifdef SWEFUSE_SKIP
kal_bool sw_efuse_check_skip = KAL_TRUE;
#else
kal_bool sw_efuse_check_skip = KAL_FALSE;
#endif
#endif

/** DCXO/VCTCXO switch by difinition of AFC_VCXO, but need to be updated by MMRF API query*/
#if defined (AFC_VCXO)
kal_bool ul1d_afc_vcxo_support = KAL_TRUE;
#else
kal_bool ul1d_afc_vcxo_support = KAL_FALSE;
#endif


/*********************************************************************/
/**                        Custom RF Timing
/*********************************************************************/

kal_int16  ddpc_trigger_offset    = (-7);
kal_int16  meas_sample_offset_5M  = (-9);
kal_int16  wait_sample_offset_5M  = (34);
kal_int16  meas_sample_offset_10M = (0); 
kal_int16  wait_sample_offset_10M = (0);
kal_int16  adc_off_offset_0 = (3);
kal_int16  adc_off_offset_1 = (2);
kal_int16  adc_off_offset_2 = (2);

kal_uint32  tri_sw_lm1 = 50;    
kal_uint32  tri_sw_et1 = 50;    
kal_uint32  tri_sw_dpd = 50;    
kal_uint32  tri_sw_lm2 = 50;    
kal_uint32  tri_sw_et2 = 50;    

/*********************************************************************/
/**                        Custom RF Data Pointer Structure Declare
/*********************************************************************/
U_sUl1dRfCustomInputData *UMTS_RF_CUSTOM_INPUT_DATA_ptr;

#if IS_3G_ELNA_IDX_SUPPORT
UMTS_CUSTOM_ELNA_IDX_T *UMTS_ELNA_IDX_LUT_ptr;
#endif/*IS_3G_ELNA_IDX_SUPPORT*/

#if IS_3G_FDD_INTERFERENCE_CHECK_SUPPORT
UMTS_RF_INTERFERENCE_FREQUENCY_T *UMTS_RF_INTERFERENCE_FREQUENCY_ptr;
#endif/*IS_3G_FDD_INTERFERENCE_CHECK_SUPPORT*/

#if (IS_3G_TX_POWER_OFFSET_SUPPORT || IS_3G_SAR_TX_POWER_BACKOFF_SUPPORT)
U_sTXPOWEROFFSETDATA *UMTS_TX_POWER_OFFSET_TABLE[UL1D_RF_CUSTOM_BAND];
#endif

#if(IS_3G_RX_POWER_OFFSET_SUPPORT)
U_sRXPOWEROFFSETDATA *UMTS_RX_POWER_OFFSET_TABLE[UL1D_RF_CUSTOM_BAND];
#endif
#if (IS_3G_VPA_SEL_BY_BAND_SUPPORT)
UMTS_VPA_SOURCE_TYPE            * UMTS_VPA_SRC_SEL_TABLE[UL1D_RF_CUSTOM_BAND];
#endif

/*********************************************************************/
/**                        Calibration Data Pointer Structure Declare
/*********************************************************************/
#if IS_3G_RF_NCCA_SUPPORT
U_sTEMPAGCOFFSET    *U_AGC_PATHLOSS_TABLE[UMTS_AGC_PATHLOSS_TBL_SIZE];
U_sTEMPAGCOFFSET    *U_AGC_PATHLOSS_RXD_TABLE[UMTS_AGC_PATHLOSS_TBL_SIZE]; //RXD path loss
#else
U_sTEMPAGCOFFSET    *U_AGC_PATHLOSS_TABLE[UL1D_RF_CUSTOM_BAND];
U_sTEMPAGCOFFSET    *U_AGC_PATHLOSS_RXD_TABLE[UL1D_RF_CUSTOM_BAND]; //RXD path loss
#endif
U_sRAMPDATA         *UMTS_RampData[UL1D_RF_CUSTOM_BAND];
U_sPAOCTLVLSETTING  *U_PA_OCTLEV_TABLE[UL1D_RF_CUSTOM_BAND];
U_sPARACHTMCOMPDATA *U_PA_RACH_COMP_TABLE[UL1D_RF_CUSTOM_BAND];
U_sPADRIFTSETTING   *U_PA_DRIFT_TABLE[UL1D_RF_CUSTOM_BAND];

#if __IS_UL1D_DPD_SUPPORT__
U_sDPD_GROUP_ALL          *p_U_DPD_GROUP_TABLE[UL1D_RF_CUSTOM_BAND];
U_sUl1dDpdCustomInputData *UMTS_DPD_CUSTOM_INPUT_DATA_ptr;
DPD_ENABLE_E              *UMTS_DPD_ENABLE_ptr;
#endif

U_sAFCDACDATA       *U_AFC_DAC_ptr;
U_sAFCCAPDATA       *U_AFC_CAP_ptr;
kal_uint16          *U_TEMP_DAC_ptr;

UMTS_RF_POWER_ON_CAL_DATA_T   *U_POC_CAL_DATA_ptr = NULL;

#if IS_3G_TAS_UL1_CUSTOM_SUPPORT
UMTS_CUSTOM_TAS_FE_DATABASE_T       *UMTS_TAS_FE_DATABASE_TABLE_ptr = NULL;
UMTS_CUSTOM_TAS_FE_ROUTE_DATABASE_T *UMTS_TAS_FE_ROUTE_TABLE_ptr = NULL;
UMTS_CUSTOM_TAS_FEATURE_BY_RAT_T    *UMTS_TAS_FEATURE_BY_RAT_ptr = NULL;
#if IS_3G_TAS_TST_SUPPORT
UMTS_CUSTOM_TAS_TST_FE_ROUTE_DATABASE_T *UMTS_TAS_TST_FE_ROUTE_DATABASE_ptr = NULL;
#endif
#if IS_3G_TAS_INHERIT_4G_ANT
UMTS_CUSTOM_TAS_INHERIT_LTE_BAND_BITMAP_TABLE_T *UMTS_TAS_INHERIT_LTE_BAND_BITMAP_TABLE_ptr=NULL;
#endif
#endif

#if IS_3G_DAT_UL1_CUSTOM_SUPPORT
UMTS_CUSTOM_DAT_FE_DATABASE_T       *UMTS_DAT_FE_DATABASE_TABLE_ptr = NULL;
UMTS_CUSTOM_DAT_FE_ROUTE_DATABASE_T *UMTS_DAT_FE_ROUTE_TABLE_ptr = NULL;
UMTS_CUSTOM_DAT_FEATURE_BY_RAT_T    *UMTS_DAT_FEATURE_BY_RAT_ptr = NULL;
#endif

#if IS_3G_RFEQ_COEF_SUBBAND_SUPPORT
hs_dsch_rfeq_info_band_T *UMTS_RFEQ_COEF_TABLE[UL1D_RF_CUSTOM_BAND];
#endif

#if IS_3G_RFEQ_REAL_COEF_TEST
URXDFE_REAL_RFEQ_CUSTOM_BAND_T *UMTS_RFEQ_REAL_COEF_TABLE[UL1D_RF_CUSTOM_BAND];
#endif

