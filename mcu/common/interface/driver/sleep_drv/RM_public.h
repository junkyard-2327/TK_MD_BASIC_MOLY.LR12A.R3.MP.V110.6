/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 *
 * Filename:
 * ---------
 *    RM_public.h
 *
 * Project:
 * --------
 *    MT6280
 *
 * Description:
 * ------------
 *    Resource Management configuration
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
//#ifdef __CENTRALIZED_SLEEP_MANAGER__

#ifndef RM_PUBLIC_H
#define RM_PUBLIC_H

#include "kal_general_types.h"
#include "sleepdrv_common.h"


typedef enum
{
   /* Resource on MCU RM */
   //RM_MCU_BASE = 0,
   /* Resource on MODEM RM */
   MODEM_SLV_START = 0,
   RM_MD2G_SPEECH  = 0,
   RM_C2K_TRIGGER  = 4,
   RM_LTE_CS       = 5,
   RM_FDD_TD       = 6,/* talking & datalink */
   RM_FDD_DL       = 7, /* datalink */
   MODEM_SLV_END   = 7,
   MODEM_DBG_START = 8,
   RM_TDD_TD       = 11,
   RM_TDD_DL       = 12,
   MODEM_DBG_END   = 12,
   NUMBER_OF_RESOURCE,
   /*Move original declared into RM_Module. */
   RM_MODEM_BASE = 20,
   RM_MODEM_DSP_1,
   RM_MODEM_DSP_2,
   RM_MODEM_L2_COPRO,
   NUMBER_OF_RM_MODEM
} RM_Module;

typedef enum
{
   L1_TXSYS_REQ_FDD           = 0,
   L1_TXSYS_REQ_TDD           = 1,
   L1_TXSYS_REQ_C2K1X         = 2,
   L1_TXSYS_REQ_C2KDO         = 3,
   L1_TXSYS_REQ_LTE           = 4,
   L1_TXSYS_REQ5              = 5,
   L1_TXSYS_REQ_END           = L1_TXSYS_REQ5,
   L1_CSSYS_REQ0              = 6,
   L1_CSSYS_REQ1              = 7,
   L1_CSSYS_REQ2              = 8,
   L1_CSSYS_REQ3              = 9,
   L1_CSSYS_REQ_LTE           = 10,
   L1_CSSYS_REQ5              = 11,
   L1_CSSYS_REQ_END           = L1_CSSYS_REQ5,
   L1_RAKE_REQ_FDD            = 12,
   L1_RAKE_REQ_LOG            = 13,
   L1_RAKE_REQ_C2K1X          = 14,
   L1_RAKE_REQ_C2KDO          = 15,
   L1_RAKE_REQ_END            = L1_RAKE_REQ_C2KDO,
   L1_BRAM_ALL_REQ_FDD        = 16,
   L1_BRAM_ALL_REQ_TDD        = 17,
   L1_BRAM_ALL_REQ_C2K1X      = 18,
   L1_BRAM_ALL_REQ_C2KDO      = 19,
   L1_BRAM_ALL_REQ_LTE        = 20,
   L1_BRAM_ALL_REQ_LOG        = 21,
   L1_BRAM_ALL_REQ6           = 22,
   L1_BRAM_ALL_REQ7           = 23,
   L1_BRAM_ALL_REQ_END        = L1_BRAM_ALL_REQ7,
   L1_BRAM_RAM_VDSP_REQ_FDD   = 24,
   L1_BRAM_RAM_VDSP_REQ_TDD   = 25,
   L1_BRAM_RAM_VDSP_REQ_C2K1X = 26,
   L1_BRAM_RAM_VDSP_REQ_C2KDO = 27,
   L1_BRAM_RAM_VDSP_REQ_LTE   = 28,
   L1_BRAM_RAM_VDSP_REQ_LOG   = 29,
   L1_BRAM_RAM_VDSP_REQ6      = 30,
   L1_BRAM_RAM_VDSP_REQ7      = 31,
   L1_BRAM_RAM_VDSP_REQ_END   = L1_BRAM_RAM_VDSP_REQ7,
   L1_NUMBER_OF_RESOURCE,
   /* for backward support temo solution */
   L1_MODEM_SLV_START = 0,
   L1_RM_MD2G_SPEECH  = 0,
   L1_RM_C2K_TRIGGER  = 4,
   L1_RM_LTE_CS       = 5,
   L1_RM_FDD_TD       = 6,/* talking & datalink */
   L1_RM_FDD_DL       = 7, /* datalink */
   L1_MODEM_SLV_END   = 7,
   L1_MODEM_DBG_START = 8,
   L1_RM_TDD_TD       = 11,
   L1_RM_TDD_DL       = 12,
   L1_MODEM_DBG_END   = 12
} L1_RM_Module;

/* For TOPSM logger force on resource API */
#define L1_RM_RAKE_MASK     0x0000F000
#define L1_RM_BRAM_ALL_MASK 0x00FF0000


//#define L1_RM_TXSYS_REQ_FDD                     0x1
//#define L1_RM_TXSYS_REQ_TDD                     0x2
//#define L1_RM_TXSYS_REQ_C2K1X                   0x4
//#define L1_RM_TXSYS_REQ_C2KDO                   0x8
//#define L1_RM_TXSYS_REQ_LTE                    0x10
//#define L1_RM_TXSYS_REQ5                       0x20
//#define L1_RM_CSSYS_REQ0                       0x40
//#define L1_RM_CSSYS_REQ1                       0x80
//#define L1_RM_CSSYS_REQ_LTE                   0x100
//#define L1_RM_CSSYS_REQ3                      0x200
//#define L1_RM_CSSYS_REQ4                      0x400
//#define L1_RM_CSSYS_REQ5                      0x800
//#define L1_RM_RAKE_REQ_FDD                   0x1000
//#define L1_RM_RAKE_REQ_C2K1X                 0x2000
//#define L1_RM_RAKE_REQ_C2KDO                 0x4000
//#define L1_RM_RAKE_REQ3                      0x8000
//#define L1_RM_BRAM_BRP_REQ_FDD              0x10000
//#define L1_RM_BRAM_BRP_REQ_TDD              0x20000
//#define L1_RM_BRAM_BRP_REQ_C2K1X            0x40000
//#define L1_RM_BRAM_BRP_REQ_C2KDO            0x80000
//#define L1_RM_BRAM_BRP_REQ_LTE             0x100000
//#define L1_RM_BRAM_BRP_REQ5                0x200000
//#define L1_RM_BRAM_BRP_REQ6                0x400000
//#define L1_RM_BRAM_BRP_REQ7                0x800000
//#define L1_RM_BRAM_RAM_VDSP_REQ_FDD       0x1000000
//#define L1_RM_BRAM_RAM_VDSP_REQ_TDD       0x2000000
//#define L1_RM_BRAM_RAM_VDSP_REQ_C2K1X     0x4000000
//#define L1_RM_BRAM_RAM_VDSP_REQ_C2KDO     0x8000000
//#define L1_RM_BRAM_RAM_VDSP_REQ_LTE      0x10000000
//#define L1_RM_BRAM_RAM_VDSP_REQ_DSPINIT  0x20000000
//#define L1_RM_BRAM_RAM_VDSP_REQ6         0x40000000
//#define L1_RM_BRAM_RAM_VDSP_REQ7         0x80000000

#define L1_RM_TXSYS          (0x1)
#define L1_RM_CSSYS          (0x2)
#define L1_RM_RAKE           (0x4)
#define L1_RM_BRAM_ALL       (0x8)
#define L1_RM_BRAM_RAM_VDSP (0x10)
#define L1_RM_NUM           (0x20)


#define PWR_ABBMIXSYS         (0x1)
#define PWR_MD2GSYS           (0x2)
#define PWR_RXDFESYS          (0x4)
#define PWR_TXSYS             (0x8)
#define PWR_CSSYS            (0x10)
#define PWR_RAKESYS          (0x20)
#define PWR_BRAMSYS          (0x40)
#define PWR_DMCSYS           (0x80)

#define PLL_MD2G              (0x1)
#define PLL_F208M             (0x2)
#define PLL_BSI               (0x4)
#define PLL_TX                (0x8)
#define PLL_CS               (0x10)
#define PLL_RAKE             (0x20)
#define PLL_VDSP             (0x40)
#define PLL_BRP              (0x80)

#if 1 /* legacy code for 92, should remove later */
/* TK6291 power domain mask define start */
#define PWR_L1INFRASYS          (0x1)
#define PWR_TRX_DIG_MACRO       (0x2)
//#define PWR_MD2GSYS             (0x4)
#define PWR_DFESYS              (0x8)
#define PWR_RXBRPSYS           (0x10)
#define PWR_MMUSYS             (0x20)
#define PWR_CSTXBSYS           (0x40)
//#define PWR_RAKESYS            (0x80)
#define PWR_EQSYS1            (0x100)
#define PWR_EQSYS2            (0x200)
#define PWR_EQSYS3            (0x400)
#define PWR_TDINRSYS1         (0x800)
#define PWR_LTXB2SYS         (0x1000)
#define PWR_LTXBSYS          (0x2000)
#define PWR_MIMOSYS          (0x4000)
#define PWR_IMCSYS           (0x8000)
//#define PWR_CSSYS           (0x10000)
#define PWR_MPCSYS          (0x20000)
#define PWR_ICCSYS          (0x40000)
#define PWR_DFE2SYS         (0x80000)
#endif

typedef enum
{
   /* Resource on MCU RM */
   MD_RM_MCU_BASE = 0,

   /* Resource on MODEM RM */
   MD_RM_MODEM_BASE = 10,
   MD_RM_MODEM_DSP_1,
   MD_RM_MODEM_DSP_2,
   MD_RM_MODEM_L2_COPRO,
   MD_NUMBER_OF_RM_MODEM
} MD_RM_Module;


#if  defined(ELBRUS) || defined(MT6763) || defined(MT6739) || defined(MT6771) || defined(MT6765) || defined(MT6761) || defined(MT6768)
typedef enum
{
    MD2AP,
    MD2DSP,
} MDTOPSM_PeerWakeup_Target;

typedef enum
{
	PWR_OFF,
	PWR_ON,
	PWR_CHANGE,
} sm_pwrstate_e;

typedef enum
{
    PLL_MSDC
} PLL_RQST;

typedef enum
{
  CORE0_PWR = 0,
  CORE1_PWR = 1,
  USIP0_PWR = 2,
  USIP1_PWR = 3,
  MML2_PWR = 4,
  MDCORE_PWR = 5,
  MDINFRA_PWR = 6,
  CM2_PWR = 7,
} MDTOPSM_Power_Domain;

#endif

typedef enum
{
   MODEM_TOPSM_EMI_REQ_GSM = 0x0,
   MODEM_TOPSM_EMI_REQ_UMTS = 0x1,
   MODEM_TOPSM_EMI_REQ_LTE = 0x2
} MODEM_TOPSM_EMI_REQ_MODULE;

typedef enum
{
  TIMER_OSTD = 0,
  TIMER_2G,
  TIMER_3G_FDD,
  TIMER_3G_TDD,
  TIMER_C2K_1x,
  TIMER_SSTA0_END = TIMER_C2K_1x,
  TIMER_C2K_do,
  TIMER_4G,
  TIMER_EXT_frame,
  TIMER_NUM
} MODEM_TOPSM_TIMER_MODULE;

typedef enum
{
  TIMER_NORMAL           =  0x1,
  TIMER_MTOFF            =  0x2,
  TIMER_PAUSE            =  0x4,
  TIMER_PRE_PAUSE        =  0x8,
  TIMER_SYSCLK_SETTLE    = 0x10,
  TIMER_CCP_SETTLE       = 0x20,
  TIMER_MTON             = 0x40
} MODEM_TOPSM_TIMER_STATUS;


#if defined(MT6763) || defined(MT6739) || defined(MT6771) || defined(MT6765) || defined(MT6761) || defined(MT6768)
typedef enum
{
   MODEM_TOPSM_PWR_ENUM_ABBMIXSYS,
   MODEM_TOPSM_PWR_ENUM_MD2GSYS,
   MODEM_TOPSM_PWR_ENUM_RXDFESYS,
   MODEM_TOPSM_PWR_ENUM_TXSYS,
   MODEM_TOPSM_PWR_ENUM_CSSYS,   
   MODEM_TOPSM_PWR_ENUM_RAKESYS,
   MODEM_TOPSM_PWR_ENUM_BRAMSYS, 
   MODEM_TOPSM_PWR_ENUM_DMCSYS,
   MODEM_TOPSM_PWR_ENUM_NUM,
   MODEM_TOPSM_PWR_ENUM_AO = MODEM_TOPSM_PWR_ENUM_NUM
} MODEM_TOPSM_PWR_ENUM;

typedef enum
{
   MODEM_TOPSM_PLL_ENUM_MD2G,
   MODEM_TOPSM_PLL_ENUM_F208M,
   MODEM_TOPSM_PLL_ENUM_BSI,
   MODEM_TOPSM_PLL_ENUM_TX,
   MODEM_TOPSM_PLL_ENUM_CS,
   MODEM_TOPSM_PLL_ENUM_RAKE,
   MODEM_TOPSM_PLL_ENUM_VDSP,
   MODEM_TOPSM_PLL_ENUM_BRP,
   MODEM_TOPSM_PLL_ENUM_NUM,
   MODEM_TOPSM_PLL_ENUM_AO = MODEM_TOPSM_PLL_ENUM_NUM
} MODEM_TOPSM_PLL_ENUM;

typedef enum
{
   MODEM_TOPSM_SYSCLK_ENUM_RF1_SYSCLK,
   MODEM_TOPSM_SYSCLK_ENUM_RF2_SYSCLK,
   MODEM_TOPSM_SYSCLK_ENUM_RF1_VRF18,
   MODEM_TOPSM_SYSCLK_ENUM_RF2_VRF18,
   MODEM_TOPSM_SYSCLK_ENUM_NUM
} MODEM_TOPSM_SYSCLK_ENUM;

#elif defined(ELBRUS)

typedef enum
{
   MODEM_TOPSM_PWR_ENUM_L1MCUSYS,
   MODEM_TOPSM_PWR_ENUM_TRX_DIG_MACRO,
   MODEM_TOPSM_PWR_ENUM_MD2GSYS,
   MODEM_TOPSM_PWR_ENUM_DFESYS,
   MODEM_TOPSM_PWR_ENUM_RXBRPSYS,
   MODEM_TOPSM_PWR_ENUM_MMUSYS,
   MODEM_TOPSM_PWR_ENUM_CSTXBSYS,
   MODEM_TOPSM_PWR_ENUM_RAKESYS,
   MODEM_TOPSM_PWR_ENUM_EQSYS1,
   MODEM_TOPSM_PWR_ENUM_EQSYS2,
   MODEM_TOPSM_PWR_ENUM_EQSYS3,
   MODEM_TOPSM_PWR_ENUM_TDINRSYS1,
   MODEM_TOPSM_PWR_ENUM_TDINRSYS2,
   MODEM_TOPSM_PWR_ENUM_LTXBSYS,
   MODEM_TOPSM_PWR_ENUM_MIMOSYS,
   MODEM_TOPSM_PWR_ENUM_IMCSYS,
   MODEM_TOPSM_PWR_ENUM_CSSYS,
   MODEM_TOPSM_PWR_ENUM_MPCSYS,
   MODEM_TOPSM_PWR_ENUM_ICCSYS,
   MODEM_TOPSM_PWR_ENUM_L1INFRASYS,
   MODEM_TOPSM_PWR_ENUM_NUM
} MODEM_TOPSM_PWR_ENUM;

typedef enum
{
   MODEM_TOPSM_PLL_ENUM_L1MCU,
   MODEM_TOPSM_PLL_ENUM_BUS2X,
   MODEM_TOPSM_PLL_ENUM_RF1,
   MODEM_TOPSM_PLL_ENUM_EQ,
   MODEM_TOPSM_PLL_ENUM_BRP,
   MODEM_TOPSM_PLL_ENUM_IMC,
   MODEM_TOPSM_PLL_ENUM_ICC,
   MODEM_TOPSM_PLL_ENUM_CMP,
   MODEM_TOPSM_PLL_ENUM_DFE,
   MODEM_TOPSM_PLL_ENUM_MD2G,
   MODEM_TOPSM_PLL_ENUM_INTF,
   MODEM_TOPSM_PLL_ENUM_NUM
} MODEM_TOPSM_PLL_ENUM;

typedef enum
{
   MODEM_TOPSM_SYSCLK_ENUM_RF1_SYSCLK,
   MODEM_TOPSM_SYSCLK_ENUM_RF2_SYSCLK,
   MODEM_TOPSM_SYSCLK_ENUM_RF1_VRF18,
   MODEM_TOPSM_SYSCLK_ENUM_RF2_VRF18,
   MODEM_TOPSM_SYSCLK_ENUM_NUM
} MODEM_TOPSM_SYSCLK_ENUM;
#endif

/* power domain mask define end */

typedef enum
{
   MEM_CG_CTRL_LTE,
   MEM_CG_CTRL_WCDMA,
   MEM_CG_CTRL_TDS,
   MEM_CG_CTRL_C2K1XRTT,
   MEM_CG_CTRL_C2KEVDO,
   MEM_CG_CTRL_NUM
} MEM_CG_CTRL_CLIENT_ENUM;

#if defined(__MTK_TARGET__)
#define F32K_CNT                              ((volatile kal_uint32*)(BASE_MADDR_MDPERI_MD_TOPSM+0x850))
#else
#define F32K_CNT                              ((volatile kal_uint32*)(MODEM_TOPSM_base+0x850))
#endif

#ifndef MAX
#define MAX(a,b)  ( ( (a) > (b) ) ? (a) : (b) )
#endif

#ifndef MIN
#define MIN(a,b)  ( ( (a) < (b) ) ? (a) : (b) )
#endif

#define MAX4(a,b,c,d) MAX( MAX((a),(b)) , MAX((c),(d)) )
#define MAX6(a,b,c,d,e,f) MAX( MAX((a),(b)) , MAX4((c),(d),(e),(f)))


#if defined(TK6291) /*resource settle*/
//#define RM_SYS_CLK_SETTLE     0x66
#define PLL_SETTLE            0x7
#define MAS_TRIG_EMI_SETTLE       0x14
#define MAS_TRIG_PSBUS_SETTLE     0x8
#define MAS_TRIG_PSBUS_RSV_SETTLE 0x8
#define MAS_TRIG_MIXEDSYS_SETTLE  0xC
#define MAS_TRIG_MAX_SETTLE       MAX4(MAS_TRIG_EMI_SETTLE, MAS_TRIG_PSBUS_SETTLE, MAS_TRIG_PSBUS_RSV_SETTLE, MAS_TRIG_MIXEDSYS_SETTLE)
#define TIMER_TRIG_SETTLE     0x4
#define MAX_PWR_SETTLE        0x5   /* Maximun Power Settling Time			*/
#define RM_RESOURCE_SETTLE                  ( RM_SYS_CLK_SETTLE + 4 + MAX4(PLL_SETTLE, MAX_PWR_SETTLE, MAS_TRIG_MAX_SETTLE, TIMER_TRIG_SETTLE) + 2 )
#define RM_RESOURCE_SETTLE_SYSCLK_FORCEON   ( MAX4(PLL_SETTLE, MAX_PWR_SETTLE, MAS_TRIG_MAX_SETTLE, TIMER_TRIG_SETTLE) + 3 )
#define MAS_TRIG_EMI_SAL          0x8
#define MAS_TRIG_PSBUS_SAL        0x2
#define MAS_TRIG_PSBUS_RSV_SAL    0x2
#define MAS_TRIG_MIXEDSYS_SAL     0x4
#elif defined(MT6755) || defined(ELBRUS) /*resource settle*/
//#define RM_SYS_CLK_SETTLE     0x66
#define PLL_SETTLE                0x5     /* HW_WRITE( L1CORE_TOPSM_SM_CLK_SETTLE, ((PLL_SETTLE<<16) | (RM_SYS_CLK_SETTLE))); */

#define MAS_TRIG_EMI_SETTLE       0x12
#define MAS_TRIG_PSBUS_SETTLE     0x8
//#define MAS_TRIG_PSBUS_RSV_SETTLE 0x8
#define MAS_TRIG_MIXEDSYS_SETTLE  0xC
#define MAS_TRIG_PS_SRC0_SETTLE   0x5

/* max value of GRP settle  PS_SRC0     /MIXEDSYS        /PSBUS               /EMI     */
/* assume Max GRP_settle1 the same as GRP_settle0*/
/*   HW_WRITE( L1CORE_TOPSM_SM_MAS_TRIG_MAX_SETTLE,  0x00000012); */
#define MAS_TRIG_MAX_SETTLE       MAX4(MAS_TRIG_PS_SRC0_SETTLE, MAS_TRIG_MIXEDSYS_SETTLE, MAS_TRIG_PSBUS_SETTLE, MAS_TRIG_EMI_SETTLE)


#define TIMER_TRIG_SETTLE     0x12   /*  HW_WRITE( L1CORE_TOPSM_SM_TIMER_TRIG_SETTLE, TIMER_TRIG_SETTLE);*/
#define MAX_PWR_SETTLE        0x5    /* Maximun Power Settling Time			*/
#define RM_RESOURCE_SETTLE                  ( RM_SYS_CLK_SETTLE + 4 + MAX4(PLL_SETTLE, MAX_PWR_SETTLE, MAS_TRIG_MAX_SETTLE, TIMER_TRIG_SETTLE) + 2 + 1)
#define RM_RESOURCE_SETTLE_SYSCLK_FORCEON   ( MAX4(PLL_SETTLE, MAX_PWR_SETTLE, MAS_TRIG_MAX_SETTLE, TIMER_TRIG_SETTLE) + 3 )
#define MAS_TRIG_EMI_SAL          0x8
#define MAS_TRIG_PSBUS_SAL        0x2
#define MAS_TRIG_PSBUS_RSV_SAL    0x2
#define MAS_TRIG_MIXEDSYS_SAL     0x4

#elif defined(MT6763) || defined(MT6739) || defined(MT6771) || defined(MT6765) ||defined(MT6761) || defined(MT6768) /*resource settle*/
//#define RM_SYS_CLK_SETTLE     0x66
#define PLL_SETTLE                   0x3     /* HW_WRITE( L1CORE_TOPSM_SM_CLK_SETTLE, ((PLL_SETTLE<<16) | (RM_SYS_CLK_SETTLE))); */

#define MAS_TRIG_CORE0_SETTLE        (0xE + 0x11)
#define MAS_TRIG_CORE1_SETTLE        (0xE + 0x11)
#define MAS_TRIG_USIP0_SETTLE        0xB
#define MAS_TRIG_USIP1_SETTLE        0xB
#define MAS_TRIG_MD_COMMRES_SETTLE   (0xB + 0x11)

#if defined(MT6765) //Cervino needs larger emi settle time
#define MAS_TRIG_EMI_SETTLE          (0x1A + 0x11)
#else
#define MAS_TRIG_EMI_SETTLE          (0x12 + 0x11)
#endif

/* max value of GRP settle  PS_SRC0     /MIXEDSYS        /PSBUS               /EMI     */
/* assume Max GRP_settle1 the same as GRP_settle0*/

#define MAS_TRIG_MAX_SETTLE       MAX6(MAS_TRIG_CORE0_SETTLE, MAS_TRIG_CORE1_SETTLE, \
                                       MAS_TRIG_USIP0_SETTLE, MAS_TRIG_USIP1_SETTLE, \
                                       MAS_TRIG_MD_COMMRES_SETTLE, MAS_TRIG_EMI_SETTLE)

#define TIMER_TRIG_SETTLE     (0x4 + 0x11)   /*  HW_WRITE( L1CORE_TOPSM_SM_TIMER_TRIG_SETTLE, TIMER_TRIG_SETTLE);*/
#define MAX_PWR_SETTLE        0x3    /* Maximun Power Settling Time			*/
#define RM_RESOURCE_SETTLE                  ( RM_SYS_CLK_SETTLE + 4 + MAX4(PLL_SETTLE, MAX_PWR_SETTLE, MAS_TRIG_MAX_SETTLE, TIMER_TRIG_SETTLE) + 2 + 1)
#define RM_RESOURCE_SETTLE_SYSCLK_FORCEON   ( MAX4(PLL_SETTLE, MAX_PWR_SETTLE, MAS_TRIG_MAX_SETTLE, TIMER_TRIG_SETTLE) + 3 )

#define MAS_TRIG_CORE0_SAL        0x6
#define MAS_TRIG_CORE1_SAL        0x6
#define MAS_TRIG_USIP0_SAL        0x2
#define MAS_TRIG_USIP1_SAL        0x2
#define MAS_TRIG_MD_COMMRES_SAL   0x2
#define MAS_TRIG_EMI_SAL          0xA

#else /*resource settle*/

#error "please check the resource settle of modem topsm"

#endif /*resource settle*/




void RM_Init( void );

void L1_RM_Resource_Control( L1_RM_Module module, kal_bool resource_on );
void MD_RM_Resource_Control( MD_RM_Module module, kal_bool resource_on );
kal_bool L1_RM_Resource_CheckReady( L1_RM_Module module );
kal_bool L1_RM_Resource_CheckReadyMask( kal_uint32 module_mask );
kal_uint32 L1_RM_Resource_GetReady( void );

kal_bool RM_Resource_CheckReady( RM_Module module );

#if defined(MT6763) || defined(MT6739) || defined(MT6771) || defined(MT6765) || defined(MT6761) || defined(MT6768)
extern kal_uint32 MODEM_TOPSM_GetF32k(void);
#define RM_GetF32k()  MODEM_TOPSM_GetF32k()
#endif

extern void MD_TOPSM_PWR_SW_Control(MDTOPSM_Power_Domain pwr_dom, kal_bool enable);
extern void MD_TOPSM_Init_Other_Cores(void);
extern void MD_TOPSM_SibAttach(void);
extern kal_bool MD_TOPSM_Is_USIP_ForcedOn(void);
extern void MD_TOPSM_PWR_SW_Control_CM2(kal_bool enable);
extern kal_bool MD_TOPSM_Is_Pwr_Domain_on(MDTOPSM_Power_Domain pwr_dom);
extern kal_bool MD_TOPSM_GetCsysReqSta(void);
extern kal_bool MD_TOPSM_IsMDInfraPowerOn(void);
extern kal_bool MD_TOPSM_IsUsipPowerOn(void);
extern kal_uint32 MD_TOPSM_Get_F32K_Cnt(void);

kal_bool MODEM4G_TOPSM_WaitTimerAwake( void );

extern void L1_RM_UL1Resource_SWControl(kal_bool resource_on);
extern void MODEM_TOPSM_DMC_PowerControl(kal_bool on);
extern void MODEM_TOPSM_MD2G_PowerControl(kal_bool on);
extern kal_bool MODEM_TOPSM_CheckPowerRdy(kal_uint32 mask);
extern kal_uint32 MODEM_TOPSM_GetPowerRdy(void);

extern void MODEM_TOPSM_SW_PowerControl(MODEM_TOPSM_TIMER_MODULE timer, kal_uint32 mask, kal_bool on);
extern void MODEM_TOPSM_ClearPowerRdyReg(kal_uint32 mask);
extern kal_bool MODEM_TOPSM_CheckPowerRdyReg(kal_uint32 mask);
extern void MODEM_TOPSM_BypassBRP4GHWMode(void);
extern void MODEM_TOPSM_ResumeBRP4GHWMode(void);
extern MODEM_TOPSM_TIMER_STATUS MODEM_TOPSM_GetTimerStatus(MODEM_TOPSM_TIMER_MODULE timer);
extern void MODEM_TOPSM_ForceOnMTCMOS(kal_uint32 mask);
extern void MODEM_TOPSM_NonForceOnMTCMOS(kal_uint32 mask);
extern void MODEM_TOPSM_ForceOnPLL(kal_uint32 mask);
extern void MODEM_TOPSM_NonForceOnPLL(kal_uint32 mask);
extern kal_bool MODEM_TOPSM_ForceOnDBGCK(void);
extern void MODEM_TOPSM_DisableForceOnDBGCK(void);
extern void MODEM_TOPSM_SW_TRIG_CSYS(kal_bool enable);
extern void MODEM_TOPSM_4GTXHWModeEnable(void);
extern void MODEM_TOPSM_4GTXHWModeDisable(void);
extern void MODEM_TOPSM_ForceOnLogResource(kal_bool enable);

/* Should remove later */
extern void MODEM_TOPSM_SetGPSSyncCon0(kal_uint32 value);
extern void MODEM_TOPSM_SetGPSSyncCon1(kal_uint32 value);

extern kal_uint32 MD_TOPSM_PollingTimingSyncSta(MODEM_TOPSM_TIMER_MODULE timer);
extern kal_uint32 MD_TOPSM_GetSync26M(MODEM_TOPSM_TIMER_MODULE timer);
extern void MD_TOPSM_ClearTimingSyncSta(MODEM_TOPSM_TIMER_MODULE timer);
extern void MD_TOPSM_SetGPSSyncCon0(kal_uint32 value);
extern void MD_TOPSM_SetGPSSyncCon1(kal_uint32 value);
extern kal_bool MD_TOPSM_GetErrorStatus(void);
extern void MODEM_TOPSM_ForceOn26M(kal_bool enable, MODEM_TOPSM_TIMER_MODULE timer);
extern void MODEM_TOPSM_ForceOnVRF18(kal_bool enable);
extern kal_bool MODEM_TOPSM_TPPA_Dump_Current_Info(void);

#ifdef L1_SIM
extern void MODEM_TOPSM_Check_off();
#endif
extern kal_uint32 MODEM_TOPSM_GetPllStatus(void);

extern void MEM_CONF_RAKECentralControl(MEM_CG_CTRL_CLIENT_ENUM client, kal_uint32 value);
extern void CG_CTRL_RAKECentralControl(MEM_CG_CTRL_CLIENT_ENUM client, kal_uint32 value);

#endif /* !RM_PUBLIC_H */
//#endif /*__CENTRALIZED_SLEEP_MANAGER__*/
