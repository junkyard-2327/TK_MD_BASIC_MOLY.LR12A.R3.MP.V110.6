#!/usr/bin/env perl

#***********************************************************************
#[Program]             gen_c_header
#[File]                gen_c_header.pl
#[Version]             V1.0
#[Revision Date]       2010-01-15
#[Author]              Chunming Wang, chunming.wang@mediatek.com, 83533
#[Description]         This file translates Coda-compatible XML files to 
#               c header format documentation for register maps.
#[Copyright]           Copyright (C) 2010 MediaTek Incorporation. All Rights Reserved.
#***********************************************************************
BEGIN {
    unshift @INC, '\\\\srdfs01\\HWRD_Utilities\\CODA_Lite\\Perl\\lib';
    unshift @INC, './lib';
}

use warnings;
use strict;
use Getopt::Long;
use RegisterXmlParser;
use Data::Dumper;
use File::Basename;

my $s_tag;
my $has_tag;
my %tag_hash = ();
my $s_prefix;
my $s_output;

GetOptions(
           'tag=s'      => \$s_tag,
           'o=s'                => \$s_output,
           'prefix'     => \$s_prefix
          );

#------- parsing tags begin ------------
if (defined $s_tag && $s_tag ne "") {
    # support "A, B, C" or "A B C"
    my @tags = split (/\s*,*\s+/, $s_tag);
    foreach my $tag (@tags) {
        $tag_hash {$tag} = 1;
    }
}
$has_tag = (scalar keys (%tag_hash) > 0)  ? 1 : 0;
#------- parsing tags end --------------

my $file = $ARGV [0];
my $width = 32;
my $addr_width = 16;
my ($all_data, $memory_map) = DumpXML ($file);
my $module_name = $all_data -> {"name"};
my $module_addr = $all_data -> {"address"} -> {"address"};
my $target_file = "..//inc//${module_name}\.h";
if (defined($s_output))
{
    $target_file = $s_output;
}
my $out_dir = dirname($target_file);
unless (-d "$out_dir") {
    mkdir $out_dir, 0755 or warn "Can't make $out_dir directory: $!\n";
}
open(TARGET, ">$target_file") || die "\nCan't open target file '$target_file'! $!.\n\n";
my $registers = $all_data -> {"register"};
my $blocks = $all_data -> {"block"};
if (exists $all_data -> {"user-defined"} -> {"Version"}) {
    my $modify_time = localtime;
    my $version = $all_data -> {"user-defined"} -> {"Version"};
    my $file_info = sprintf("%-20s: %s\n", "//[File]", $target_file);
    my $modify_info = sprintf("%-20s: %s\n", "//[Revision time]", $modify_time);
    my $version_info = sprintf("%-20s: %s\n", "//[Version]", $version);
    my $author_info = sprintf("%-20s: %s\n", "//[Author]", $ENV{'USERNAME'});
    my $desc_info = sprintf("%-20s: %s\n", "//[Description]", "This file is auto generated by CODA $0");
    my $year = "2010";
    if ($modify_time =~ /(\d{4,4})$/) {
        $year = $1;
    }
    my $copyright_info =     sprintf("%-20s: %s\n\n", "//[Copyright]", "Copyright (C) $year Mediatek Incorportion. All rights reserved.");
    print TARGET $file_info;
    print TARGET $version_info;
    print TARGET $author_info;
    print TARGET $modify_info;
    print TARGET $desc_info;
    print TARGET $copyright_info;
}

print TARGET "#ifndef __" . $module_name . "_H__\n";
print TARGET "#define __" . $module_name . "_H__\n\n";


# output MACRO
print TARGET "// ----------------- $module_name Register Definition -------------------\n";
print TARGET "typedef volatile struct {\n";
print TARGET DumpModule($memory_map);
print TARGET "} $module_name" . "_REGS" . ", *P" . $module_name . "_REGS;\n\n";

print TARGET "// ---------- $module_name word-offset  ----------\n";
print TARGET DumpRegisterMacros($registers);
print TARGET "\n";
print TARGET DumpFieldMacros($registers);


print TARGET "#endif \/\/ __" . $module_name . "_H__\n";
close(TARGET);
exit 0;

sub DumpXML {
    my ($xml_file) = @_;
    my ($mod_ref, $memory_map) = RegisterXmlParser::ParseXML ($xml_file);
    
    # $mod_ref -> {"name"};
    # $mod_ref -> {"address"} -> {"address"};
    # $mod_ref -> {"description"};
    # $mod_ref -> {"documentation"};
    
    # open FILE, '>', "tree.dump";
    # print FILE Dumper ($mod_ref);
    # close FILE;
    return $mod_ref, $memory_map;
}

sub DumpModule {
    my ($module) = @_;
    my $result = "";
    my $width = 32;
    my $comment_start = 90;

    my $prev_skipped  = 0 ;
    my $prev_addr     = 0 ;
    my $prev_str      = 0 ;

    foreach my $ele (@{$module})
    {
        my $type = $ele -> {"type"};
        my $offset = $ele -> {"address"} -> {"address"};
        next if ($type eq "MEMORY");

    my $offset_val = Util::String2Value($offset);
    if ($prev_skipped) {
      $prev_skipped = 0 ;
      if ($prev_addr != $offset_val  ) {
        $result .= $prev_str ;
      }
    }

        if ($type eq "PADDING")
        {
            my $mod = $offset % 4;
            my $size = $ele -> {"size"};
            if ($mod == 1)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
                my $tmp_str = "kal_uint8  ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                $offset ++;
                
                $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
                $tmp_str = "kal_uint16 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                $offset += 2;    
                $size -= 3;
            }
            elsif ($mod == 2)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
                my $tmp_str = "kal_uint16 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                $offset += 2;
                $size -= 2;                
            }
            elsif ($mod == 3)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
                my $tmp_str = "kal_uint8 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                $offset ++;
                $size --;                
            }
            
            $mod = $size % 4;
            $size -= $mod;
            my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
            my $array_count = $size / 4;
            my $end_offset = $offset + $size;
            my $str_offset = Util::Dec2Hex($addr_width, Util::String2Value($offset));
            my $str_end_offset = Util::GetAbsoluteAddr($module_addr, $end_offset - 4,$addr_width);
            #$end_offset = Util::Dec2Hex(32, $end_offset);
            my $tmp_str = "kal_uint32 ";
            #$tmp_str = AddBlanks($tmp_str, $width);
            if ($array_count > 1)
            {
                $tmp_str = "    ${tmp_str}rsv_${hex_offset}[$array_count];";
                $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// 0x${hex_offset}..0x${str_end_offset}\n";                
            }
            else
            {
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
                $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// 0x${hex_offset}\n";                    
            }

            
            if ($mod ==1)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
                my $tmp_str = "kal_uint8  ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";                
            }
            elsif ($mod == 2)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
                my $tmp_str = "kal_uint16 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";                        
            }
            elsif ($mod == 3)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
                my $tmp_str = "kal_uint8  ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                
                $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset + 1,$addr_width);
                $tmp_str = "kal_uint16 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";                                
            }
        } elsif ($type eq "REGISTER") {
            next if (exists $ele->{"user-defined"}->{"Group"} and $ele->{"user-defined"}->{"Group"} !~ /^\s*$/);

             my $is_skipped = &Skip_Whole_Register($ele);

            my $count = 1;
            my $array_flag = "";
            if ( $ele -> {"count"} !~ /^\s*$/ and Util::String2Value($ele -> {"count"}) > 1)
            {
                $count = Util::String2Value($ele -> {"count"});
                $array_flag = "[${count}]";
            }
            my $size = RegisterXmlParser::GetByteSize($ele);
            my $end_offset = Util::String2Value($offset) + Util::String2Value($size) - $ele -> {"width"} / 8;
            $end_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
            $offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
            #my $tmp_str = AddPrefix($module_name, $ele -> {"name"}, $s_prefix);
             #$tmp_str = AddBlanks($tmp_str, $width);
             my $tmp_str = "kal_uint32 "; # mod for CUIF
            
            my $reg_name = $ele -> {"name"};
            $reg_name =~ s/(${module_name}_)?(.*)/$2/;

      if ($is_skipped) {
        my $reg_width = Util::String2Value($ele->{"width"});
        if    ($reg_width == 8 ) { $tmp_str = "kal_uint8  "  ; }
        elsif ($reg_width == 16) { $tmp_str = "kal_uint16 " ; }
        elsif ($reg_width == 32) { $tmp_str = "kal_uint32 " ; }
        elsif ($reg_width == 64) { $tmp_str = "kal_uint64 " ; }
        else                     { $tmp_str = "kal_uint32 " ; } #!!!!!!!!!!

                #$tmp_str  = AddBlanks($tmp_str, $width); 
        $reg_name = "rsv_${offset}";
      }

      my $tmp_comment ;
            if ( $ele -> {"count"} !~ /^\s*$/ and Util::String2Value($ele -> {"count"}) > 1)
            {
                $tmp_str = "    ${tmp_str}" . $reg_name . "${array_flag};";
                $tmp_str = AddBlanks($tmp_str, $comment_start);
        $tmp_comment = "// 0x${offset}..0x${end_offset}";            
        # $result .= "${tmp_str}// ${offset}..${end_offset}\n";            
            }
            else
            {
                $tmp_str = "    ${tmp_str}" . $reg_name . "${array_flag};";
                $tmp_str = AddBlanks($tmp_str, $comment_start);
                $tmp_comment = "// 0x${offset}";
        #    $result .= "${tmp_str}// ${offset}\n";
            }

      if ($is_skipped) {
        if ($offset_val != $prev_addr) {
          $prev_skipped = 1 ; 
          $prev_str     = "$tmp_str"."$tmp_comment"."  padding-tag-skip\n" ;
        }
      } else {
        $result .= "$tmp_str"."$tmp_comment\n" ;
      }
        }
    $prev_addr = $offset_val ; 
    }
    return $result;
}



sub DumpRegisterMacros {
    my ($registers) = @_;
    my $results = "";
    my $width = 90;
    
    foreach my $reg (@{$registers})
    {
    next if (&Skip_Whole_Register($reg));

        my $reg_name = $reg -> {"name"};
        my $reg_name_prefix = AddPrefix2($module_name, $reg_name, $s_prefix);
        $reg_name =~ s/(${module_name}_)?(.*)/$2/;
        if (! exists $reg -> {"in-block"})
        {
            my $reg_count = 1;
            if ($reg -> {"count"} =~ /^(\d+)$/ and $reg -> {"count"} > 1)
            {
                $reg_count = $1;
            }
            if ($reg_count > 1)
            {
                my $tmp_str = "#define O_${reg_name_prefix}(i)";
                my $word_addr = $reg->{"address"}->{"address"};
                $word_addr = oct($word_addr) if $word_addr =~ /^0/;
                $word_addr = $word_addr >> 2;
                $tmp_str = AddBlanks($tmp_str, $width);
                #$results .= "${tmp_str}(".$word_addr.") \/\* ".$reg->{"address"}->{"address"}." \*\/\n";
                $results .= "${tmp_str}(".$word_addr." + (i))\n";
            }
            else
            {
                my $tmp_str = "#define O_${reg_name_prefix}";
                my $word_addr = $reg->{"address"}->{"address"};
                $word_addr = oct($word_addr) if $word_addr =~ /^0/;
                $word_addr = $word_addr >> 2;
                $tmp_str = AddBlanks($tmp_str, $width);
                #$results .= "${tmp_str}(".$word_addr.") \/\* ".$reg->{"address"}->{"address"}." \*\/\n";
                $results .= "${tmp_str}(".$word_addr.")\n";
            }
        }
    }
    
    return $results;
}



sub DumpFieldMacros {
    my ($registers) = @_;
    my $results = "";
    my $width = 90;

    my $msk_macro = "";


    
    foreach my $reg (@{$registers})
    {
    next if (&Skip_Whole_Register($reg));

        my $reg_name = $reg -> {"name"};
        my $reg_name_prefix = AddPrefix2($module_name, $reg_name, $s_prefix);
        $reg_name =~ s/(${module_name}_)?(.*)/$2/;
        
        $msk_macro .= "// ---------- $reg_name bit-field ----------\n";
        my @bit_fields = @{$reg->{"field"}};

        for (my $i = $#bit_fields; $i >= 0; $i--)
        {
            my $field = $bit_fields[$i];
            if ($field -> {"name"} eq "RESERVED") { next;}
            my $user_define = $field -> {"user-defined"};
            if (exists $user_define -> {"TAG"})
            {
                my $field_tag = $user_define -> {"TAG"};
                next if (Hide_Field($field_tag)); 
            }
             my $tmp_str;
             my $tmp_msk;
             
            $tmp_str = "#define P_${reg_name_prefix}_".$field->{"name"};
            $tmp_str = AddBlanks($tmp_str, $width);
            $msk_macro .= "${tmp_str}" . "(" .$field->{"position"}.")\n";
            
            $tmp_str = "#define L_${reg_name_prefix}_".$field->{"name"};
            $tmp_str = AddBlanks($tmp_str, $width);
            $msk_macro .= "${tmp_str}" . "(" .$field->{"width"}.")\n";
            
            $tmp_str = "#define M_${reg_name_prefix}_".$field->{"name"};
            $tmp_str = AddBlanks($tmp_str, $width);
            if (int($field->{"width"}) == 32) {
                $tmp_msk = "0xFFFFFFFF";
            } else {
                $tmp_msk = sprintf("0x%08X",((1 << int($field->{"width"}))-1) << int($field->{"position"})); 
            }            
            $msk_macro .= "${tmp_str}" . "(" .$tmp_msk.")\n";

        }
        $msk_macro .= "\n";

    }
    $results = $msk_macro;
    return $results;
}

sub AddressComment {
    my ($start, $dword_count) = @_;
    my $comment = sprintf("// %08X", $start);
    if ($dword_count > 1) {
        $comment .= sprintf("..%08X", $start + ($dword_count - 1) * 4 );
    }
    return $comment;
}

sub AddBlanks {
    my ($str, $width) = @_;
    my $str_length = length($str);
    my $blank_num = 1;
    $blank_num = $width - $str_length if ($width > $str_length);
    my $blanks = " " x $blank_num;
    $str .= $blanks;
    return $str;
}

sub AddPrefix {
    my ($module_name, $reg_name, $s_prefix) = @_;
    if (defined($s_prefix))
    { 
        if ($reg_name !~ /^$module_name/)
        {
            $reg_name = $module_name . "_REG_" . $reg_name;
        }
        else
        {
            $reg_name =~ s/^$module_name/${module_name}_REG/;
        }
    }
    else
    {
        $reg_name =~ s/(${module_name}_)?(.*)/REG_$2/;
    }
    return $reg_name;
}

sub AddPrefix2 {
    my ($module_name, $reg_name, $s_prefix) = @_;
    if (defined($s_prefix))
    { 
        if ($reg_name !~ /^$module_name/)
        {
            $reg_name = $module_name . "_" . $reg_name;
        }
    }
    else
    {
        $reg_name =~ s/(${module_name}_)?(.*)/$2/;
    }
    return $reg_name;
}

sub Hide_Field {
    my ($field_tag) = @_;
    
    my $hide_field = 0;

    if ($has_tag && defined $field_tag && $field_tag ne "") {
        $hide_field = 1;

    my @field_tags = split (/\n/, $field_tag);
    foreach my $tag (@field_tags) {
        next if ($tag eq "");
        if (exists $tag_hash {$tag}) {
            $hide_field = 0;
            last;
      }
    }
  }
    return $hide_field;
}

sub Skip_Whole_Register {
    my ($reg) = @_;

  my $skip = 1 ;
    my $field_array = $reg -> {"field"};

    foreach my $field (@{$field_array}) {
        next if ($field -> {"name"} eq "RESERVED");

        my $user_define = $field -> {"user-defined"};
        if (exists $user_define -> {"TAG"}) {
            if (not Hide_Field($user_define -> {"TAG"})) { $skip = 0 ; last;}; 
        } else {
      $skip = 0 ;
      last ;
    }
  }
 
  return $skip ; 
}

