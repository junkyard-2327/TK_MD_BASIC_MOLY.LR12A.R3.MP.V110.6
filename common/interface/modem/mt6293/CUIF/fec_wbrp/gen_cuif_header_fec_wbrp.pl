#!/usr/bin/env perl

#***********************************************************************
#[Program]             gen_c_header
#[File]                gen_c_header.pl
#[Version]             V1.0
#[Revision Date]       2010-01-15
#[Author]              Chunming Wang, chunming.wang@mediatek.com, 83533
#[Description]         This file translates Coda-compatible XML files to 
#		       c header format documentation for register maps.
#[Copyright]           Copyright (C) 2010 MediaTek Incorporation. All Rights Reserved.
#***********************************************************************
BEGIN {
	unshift @INC, '\\\\srdfs01\\HWRD_Utilities\\CODA_Lite\\Perl\\lib';
	unshift @INC, './lib';
}

use warnings;
use strict;
use Getopt::Long;
use RegisterXmlParser;
use Data::Dumper;
use File::Basename;

my $s_tag;
my $has_tag;
my %tag_hash = ();
my $s_prefix;
my $s_output;

GetOptions(
           'tag=s'      => \$s_tag,
           'o=s'				=> \$s_output,
           'prefix'     => \$s_prefix
          );

#------- parsing tags begin ------------
if (defined $s_tag && $s_tag ne "") {
	# support "A, B, C" or "A B C"
	my @tags = split (/\s*,*\s+/, $s_tag);
	foreach my $tag (@tags) {
		$tag_hash {$tag} = 1;
	}
}
$has_tag = (scalar keys (%tag_hash) > 0)  ? 1 : 0;
#------- parsing tags end --------------

my $file = $ARGV [0];
my $width = 32;
my $addr_width = 16;
my ($all_data, $memory_map) = DumpXML ($file);
my $module_name = $all_data -> {"name"};
my $module_addr = $all_data -> {"address"} -> {"address"};
my $target_file = "${module_name}_c_header\.h";
my $target_struct_file = "${module_name}_c_header_struct\.h";
my $strGlobalStruct = uc(${module_name})."_REGS";
my $strGlobalStructBase = uc(${module_name});
if (defined($s_output))
{
	$target_file = $s_output;
	$target_struct_file = $s_output;
	$target_struct_file =~ s/\.h/\_struct\.h/;
}
my $out_dir = dirname($target_file);
unless (-d "$out_dir") {
    mkdir $out_dir, 0755 or warn "Can't make $out_dir directory: $!\n";
}
open(TARGET, ">$target_file") || die "\nCan't open target file '$target_file'! $!.\n\n";
my $registers = $all_data -> {"register"};
my $blocks = $all_data -> {"block"};
if (exists $all_data -> {"user-defined"} -> {"Version"}) {
	my $modify_time = localtime;
	my $version = $all_data -> {"user-defined"} -> {"Version"};
	my $file_info = sprintf("%-20s: %s\n", "//[File]", $target_file);
	my $modify_info = sprintf("%-20s: %s\n", "//[Revision time]", $modify_time);
	my $version_info = sprintf("%-20s: %s\n", "//[Version]", $version);
	my $author_info = sprintf("%-20s: %s\n", "//[Author]", $ENV{'USERNAME'});
	my $desc_info = sprintf("%-20s: %s\n", "//[Description]", "This file is auto generated by CODA $0");
	my $year = "2010";
	if ($modify_time =~ /(\d{4,4})$/) {
		$year = $1;
	}
	my $copyright_info = 	sprintf("%-20s: %s\n\n", "//[Copyright]", "Copyright (C) $year Mediatek Incorportion. All rights reserved.");

	print TARGET $file_info;
	print TARGET $version_info;
	print TARGET $author_info;
	print TARGET $modify_info;
	print TARGET $desc_info;
	print TARGET $copyright_info;
}

print TARGET "#ifndef __" . $module_name . "_CUIF_H__\n";
print TARGET "#define __" . $module_name . "_CUIF_H__\n\n";
print TARGET "#ifndef INCLUDE_DSP_HEADER_MACRO_FEC_WBRP\n";
print TARGET "	#error \"Please include " . $target_file . " via dsp_header_define_fec_wbrp_macro.h\"\n";
print TARGET "#endif\n\n";
print TARGET "#include \"kal_public.h\"\n";
print TARGET "#include \"dsp_header_define_cuif_fec_wbrp.h\"\n\n";

print TARGET DumpModule($memory_map);
print TARGET "\n";

print TARGET DumpFieldMacros2($registers);

print TARGET "#endif \/\* __" . $module_name . "_CUIF_H__ \*\/\n";
close(TARGET);

open(TARGET_STRUCT, ">$target_struct_file") || die "\nCan't open target file '$target_struct_file'! $!.\n\n";
print TARGET_STRUCT "#ifndef __" . $module_name . "_STRUCT_CUIF_H__\n";
print TARGET_STRUCT "#define __" . $module_name . "_STRUCT_CUIF_H__\n\n";
# output struct file
print TARGET_STRUCT "// ----------------- $module_name Register Definition -------------------\n";
print TARGET_STRUCT "typedef volatile struct {\n";
print TARGET_STRUCT DumpModuleStruct($memory_map);
print TARGET_STRUCT "} $module_name" . "_REGS" . ", *P" . $module_name . "_REGS;\n\n";
print TARGET_STRUCT "#endif \/\* __" . $module_name . "_STRUCT_CUIF_H__ \*\/\n";
close(TARGET_STRUCT);
exit 0;

sub DumpModuleStruct {
    my ($module) = @_;
    my $result = "";
    my $width = 32;
    my $comment_start = 60;

    my $prev_skipped  = 0 ;
    my $prev_addr     = 0 ;
    my $prev_str      = 0 ;

    foreach my $ele (@{$module})
    {
        my $type = $ele -> {"type"};
        my $offset = $ele -> {"address"} -> {"address"};
        next if ($type eq "MEMORY");

    my $offset_val = Util::String2Value($offset);
    if ($prev_skipped) {
      $prev_skipped = 0 ;
      if ($prev_addr != $offset_val  ) {
        $result .= $prev_str ;
      }
    }

        if ($type eq "PADDING")
        {
            my $mod = $offset % 4;
            my $size = $ele -> {"size"};
            if ($mod == 1)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
                my $tmp_str = "kal_uint8  ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                $offset ++;
                
                $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
                $tmp_str = "kal_uint16 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                $offset += 2;    
                $size -= 3;
            }
            elsif ($mod == 2)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
                my $tmp_str = "kal_uint16 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                $offset += 2;
                $size -= 2;                
            }
            elsif ($mod == 3)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
                my $tmp_str = "kal_uint8 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                $offset ++;
                $size --;                
            }
            
            $mod = $size % 4;
            $size -= $mod;
            my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
            my $array_count = $size / 4;
            my $end_offset = $offset + $size;
            my $str_offset = Util::Dec2Hex($addr_width, Util::String2Value($offset));
            my $str_end_offset = Util::GetAbsoluteAddr($module_addr, $end_offset - 4,$addr_width);
            #$end_offset = Util::Dec2Hex(32, $end_offset);
            my $tmp_str = "kal_uint32 ";
            #$tmp_str = AddBlanks($tmp_str, $width);
            if ($array_count > 1)
            {
                $tmp_str = "    ${tmp_str}rsv_${hex_offset}[$array_count];";
                $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// 0x${hex_offset}..0x${str_end_offset}\n";                
            }
            else
            {
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
                $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// 0x${hex_offset}\n";                    
            }

            
            if ($mod ==1)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
                my $tmp_str = "kal_uint8  ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";                
            }
            elsif ($mod == 2)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
                my $tmp_str = "kal_uint16 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";                        
            }
            elsif ($mod == 3)
            {
                my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
                my $tmp_str = "kal_uint8  ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";
                
                $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset + 1,$addr_width);
                $tmp_str = "kal_uint16 ";
                #$tmp_str = AddBlanks($tmp_str, $width);
                $tmp_str = "    ${tmp_str}rsv_${hex_offset};";
              $tmp_str = AddBlanks($tmp_str, $comment_start);
                $result .= "${tmp_str}// ${hex_offset}\n";                                
            }
        } elsif ($type eq "REGISTER") {
            next if (exists $ele->{"user-defined"}->{"Group"} and $ele->{"user-defined"}->{"Group"} !~ /^\s*$/);

             my $is_skipped = &Skip_Whole_Register($ele);

            my $count = 1;
            my $array_flag = "";
            if ( $ele -> {"count"} !~ /^\s*$/ and Util::String2Value($ele -> {"count"}) > 1)
            {
                $count = Util::String2Value($ele -> {"count"});
                $array_flag = "[${count}]";
            }
            my $size = RegisterXmlParser::GetByteSize($ele);
            my $end_offset = Util::String2Value($offset) + Util::String2Value($size) - $ele -> {"width"} / 8;
            $end_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
            $offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
            #my $tmp_str = AddPrefix($module_name, $ele -> {"name"}, $s_prefix);
             #$tmp_str = AddBlanks($tmp_str, $width);
             my $tmp_str = "kal_uint32 "; # mod for CSIF
            
            my $reg_name = $ele -> {"name"};
            $reg_name =~ s/(${module_name}_)?(.*)/$2/;
            $reg_name = "CUIF_" . $reg_name;

      if ($is_skipped) {
        my $reg_width = Util::String2Value($ele->{"width"});
        if    ($reg_width == 8 ) { $tmp_str = "kal_uint8  "  ; }
        elsif ($reg_width == 16) { $tmp_str = "kal_uint16 " ; }
        elsif ($reg_width == 32) { $tmp_str = "kal_uint32 " ; }
        elsif ($reg_width == 64) { $tmp_str = "kal_uint64 " ; }
        else                     { $tmp_str = "kal_uint32 " ; } #!!!!!!!!!!

                #$tmp_str  = AddBlanks($tmp_str, $width); 
        $reg_name = "rsv_${offset}";
      }

      my $tmp_comment ;
            if ( $ele -> {"count"} !~ /^\s*$/ and Util::String2Value($ele -> {"count"}) > 1)
            {
                $tmp_str = "    ${tmp_str}" . $reg_name . "${array_flag};";
                $tmp_str = AddBlanks($tmp_str, $comment_start);
        $tmp_comment = "// 0x${offset}..0x${end_offset}";            
        # $result .= "${tmp_str}// ${offset}..${end_offset}\n";            
            }
            else
            {
                $tmp_str = "    ${tmp_str}" . $reg_name . "${array_flag};";
                $tmp_str = AddBlanks($tmp_str, $comment_start);
                $tmp_comment = "// 0x${offset}";
        #    $result .= "${tmp_str}// ${offset}\n";
            }

      if ($is_skipped) {
        if ($offset_val != $prev_addr) {
          $prev_skipped = 1 ; 
          $prev_str     = "$tmp_str"."$tmp_comment"."  padding-tag-skip\n" ;
        }
      } else {
        $result .= "$tmp_str"."$tmp_comment\n" ;
      }
        }
    $prev_addr = $offset_val ; 
    }
    return $result;
}

sub DumpXML {
	my ($xml_file) = @_;
	my ($mod_ref, $memory_map) = RegisterXmlParser::ParseXML ($xml_file);
	
	# $mod_ref -> {"name"};
	# $mod_ref -> {"address"} -> {"address"};
	# $mod_ref -> {"description"};
	# $mod_ref -> {"documentation"};
	
	# open FILE, '>', "tree.dump";
	# print FILE Dumper ($mod_ref);
	# close FILE;
	return $mod_ref, $memory_map;
}

sub DumpUserDefined {
	my ($hash_ref) = @_;
	
	foreach my $name (keys %{$hash_ref}) {

		my $data_ref = $hash_ref -> {$name};
		
		# USER-DEFINED NAME : $name
		# USER-DEFINED VALUE: $data_ref -> {"value"}
	}
}

sub DumpBitFields {
	my ($hash_ref) = @_;
	my $width = 32;
	my $bit_field_array = $hash_ref -> {"field"};
	$bit_field_array = RegisterXmlParser::SortByPosition ($bit_field_array);
	my $result = "";
	my @bit_fields = @{$bit_field_array};
	#foreach my $field (@{$bit_field_array})
	for (my $i = 0; $i <= $#bit_fields; $i++)
	{
		my $field = $bit_fields[$i];
		my $user_define = $field -> {"user-defined"};
		if (exists $user_define -> {"TAG"})
		{
			my $field_tag = $user_define -> {"TAG"};
			next if (Hide_Field($field_tag)); 
		}
		if ($field -> {"name"} eq "RESERVED"  and exists $field -> {"auto-inserted"} and $field -> {"auto-inserted"} = 1)
		{
			my $tmp_str = "FIELD rsv_" . $field -> {"position"};
			$tmp_str = AddBlanks($tmp_str, $width);
			$result .= "        ${tmp_str}" . ": " . $field -> {"width"} . ";\n";
		}
		else
		{ 
			my $tmp_str = "FIELD " . $field -> {"name"};
			$tmp_str = AddBlanks($tmp_str, $width);
			$result .= "        ${tmp_str}" . ": " . $field -> {"width"} . ";\n";			
		}
	}
	return $result;
}

#sub DumpBlocks {
#	my ($hash_ref, $registers) = @_;
#	my $block_register = $hash_ref -> {"block-register"};
#	my $block_addr = $hash_ref -> {"address"} -> {"address"};
#	my $result = "";
#	my $width = 32;
#	my $comment_start = 54;
	
#	foreach my $blk_reg (@{$block_register})
#	{
#		if ($blk_reg -> {"name"} eq "RESERVED"  and exists $blk_reg -> {"auto-inserted"} and $blk_reg -> {"auto-inserted"} = 1)
#		{
			#$result .= "    PADDING rsv_" . $blk_reg -> {"offset"} . "; //" .  $blk_reg -> {"offset"} . "\n";
#			next;
#		}
#		else
#		{
#  		my $array_flag = "";
#  		my $addr_incr = 0;
#  		my $last_ele_addr_num = 0;
#  		my $address_flag = "";
#  		my $last_ele_addr = "";
#  		foreach my $reg (@{$registers})
#  		{
#  			if ($blk_reg -> {"name"} eq $reg -> {"name"})
#  			{
#  				if ( $reg -> {"count"} !~ /^\s*$/ and Util::String2Value($reg -> {"count"}) > 1)
#  				{
#  					$array_flag = "[" . $reg -> {"count"} . "]";
#  					$addr_incr = Util::String2Value($reg -> {"width"}) / 8;
#  					$last_ele_addr_num = Util::String2Value($blk_reg -> {"offset"}) + $addr_incr * (Util::String2Value($reg -> {"count"}) - 1);
#  					#$last_ele_addr_num = Util::Dec2Hex($addr_width, $last_ele_addr_num);
#  					$last_ele_addr_num = Util::GetAbsoluteAddrInBlock($module_addr, $block_addr, $last_ele_addr_num,$addr_width);
#  					$last_ele_addr = "..$last_ele_addr_num";
#  				}
#  				last;
#  			}
#  		}
#  		my $blk_name = $blk_reg -> {"name"};
#  		my $blk_name_prefix = AddPrefix($all_data -> {"name"}, $blk_name, $s_prefix);
#  		my $module_name = $all_data -> {"name"};
#			$blk_name_prefix = AddBlanks($blk_name_prefix, $width);
#			$blk_name =~ s/(${module_name}_)?(.*)/$2/;
#			my $tmp_str = "    ${blk_name_prefix}" . $blk_name . $array_flag . ";";
#			$tmp_str = AddBlanks($tmp_str, $comment_start);
#  		$result .= "${tmp_str}\/\/ " . Util::GetAbsoluteAddrInBlock($module_addr, $block_addr, $blk_reg -> {"offset"},$addr_width) . "$last_ele_addr\n";
#  	}
#	}
#	return $result;
#}

#sub DumpModule {
#	my ($module) = @_;
#	my $result = "";
#	my $width = 32;
#	my $comment_start = 54;
#
#  my $prev_skipped  = 0 ;
#  my $prev_addr     = 0 ;
#  my $prev_str      = 0 ;
#
#	foreach my $ele (@{$module})
#	{
#		my $type = $ele -> {"type"};
#		my $offset = $ele -> {"address"} -> {"address"};
#		next if ($type eq "MEMORY");
#
#    my $offset_val = Util::String2Value($offset);
#    if ($prev_skipped) {
#      $prev_skipped = 0 ;
#      if ($prev_addr != $offset_val  ) {
#        $result .= $prev_str ;
#      }
#    }
#
#		if ($type eq "PADDING")
#		{
#			my $mod = $offset % 4;
#			my $size = $ele -> {"size"};
#			if ($mod == 1)
#			{
#				my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
#				my $tmp_str = "kal_uint8";
#				$tmp_str = AddBlanks($tmp_str, $width);
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#			  $tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";
#				$offset ++;
#				
#				$hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
#				$tmp_str = "kal_uint16";
#				$tmp_str = AddBlanks($tmp_str, $width);
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#			  $tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";
#				$offset += 2;	
#				$size -= 3;
#			}
#			elsif ($mod == 2)
#			{
#				my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
#				my $tmp_str = "kal_uint16";
#				$tmp_str = AddBlanks($tmp_str, $width);
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#			  $tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";
#				$offset += 2;
#				$size -= 2;				
#			}
#			elsif ($mod == 3)
#			{
#				my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
#				my $tmp_str = "kal_uint8";
#				$tmp_str = AddBlanks($tmp_str, $width);
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#			  $tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";
#				$offset ++;
#				$size --;				
#			}
#			
#			$mod = $size % 4;
#			$size -= $mod;
#			my $hex_offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
#			my $array_count = $size / 4;
#			my $end_offset = $offset + $size;
#			my $str_offset = Util::Dec2Hex($addr_width, Util::String2Value($offset));
#			my $str_end_offset = Util::GetAbsoluteAddr($module_addr, $end_offset - 4,$addr_width);
#			#$end_offset = Util::Dec2Hex(32, $end_offset);
#			my $tmp_str = "kal_uint32";
#			$tmp_str = AddBlanks($tmp_str, $width);
#			if ($array_count > 1)
#			{
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset}[$array_count];";
#				$tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}..${str_end_offset}\n";				
#			}
#			else
#			{
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#				$tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";					
#			}
#
#			
#			if ($mod ==1)
#			{
#				my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
#				my $tmp_str = "kal_uint8";
#				$tmp_str = AddBlanks($tmp_str, $width);
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#			  $tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";				
#			}
#			elsif ($mod == 2)
#			{
#				my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
#				my $tmp_str = "kal_uint16";
#				$tmp_str = AddBlanks($tmp_str, $width);
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#			  $tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";						
#			}
#			elsif ($mod == 3)
#			{
#				my $hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
#				my $tmp_str = "kal_uint8";
#				$tmp_str = AddBlanks($tmp_str, $width);
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#			  $tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";
#				
#				$hex_offset = Util::GetAbsoluteAddr($module_addr, $end_offset + 1,$addr_width);
#				$tmp_str = "kal_uint16";
#				$tmp_str = AddBlanks($tmp_str, $width);
#				$tmp_str = "    ${tmp_str}rsv_${hex_offset};";
#			  $tmp_str = AddBlanks($tmp_str, $comment_start);
#				$result .= "${tmp_str}// ${hex_offset}\n";								
#			}
#		} elsif ($type eq "REGISTER") {
#			next if (exists $ele->{"user-defined"}->{"Group"} and $ele->{"user-defined"}->{"Group"} !~ /^\s*$/);
#
#      my $is_skipped = &Skip_Whole_Register($ele);
#
#			my $count = 1;
#			my $array_flag = "";
#			if ( $ele -> {"count"} !~ /^\s*$/ and Util::String2Value($ele -> {"count"}) > 1)
#			{
#				$count = Util::String2Value($ele -> {"count"});
#				$array_flag = "[${count}]";
#			}
#			my $size = RegisterXmlParser::GetByteSize($ele);
#			my $end_offset = Util::String2Value($offset) + Util::String2Value($size) - $ele -> {"width"} / 8;
#			$end_offset = Util::GetAbsoluteAddr($module_addr, $end_offset,$addr_width);
#			$offset = Util::GetAbsoluteAddr($module_addr, $offset,$addr_width);
#			my $tmp_str = AddPrefix($module_name, $ele -> {"name"}, $s_prefix);
#			$tmp_str = AddBlanks($tmp_str, $width);
#			my $reg_name = $ele -> {"name"};
#			$reg_name =~ s/(${module_name}_)?(.*)/$2/;
#
#      if ($is_skipped) {
#        my $reg_width = Util::String2Value($ele->{"width"});
#        if    ($reg_width == 8 ) { $tmp_str = "kal_uint8"  ; }
#        elsif ($reg_width == 16) { $tmp_str = "kal_uint16" ; }
#        elsif ($reg_width == 32) { $tmp_str = "kal_uint32" ; }
#        elsif ($reg_width == 64) { $tmp_str = "kal_uint64" ; }
#        else                     { $tmp_str = "kal_uint32" ; } #!!!!!!!!!!
#
#				$tmp_str  = AddBlanks($tmp_str, $width); 
#        $reg_name = "rsv_${offset}";
#      }
#
#      my $tmp_comment ;
#			if ( $ele -> {"count"} !~ /^\s*$/ and Util::String2Value($ele -> {"count"}) > 1)
#			{
#				$tmp_str = "    ${tmp_str}" . $reg_name . "${array_flag};";
#				$tmp_str = AddBlanks($tmp_str, $comment_start);
#        $tmp_comment = "// ${offset}..${end_offset}";			
#        # $result .= "${tmp_str}// ${offset}..${end_offset}\n";			
#			}
#			else
#			{
#				$tmp_str = "    ${tmp_str}" . $reg_name . "${array_flag};";
#				$tmp_str = AddBlanks($tmp_str, $comment_start);
#				$tmp_comment = "// ${offset}";
#        #	$result .= "${tmp_str}// ${offset}\n";
#			}
#
#      if ($is_skipped) {
#        if ($offset_val != $prev_addr) {
#          $prev_skipped = 1 ; 
#          $prev_str     = "$tmp_str"."$tmp_comment"."  padding-tag-skip\n" ;
#        }
#      } else {
#        $result .= "$tmp_str"."$tmp_comment\n" ;
#      }
#		}
#    $prev_addr = $offset_val ; 
#	}
#	return $result;
#}

sub DumpModule {
	my ($module) = @_;
	my $result = "";
	my $width = 70;

  my $extend_module_name = $module_name;
  my $base_reg_name = $extend_module_name;
  my $struct_name = lc($extend_module_name);

  #my $base_str = "#define ${base_reg_name}";
  #$base_str = AddBlanks($base_str, $width);
  #$result .= "${base_str}((volatile kal_uint32*)(".$strGlobalStructBase."+ offsetof(".$strGlobalStruct.", ".$struct_name."))\n";

  my $rd_result = "";
  my $wr_result = "";


  foreach my $ele (@{$module})
  {
    my $reg_name = $ele -> {"name"};
    my $extend_reg_name = "CUIF_" . $reg_name;
    my $offset = $ele -> {"address"} -> {"address"};
    my $type = $ele -> {"type"};


    if ($type eq "REGISTER")
    {
        my $reg_width = Util::String2Value($ele->{"width"});
        my $tmp_type;
        if($reg_width == 8 ) { $tmp_type = "kal_uint8"  ; }
        elsif ($reg_width == 16) { $tmp_type = "kal_uint16" ; }
        elsif ($reg_width == 32) { $tmp_type = "kal_uint32" ; }
        elsif ($reg_width == 64) { $tmp_type = "kal_uint64" ; }
        else                     { $tmp_type = "kal_uint32" ; } #!!!!!!!!!!
        if (exists $ele -> {"count"} and $ele -> {"count"} !~ /^\s*$/)
        {
            my $extend_reg_name_array = "${reg_name}(i)";

            my $tmp_str = "#define ${extend_reg_name_array}";
            $tmp_str = AddBlanks($tmp_str, $width);
            #$result .= "${tmp_str}(" . $base_reg_name . " + ". $offset . " + ((i) * 0x4))\n";
            $result .= "${tmp_str}((volatile ".$tmp_type."*)(".$strGlobalStructBase." + offsetof(".$strGlobalStruct.", ".$extend_reg_name."[i])))\n";

            $tmp_str = "#define M_${reg_name}_RD(i)";
            $tmp_str = AddBlanks($tmp_str, $width);
            $rd_result .= "${tmp_str}REG_READ(${extend_reg_name_array})\n";

            $tmp_str = "#define M_${reg_name}_WR(i, reg)";
            $tmp_str = AddBlanks($tmp_str, $width);
            $wr_result .= "${tmp_str}REG_WRITE(${extend_reg_name_array}, reg)\n";
        }
        else
        {
            my $tmp_str = "#define ${reg_name}";
            $tmp_str = AddBlanks($tmp_str, $width);
            #$result .= "${tmp_str}(" . $base_reg_name . " + ". $offset . ")\n";
            $result .= "${tmp_str}((volatile ".$tmp_type."*)(".$strGlobalStructBase." + offsetof(".$strGlobalStruct.", ".$extend_reg_name.")))\n";

            $tmp_str = "#define M_${reg_name}_RD()";
            $tmp_str = AddBlanks($tmp_str, $width);
            $rd_result .= "${tmp_str}REG_READ(${reg_name})\n";

            $tmp_str = "#define M_${reg_name}_WR(reg)";
            $tmp_str = AddBlanks($tmp_str, $width);
            $wr_result .= "${tmp_str}REG_WRITE(${reg_name}, reg)\n";
        }
    }
    elsif ($type eq "MEMORY")
    {
        my $tmp_str = "#define ${reg_name}";
        $tmp_str = AddBlanks($tmp_str, $width);
        #$result .= "${tmp_str}(" . $base_reg_name . " + ". $offset . ")\n";
        $result .= "${tmp_str}((volatile kal_uint32*)(".$strGlobalStructBase." + offsetof(".$strGlobalStruct.", ".$extend_reg_name.")))\n";
    }
  }
  $result .= "\n";
  $result .= "${rd_result}";
  $result .= "\n";
  $result .= "${wr_result}";

	return $result;
}



sub RegInBlock {
	my ($reg_name, $blocks) = @_;
	my $not_in = 1;
	foreach my $blk (@{$blocks})
	{
		my $blk_regs = $blk -> {"block-register"};
		foreach my $reg (@{$blk_regs})
		{
			if ($reg_name eq $reg ->{"name"})
			{
				$not_in = 0;
				last;
			}
		}
	} 
	return $not_in;
}

sub DumpRegisterMacros {
	my ($registers) = @_;
	my $results = "";
	my $width = 63;
	
	foreach my $reg (@{$registers})
	{
    next if (&Skip_Whole_Register($reg));

		my $reg_name = $reg -> {"name"};
		my $reg_name_prefix = AddPrefix2($module_name, $reg_name, $s_prefix);
		$reg_name =~ s/(${module_name}_)?(.*)/$2/;
		if (! exists $reg -> {"in-block"})
		{
			my $reg_count = 1;
			if ($reg -> {"count"} =~ /^(\d+)$/ and $reg -> {"count"} > 1)
			{
				$reg_count = $1;
			}
			if ($reg_count > 1)
			{
				my $tmp_str = "#define ${reg_name_prefix}(i)";
				$tmp_str = AddBlanks($tmp_str, $width);
				$results .= "${tmp_str}INREG32(&${module_name}_BASE->" . $reg_name . "[i]) \/\/ " . Util::GetAbsoluteAddr($module_addr, $reg->{"address"}->{"address"}, $addr_width) . "\n";				
			}
			else
			{
				my $tmp_str = "#define ${reg_name_prefix}";
				$tmp_str = AddBlanks($tmp_str, $width);
				$results .= "${tmp_str}INREG32(&${module_name}_BASE->" . $reg_name . ") \/\/ " . Util::GetAbsoluteAddr($module_addr, $reg->{"address"}->{"address"}, $addr_width) . "\n";
			}
		}
	}
	
	return $results;
}

sub DumpFieldMacros {
	my ($registers) = @_;
	my $results = "";
	my $width = 63;
	
	my $field_macro = "";
	my $get_macro = "";
	my $set_macro = "";
	my $val_macro = "";
	
	foreach my $reg (@{$registers})
	{
    next if (&Skip_Whole_Register($reg));

		my $reg_name = $reg -> {"name"};
		my $reg_name_prefix = AddPrefix2($module_name, $reg_name, $s_prefix);
		#$reg_name =~ s/(${module_name}_)?(.*)/$2/;
		
		my @bit_fields = @{$reg->{"field"}};
	#foreach my $field (@{$bit_field_array})
		for (my $i = $#bit_fields; $i >= 0; $i--)
		{
			my $field = $bit_fields[$i];
			if ($field -> {"name"} eq "RESERVED") { next;}
			my $user_define = $field -> {"user-defined"};
			if (exists $user_define -> {"TAG"})
			{
				my $field_tag = $user_define -> {"TAG"};
				next if (Hide_Field($field_tag)); 
			}
			my $tmp_str = "#define ${reg_name}" . "_FLD_" . $field->{"name"};
			$tmp_str = AddBlanks($tmp_str, $width);
			$field_macro .= "${tmp_str}" . "REG_FLD(" . $field->{"width"} . ", " . $field->{"position"} . ")\n";
			
			$tmp_str = "#define ${reg_name}" . "_GET_" . $field->{"name"} . "(reg32)";
			$tmp_str = AddBlanks($tmp_str, $width);			
#			$results .= "${tmp_str}REG_FLD_GET(${reg_name}" . "_FLD_" . $field->{"name"} . $field->{"width"} . ", (reg32))\n";
			$get_macro .= "${tmp_str}REG_FLD_GET(${reg_name}" . "_FLD_" . $field->{"name"} . ", (reg32))\n";
			
			$tmp_str = "#define ${reg_name}" . "_SET_" . $field->{"name"} . "(reg32, val)";
			$tmp_str = AddBlanks($tmp_str, $width);	
#			$results .= "${tmp_str}REG_FLD_SET(${reg_name}" . "_FLD_" . $field->{"name"} . $field->{"width"} . ", (reg32), (val))\n";
			$set_macro .= "${tmp_str}REG_FLD_SET(${reg_name}" . "_FLD_" . $field->{"name"} . ", (reg32), (val))\n";
			
			$tmp_str = "#define ${reg_name}" . "_VAL_" . $field->{"name"} . "(val)";
			$tmp_str = AddBlanks($tmp_str, $width);				
#			$results .= "${tmp_str}REG_FLD_VAL(${reg_name}" . "_FLD_" . $field->{"name"} . $field->{"width"} . ", (val))\n";
			$val_macro .= "${tmp_str}REG_FLD_VAL(${reg_name}" . "_FLD_" . $field->{"name"} . ", (val))\n";
		}
		$field_macro .= "\n";
		$get_macro .= "\n";
		$set_macro .= "\n";
		$val_macro .= "\n";
	}
	$results = $field_macro . $get_macro . $set_macro . $val_macro;
	return $results;
}

sub DumpFieldMacros2 {
	my ($registers) = @_;
	my $results = "";
	my $width = 70;
	
	my $field_macro = "";
	my $get_macro = "";
	my $set_macro = "";
	my $val_macro = "";
	
	foreach my $reg (@{$registers})
	{
    next if (&Skip_Whole_Register($reg));

		my $reg_name = $reg -> {"name"};
		my $reg_name_prefix = AddPrefix2($module_name, $reg_name, $s_prefix);
		#$reg_name =~ s/(${module_name}_)?(.*)/$2/;
		
		my @bit_fields = @{$reg->{"field"}};
	#foreach my $field (@{$bit_field_array})
		for (my $i = $#bit_fields; $i >= 0; $i--)
		{
			my $field = $bit_fields[$i];
			my $fld_str;
			
			if ($field -> {"name"} eq "RESERVED") { next;}
			my $user_define = $field -> {"user-defined"};
			if (exists $user_define -> {"TAG"})
			{
				my $field_tag = $user_define -> {"TAG"};
				next if (Hide_Field($field_tag)); 
			}

      my $uc_field_name = uc($field->{"name"});

      my $lsb_str = "${reg_name}_" . $uc_field_name . "_BIT_LSB";
			my $tmp_str = "#define ${lsb_str}";
			$tmp_str = AddBlanks($tmp_str, $width);
			$field_macro .= "${tmp_str}" . "(" . $field->{"position"} . ")\n";

      my $width_str = "${reg_name}_" . $uc_field_name . "_BIT_WIDTH";
			$tmp_str = "#define ${width_str}";
			$tmp_str = AddBlanks($tmp_str, $width);
			$field_macro .= "${tmp_str}" . "(" . $field->{"width"} . ")\n";

      my $mask_str = "${reg_name}_" . $uc_field_name . "_BIT_MASK";
			$tmp_str = "#define ${mask_str}";
			$tmp_str = AddBlanks($tmp_str, $width);
			$field_macro .= "${tmp_str}" . "((kal_uint32) (((1<<" . $width_str . ")-1) << " .$lsb_str . ") )\n";

#      if ($field -> {"access"} ne "RO" and $field -> {"access"} ne "RU" and $field -> {"access"} ne "RC")
#      {
          $fld_str = "${reg_name}_" . $uc_field_name . "_FLD_WR(reg, val)";
          $tmp_str = "#define ${fld_str}";
          $tmp_str = AddBlanks($tmp_str, $width);
          $field_macro .= "${tmp_str}" . "(reg |= (val) << " . $lsb_str . ")\n";
#      }

#      if ($field -> {"access"} ne "WO" and $field -> {"access"} ne "WC" and $field -> {"access"} ne "W1C")
#      {
          if (exists $reg -> {"count"} and $reg -> {"count"} !~ /^\s*$/)
          {
              $fld_str = "${reg_name}_" . $uc_field_name . "_FLD_RD(i)";
              $tmp_str = "#define ${fld_str}";
              $tmp_str = AddBlanks($tmp_str, $width);
              $field_macro .= "${tmp_str}" . "((M_${reg_name}_RD(i) & " . $mask_str . ") >> " . $lsb_str . ")\n";
          }
          else
          {
              $fld_str = "${reg_name}_" . $uc_field_name . "_FLD_RD()";
              $tmp_str = "#define ${fld_str}";
              $tmp_str = AddBlanks($tmp_str, $width);
              $field_macro .= "${tmp_str}" . "((M_${reg_name}_RD() & " . $mask_str . ") >> " . $lsb_str . ")\n";
          }
#      }

      $field_macro .= "\n";
     }
  }

	return $field_macro;
}

sub AddressComment {
    my ($start, $dword_count) = @_;
    my $comment = sprintf("// %08X", $start);
    if ($dword_count > 1) {
        $comment .= sprintf("..%08X", $start + ($dword_count - 1) * 4 );
    }
    return $comment;
}

sub AddBlanks {
	my ($str, $width) = @_;
	my $str_length = length($str);
	my $blank_num = 1;
	$blank_num = $width - $str_length if ($width > $str_length);
	my $blanks = " " x $blank_num;
	$str .= $blanks;
	return $str;
}

sub AddPrefix {
	my ($module_name, $reg_name, $s_prefix) = @_;
	if (defined($s_prefix))
	{ 
		if ($reg_name !~ /^$module_name/)
		{
			$reg_name = $module_name . "_REG_" . $reg_name;
		}
		else
		{
			$reg_name =~ s/^$module_name/${module_name}_REG/;
		}
	}
	else
	{
		$reg_name =~ s/(${module_name}_)?(.*)/REG_$2/;
	}
	return $reg_name;
}

sub AddPrefix2 {
	my ($module_name, $reg_name, $s_prefix) = @_;
	if (defined($s_prefix))
	{ 
		if ($reg_name !~ /^$module_name/)
		{
			$reg_name = $module_name . "_" . $reg_name;
		}
	}
	else
	{
		$reg_name =~ s/(${module_name}_)?(.*)/$2/;
	}
	return $reg_name;
}

sub Hide_Field {
	my ($field_tag) = @_;
	
	my $hide_field = 0;

	if ($has_tag && defined $field_tag && $field_tag ne "") {
		$hide_field = 1;

    my @field_tags = split (/\n/, $field_tag);
    foreach my $tag (@field_tags) {
    	next if ($tag eq "");
    	if (exists $tag_hash {$tag}) {
    		$hide_field = 0;
    		last;
      }
    }
  }
	return $hide_field;
}

sub Skip_Whole_Register {
	my ($reg) = @_;

  my $skip = 1 ;
	my $field_array = $reg -> {"field"};

	foreach my $field (@{$field_array}) {
		next if ($field -> {"name"} eq "RESERVED");

		my $user_define = $field -> {"user-defined"};
		if (exists $user_define -> {"TAG"}) {
			if (not Hide_Field($user_define -> {"TAG"})) { $skip = 0 ; last;}; 
		} else {
      $skip = 0 ;
      last ;
    }
  }
 
  return $skip ; 
}



